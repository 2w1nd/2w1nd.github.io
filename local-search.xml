<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Project4：Concurrency Control</title>
    <link href="/2022/04/03/CMU15445/Project4%EF%BC%9AConcurrency-Control/"/>
    <url>/2022/04/03/CMU15445/Project4%EF%BC%9AConcurrency-Control/</url>
    
    <content type="html"><![CDATA[<h2 id="0-前言-amp-要求"><a href="#0-前言-amp-要求" class="headerlink" title="0 前言&amp;要求"></a>0 前言&amp;要求</h2><p>​    该部分是做一些并发控制的功能，在DBMS中实现一个<code>Lock Manager</code>，使用其来支持并发执行。锁管理器负责跟踪向事务发出的行级锁，并支持根据隔离级别适当的加上或释放共享锁或排他锁。    </p><p>​    LM的基本思想是：维护一个关于活动事务当前持有的锁的内部数据结构，然后事务在访问数据项之前向LM发出锁请求，LM将根据情况决定锁授予该事务、阻止该事务还是终止该事务。在<code>Task1</code>中就要实现LM中的相关API</p><ol><li><code>LockShared(Transaction, RID)</code>：<code>Transaction txn</code>试图对记录<code>id RID</code>获取一个共享锁。这应该在等待时被阻塞，并且应该在授予时返回<code>true</code>。如果事务回滚(中止)则返回false。</li><li><code>LockExclusive(Transaction, RID)</code>：<code>Transaction txn</code>图对记录<code>id RID</code>进行排他锁。这应该在等待时被阻塞，并且应该在授予时返回<code>true</code>。如果事务回滚(中止)则返回false。</li><li><code>LockUpgrade(Transaction, RID)</code>：<code>Transaction txn</code>试图在记录<code>id RID</code>上将共享锁升级为排他锁。这应该在等待时被阻塞，并且应该在授予时返回<code>true</code>。如果事务回滚(中止)则返回<code>false</code>。这还应该中止事务，如果另一个事务已经在等待升级其锁，则返回<code>false</code>。</li><li><code>Unlock(Transaction, RID)</code>：解锁由事务持有的给定记录<code>id</code>标识的记录。</li></ol><p>​    在设计时，还需要考虑隔离级别<code>READ_UNCOMMITED</code>，<code>READ_COMMITTED</code>和<code>REPEATABLE_READ</code>。LM将根据事务隔离级别来授予或释放锁。</p><p>​    <code>Task2</code>是说实现的锁要注意进行死锁预防，使用<code>WOUND-WAIT</code>算法来决定中止哪些事务。</p><p>​    <code>Task3</code>也就是将实现好的LM应用到Lab3中Executor里，以此增加对并发查询的支持。</p><h2 id="1-实验分析"><a href="#1-实验分析" class="headerlink" title="1 实验分析"></a>1 实验分析</h2><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><p>​    <code>Lock_Manager</code>中有一个<code>lock_table_</code>哈希表，它的类型为<code>std::unordered_map&lt;RID, LockRequestQueue&gt;</code>。其中，又包含了<code>LockRequestQueue</code>和<code>LockRequest</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockRequest</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LockRequest</span>(<span class="hljs-keyword">txn_id_t</span> txn_id, LockMode lock_mode) : <span class="hljs-built_in">txn_id_</span>(txn_id), <span class="hljs-built_in">lock_mode_</span>(lock_mode), <span class="hljs-built_in">granted_</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">txn_id_t</span> txn_id_;<br>    LockMode lock_mode_;<br>    <span class="hljs-keyword">bool</span> granted_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockRequestQueue</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    std::list&lt;LockRequest&gt; request_queue_;<br>    std::condition_variable cv_;<br>    <span class="hljs-keyword">txn_id_t</span> upgrading_ = INVALID_TXN_ID;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​    表示了，对于每个RID（也就是每个tuple），都有一个请求队列<code>LockReuqestQueue</code>，其中有一个<code>list&lt;LockRequest&gt; request_queue_;</code>来存储当前对该tuple的锁请求事务，<code>LockRequest</code>也就是用于描述该事务的id，锁类型，是否授予信息的。</p><p>​                                                                <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220405161057839.png" alt="请求队列">        </p><p>​        在《数据库系统概念》中有关锁管理器的算法。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220405161423834.png" alt="锁管理器算法"></p><h3 id="1-2-死锁预防"><a href="#1-2-死锁预防" class="headerlink" title="1.2 死锁预防"></a>1.2 死锁预防</h3><p>​    <code>wound-wait</code>通过使用抢占与事务回滚来实现死锁预防。当事务$T_i$申请的数据项被$T_j$所持有，当$T_i$的时间戳大于$T_j$的时间戳时（$T_i$比$T_j$年轻），允许$T_i$等待。否则，$T_j$回滚（$T_j$被$T_i$伤害）。</p><h3 id="1-3-2PL"><a href="#1-3-2PL" class="headerlink" title="1.3 2PL"></a>1.3 2PL</h3><p>​    实验建议使用严格两阶段封锁协议来实现某些隔离级别，也就是整个事务分为两个阶段，前一个阶段为加锁（GROWING），后一个阶段为解锁（SHINKING）。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。</p><h3 id="1-4-隔离级别"><a href="#1-4-隔离级别" class="headerlink" title="1.4 隔离级别"></a>1.4 隔离级别</h3><p>​    实验需要支持三种隔离级别：</p><ol><li><code>READ_UNCOMMITED</code>：读未提交，这种在需要时加写锁即可，因为允许脏读的发生，读锁不需要加</li><li><code>READ_COMMITED</code>：读已提交，这要解决脏读的问题，解决方案就是读时上读锁，读完解读锁；写时上写锁，但等到commit时才解写锁；读时上读锁，读完解读锁。这样，永远不会读到未commit的数据，因为上面有写锁。</li><li><code>REPEATABLE_READ</code>：可重复读，这需要解决不可重复读的问题了。也就是一个事务在读两次数据不会被其他事务的写干扰，这里需要用到二阶段封锁协议（2PL）。这样，第二次读取时，前一次的读锁还在，避免了中途被修改</li></ol><h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2 实验过程"></a>2 实验过程</h2><h3 id="2-1-LockShare（共享锁）"><a href="#2-1-LockShare（共享锁）" class="headerlink" title="2.1 LockShare（共享锁）"></a>2.1 LockShare（共享锁）</h3><p>​    首先检查<code>txn</code>是不是<code>aborted</code>，是则返回<code>false</code>；</p><p>​    然后检查<code>txn</code>的隔离级别，如果是<code>READ_UNCOMMIED</code>，是不需要共享锁的，将事务状态设置为<code>ABORTED</code>，返回<code>false</code></p><p>​    检查<code>txn</code>的状态是否是<code>shrinking</code>。根据2PL的性质，该状态下不能申请锁，设置事务状态为<code>ABORTED</code>，返回<code>false</code></p><p>​    判断该事务是否为该tuple加锁过，如果加锁过，返回<code>true</code></p><p>​    然后遍历锁请求队列<code>lock_table[rid].request_queue</code>，如果当前事务（<code>txn</code>）为老事务并且占用独占锁的为新事务，则将新事务（遍历到的事务）abort掉；</p><p>如果当前事务为新事务，老事务为独占锁，则等待，但也要向队列中插入该事务以及<code>sharedlockset</code>中进行标记，然后发出等待信号。</p><p>​    如果遍历过程没有出现以上情况，说明锁队列为空或占用锁队列的均为共享锁，将当前事务状态设置为<code>GROWING</code>并且向队列添加事务即可。</p><h3 id="2-2-LockExeclusive（排他锁）"><a href="#2-2-LockExeclusive（排他锁）" class="headerlink" title="2.2 LockExeclusive（排他锁）"></a>2.2 LockExeclusive（排他锁）</h3><p>​    与共享锁流程大同小异。要注意，如果是shrinking，根据2PL，不能继续申请锁，并且要在可重复读的隔离级别下。</p><p>​    而且，既然是获取排他锁，那么其和其他锁都是不相容的，也就是说，要求该次请求必须为第一个请求，锁才能授予。那么在遍历队列时，如果当前事务为新事务，则要直接<code>abort</code>。</p><h3 id="2-3-LockUpgrade（锁升级）"><a href="#2-3-LockUpgrade（锁升级）" class="headerlink" title="2.3 LockUpgrade（锁升级）"></a>2.3 LockUpgrade（锁升级）</h3><p>​    同样的，但锁升级需要判断该锁是否已经授予，如果已经授予，则返回false即可。否，则标记正在上锁。</p><p>​    遍历队列，如果当前事务为老事务，则<code>abort</code>掉新事务的排他锁；当前事务为新事务，则进行等待。</p><p>​    否则，进行锁升级，取出对头元素，设置为排他锁。</p><h3 id="2-4-UnLock（解锁）"><a href="#2-4-UnLock（解锁）" class="headerlink" title="2.4 UnLock（解锁）"></a>2.4 UnLock（解锁）</h3><p>​    比较简单，遍历锁队列时，找到该事务，将该事务解锁（从队列中删除），再notify所有在该队列中睡眠的事务，因为这种情况下可能会有多个事务都获得锁。然后记得从事务对应的LockSet中删除该RID。还需要记得将事务状态设置为<code>shrinking</code>（<code>repeatable read</code>如果unlock是要shirnking的，<code>read commited</code>如果unlock的是sharelock则不用）。</p><h3 id="2-5-并发执行器"><a href="#2-5-并发执行器" class="headerlink" title="2.5 并发执行器"></a>2.5 并发执行器</h3><p>​    这个部分是增加对并发query execution的支持。</p><p><strong>seq_scan_executor</strong></p><p>​    该executor就是在渎之前要加读锁，并且要注意未提交读情况不需要加锁。并且在<code>Next</code>结尾，如果隔离级别为<code>READ_COMMITED</code>，则直接释放该锁</p><p><strong>update_executor</strong></p><p>​    更新则要加锁独占锁，如果该锁已经被读锁占用，则进行升级锁，否则，加上独占锁。同样，提交读才需要解锁</p><p>​    这里要记得记录事务变更</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">IndexWriteRecord <span class="hljs-title">write_record</span><span class="hljs-params">(tuple_rid, table_info_-&gt;oid_, WType::DELETE, new_tuple, index-&gt;index_oid_,</span></span><br><span class="hljs-params"><span class="hljs-function">                              exec_ctx_-&gt;GetCatalog())</span></span>;<br>write_record.old_tuple_ = old_tuple;<br>txn-&gt;<span class="hljs-built_in">GetIndexWriteSet</span>()-&gt;<span class="hljs-built_in">emplace_back</span>(write_record);<br></code></pre></td></tr></table></figure><p><strong>insert_executor</strong></p><p>​    和更新一样</p><p><strong>delete_executor</strong></p><p>​    同上= =</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>​    这部分是实现一个锁管理器，用来支持事务的并发执行。使用2PL来控制事务的并发，使用<code>wound-wait</code>策略来避免死锁，考虑了三种隔离级别。感觉难度还行，在实现时考虑的因素没有lab2要多，但很多细节需要注意就是。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系 - 美团技术团队 (meituan.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/420140287">15445-lab4：concurrency_control - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/zszmhd/p/3365220.html">两阶段锁协议 - 使命召唤 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.epis2048.net/2021/15445-lab4/">CMU-15445-BusTub 笔记 - Lab 4: Concurrency Control | 吃着土豆坐地铁的博客 (epis2048.net)</a></p>]]></content>
    
    
    <categories>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第75场双周赛</title>
    <link href="/2022/04/03/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC75%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/04/03/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC75%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-bit-flips-to-convert-number/">6033. 转换数字的最少位翻转次数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minBitFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> bit = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uint32_t</span> t = start, t1 = goal;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (start != goal) &#123;<br>            <span class="hljs-keyword">int</span> x = (start &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> y = (goal &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (x != y) &#123;<br>                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>                    start &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; i);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    start |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>                &#125;<br>                res ++;<br>            &#125;<br>            i ++;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-triangular-sum-of-an-array/">6034. 数组的三角和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>模拟队列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">triangularSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num: nums) q.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">int</span> bunner = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> a = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> b = q.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">int</span> sum = a + b;<br>            q.<span class="hljs-built_in">push</span>(sum % <span class="hljs-number">10</span>);<br>            i ++;<br>            <span class="hljs-keyword">if</span> (i == bunner) &#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>                i = <span class="hljs-number">0</span>;<br>                bunner = q.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>空间复杂度1做法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">triangularSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i --) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>                nums[j] = (nums[j] + nums[j + <span class="hljs-number">1</span>]) % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/">6035. 选择建筑的方案数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">numberOfWays</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n1 = <span class="hljs-number">0</span>, n01 = <span class="hljs-number">0</span>, n10 = <span class="hljs-number">0</span>, n0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                n01 += n0;<br>                n1 ++;<br>                res += n10;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                n10 += n1;<br>                n0 ++;<br>                res += n01;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>前缀和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">numberOfWays</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> zeroCount = <span class="hljs-number">0</span>, oneCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                count[i] = oneCount;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count[i] = zeroCount;<br>            &#125;<br>            zeroCount += s[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            oneCount += s[i] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        zeroCount = oneCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                count[i] *= oneCount;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count[i] *= zeroCount;<br>            &#125;<br>            zeroCount += s[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            oneCount += s[i] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            res += count[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/">6036. 构造字符串的总得分和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>字符串哈希+二分</p><p>扩展kmp</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LC双周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project3：Query Execution</title>
    <link href="/2022/04/01/CMU15445/Project3%EF%BC%9AQuery-Execution/"/>
    <url>/2022/04/01/CMU15445/Project3%EF%BC%9AQuery-Execution/</url>
    
    <content type="html"><![CDATA[<h2 id="0-前言-amp-要求"><a href="#0-前言-amp-要求" class="headerlink" title="0 前言 &amp; 要求"></a>0 前言 &amp; 要求</h2><p>​    该部分是让我们实现一个执行器，从而实现以下操作：</p><ul><li><strong>Access Methods:</strong> Sequential Scans, Index Scans (with your B+Tree from <a href="https://15445.courses.cs.cmu.edu/fall2020/project2">Project #2</a>)</li><li><strong>Modifications:</strong> Inserts, Updates, Deletes</li><li><strong>Miscellaneous:</strong> Nested Loop Joins, Index Nested Loop Joins, Aggregation, Limit/Offset</li></ul><p>​    所有的执行器采用火山模型，也就是<strong>所有的 executor 向外暴露一个 Next 接口</strong>，ExecutorEngine 通过调用 Next 接口得到一条 tuple。</p><p>​    一共有九个执行器。对于每种查询计划运算符类型，都有一个相应的执行器对象来实现Init和Next方法。Init方法初始化操作符的内部状态（如检索要扫表的对应表）。Next方法提供迭代器的接口，该接口在每次调用时返回一个记录和对应的RID（也可能是执行器已经结束的标志）。</p><p>​    对应的头文件如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>seq_scan_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/i</span>nsert_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/u</span>pdate_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>delete_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>nested_loop_join_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>hash_join_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>aggregation_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>limit_executor.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/executors/</span>distinct_executor.h<br></code></pre></td></tr></table></figure><p>​    每个执行器负责处理单个的Plan Node类型。Plan Node是组成查询计划的各个元素。每个Plan Node可以定义他所代表的操作符的特定信息。如：顺序扫描的Plan Node必须为执行扫描的表定义标识符，而Limit的Plan Node不需要此信息。相应的Plan Node在如下文件定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>seq_scan_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/i</span>nsert_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/u</span>pdate_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>delete_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>nested_loop_join_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>hash_join_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>aggregation_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>limit_plan.h<br>src<span class="hljs-regexp">/include/</span>execution<span class="hljs-regexp">/plans/</span>distinct_plan.h<br></code></pre></td></tr></table></figure><h2 id="1-实验分析"><a href="#1-实验分析" class="headerlink" title="1 实验分析"></a>1 实验分析</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>​    该实验的难点感觉在于有许多API，类需要自己去研究，不然很难理清执行的逻辑，下面分析一些重要的概念与流程</p><p><strong>ExecutionEngine</strong>：用于执行查询计划，其中只有一个Execute函数。该函数逻辑不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Execute</span><span class="hljs-params">(<span class="hljs-keyword">const</span> AbstractPlanNode *plan, std::vector&lt;Tuple&gt; *result_set, Transaction *txn,</span></span><br><span class="hljs-params"><span class="hljs-function">             ExecutorContext *exec_ctx)</span> </span>&#123;<br>  <span class="hljs-comment">// 创建一个执行器</span><br>  <span class="hljs-keyword">auto</span> executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, plan);<br><br>  <span class="hljs-comment">// 对执行器进行初始化</span><br>  executor-&gt;<span class="hljs-built_in">Init</span>();<br><br>  <span class="hljs-comment">// 执行查询</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    Tuple tuple;<br>    RID rid;<br>    <span class="hljs-keyword">while</span> (executor-&gt;<span class="hljs-built_in">Next</span>(&amp;tuple, &amp;rid)) &#123; <span class="hljs-comment">// 循环调用执行的Next函数，并将结果插入result set中</span><br>      <span class="hljs-keyword">if</span> (result_set != <span class="hljs-literal">nullptr</span>) &#123;<br>        result_set-&gt;<span class="hljs-built_in">push_back</span>(tuple);<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (Exception &amp;e) &#123;<br>    <span class="hljs-comment">// TODO(student): handle exceptions</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ExecutorFactory</strong>：根据Node Plan去创建执行器，以下是其创建执行器的代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;AbstractExecutor&gt; <span class="hljs-title">ExecutorFactory::CreateExecutor</span><span class="hljs-params">(ExecutorContext *exec_ctx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                                  <span class="hljs-keyword">const</span> AbstractPlanNode *plan)</span> </span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (plan-&gt;<span class="hljs-built_in">GetType</span>()) &#123;<br>    <span class="hljs-comment">// Create a new sequential scan executor</span><br>    <span class="hljs-keyword">case</span> PlanType::SeqScan: &#123;<br>      <span class="hljs-keyword">return</span> std::make_unique&lt;SeqScanExecutor&gt;(exec_ctx, <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-keyword">const</span> SeqScanPlanNode *&gt;(plan));<br>    &#125;<br>    <span class="hljs-comment">// Create a new index scan executor</span><br>    <span class="hljs-keyword">case</span> PlanType::IndexScan: &#123;<br>      <span class="hljs-keyword">return</span> std::make_unique&lt;IndexScanExecutor&gt;(exec_ctx, <span class="hljs-keyword">dynamic_cast</span>&lt;<span class="hljs-keyword">const</span> IndexScanPlanNode *&gt;(plan));<br>    &#125;<br>    ......<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Execution Plan</strong>：Executor Type Specific的创建参数（包含children、predicate、table_oid等）。对应类为<code>AbstractPlanNode</code>，其中主要函数与对象为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">此计划节点的输出模式。在火山模型中，每个计划节点都会吐出元组，这告诉您这个计划节点的元组将具有什么模式</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> Schema *output_schema_;<br><span class="hljs-comment">/** 此计划节点的子节点 */</span><br>std::vector&lt;<span class="hljs-keyword">const</span> AbstractPlanNode *&gt; children_;<br></code></pre></td></tr></table></figure><p><strong>Execution Context</strong>：Executor Type Irrelavent的创建参数（包含各种manager、catalog等）。一般是指<strong>存储运行程序所需的上下文</strong>。以下是其中包含的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** 与此执行程序上下文关联的事务上下文 */</span><br>Transaction *transaction_;<br><span class="hljs-comment">/** 与此执行程序上下文关联的数据库目录 */</span><br>Catalog *catalog_;<br><span class="hljs-comment">/** 与此执行程序上下文关联的缓冲池管理器 */</span><br>BufferPoolManager *bpm_;<br><span class="hljs-comment">/** 与此执行程序上下文关联的事务管理器 */</span><br>TransactionManager *txn_mgr_;<br><span class="hljs-comment">/** 与此执行器上下文关联的锁管理器 */</span><br>LockManager *lock_mgr_;<br></code></pre></td></tr></table></figure><p><strong>AbstractPlanNode</strong>：对SQL语句的操作进行拆分，形成一个树，其中的每一个节点就对应一个executor，而AbstractPlanNode类包含执行该节点功能需要的一些材料。该抽象类包括其子节点，以及向上返回的列格式（Schema）。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220403165806880.png" alt="image-20220403165806880"></p><p><strong>Schema</strong>：本质是Column类的集合，即一个表中的所有列。其中包含的对象为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** 固定长度的列大小，即一个元组使用的字节数。 */</span><br><span class="hljs-keyword">uint32_t</span> length_;<br><br><span class="hljs-comment">/** schema中的所有列，内嵌和非内嵌的 */</span><br>std::vector&lt;Column&gt; columns_;<br><br><span class="hljs-comment">/** 如果所有列都被内联，则为真，否则为假 */</span><br><span class="hljs-keyword">bool</span> tuple_is_inlined_;<br><br><span class="hljs-comment">/** 所有未内联列的索引 */</span><br>std::vector&lt;<span class="hljs-keyword">uint32_t</span>&gt; uninlined_columns_;<br></code></pre></td></tr></table></figure><p><strong>Column</strong>：列。包含该column的名字、类型，以及一个Expression（optional），描述该column如何构造。其中包含的主要对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** 列名. */</span><br>std::string column_name_;<br><br><span class="hljs-comment">/** 列的长度. */</span><br>TypeId column_type_;<br><br><span class="hljs-comment">/** 对于非内联列，这是指针的大小。否则，固定长度列的大小 */</span><br><span class="hljs-keyword">uint32_t</span> fixed_length_;<br><br><span class="hljs-comment">/** 对于内联列，为 0。否则为可变长度列的长度 */</span><br><span class="hljs-keyword">uint32_t</span> variable_length_&#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">/** 元组中的列偏移 */</span><br><span class="hljs-keyword">uint32_t</span> column_offset_&#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">/** 用于创建此列的表达式 **/</span><br><span class="hljs-keyword">const</span> AbstractExpression *expr_;<br></code></pre></td></tr></table></figure><p><strong>Tuple</strong>：行。包含Data和RID。<strong>注意，tuple中不存储schema</strong>；TableHeap中不直接在page中保存tuple，而是保存serialize后的tuple data。以下是其中的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> allocated_&#123;<span class="hljs-literal">false</span>&#125;;  <span class="hljs-comment">// is allocated?</span><br>RID rid_&#123;&#125;;              <span class="hljs-comment">// 如果指向表堆，则 rid 有效</span><br><span class="hljs-keyword">uint32_t</span> size_&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">char</span> *data_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Value</strong>：表示一个值（Int、Char、Varchar等）。用一个Value vector和一个schema，可以构建一个tuple。</p><p><strong>TableHeap</strong>：磁盘中的一个物理表。其中的主要对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BufferPoolManager *buffer_pool_manager_;<br>LockManager *lock_manager_;<br>LogManager *log_manager_;<br><span class="hljs-keyword">page_id_t</span> first_page_id_&#123;&#125;;<br></code></pre></td></tr></table></figure><p><strong>TableIterator</strong>：提供对TableHeap进行顺序遍历的方法，其只存储了当前一条记录。其重载了一些基本符号，有：==, !=, ++, -&gt;, =。存储一个当前Tuple。在取*时返回该tuple；在递增(++)时，取出该tuple中的rid，在table中定位对应的slot。然后逐slot向下遍历，直至找到下一个valid rid。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TableHeap *table_heap_;<br>Tuple *tuple_;<br>Transaction *txn_;<br></code></pre></td></tr></table></figure><p><strong>RID</strong>：记录tuple的存储位置。包括page id+slot id。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">page_id_t</span> page_id_&#123;INVALID_PAGE_ID&#125;;<br><span class="hljs-keyword">uint32_t</span> slot_num_&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// logical offset from 0, 1...</span><br></code></pre></td></tr></table></figure><p><strong>Expression</strong>：以树的形式递归地表示一个表达式。Expression共包含Const、Comparison、Column、Aggregation四种类型，分别用于不同的场合。</p><p><strong>Catalog</strong>：描述着数据库内部表和索引的元数据，存储着数据库中 有哪些 table， 每个 table 的 schema 是怎么样的，每个 table 有哪些 index， index 有哪些元数据等等。以下是其中包含的两个主要对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> TableInfo *NULL_TABLE_INFO&#123;<span class="hljs-literal">nullptr</span>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> IndexInfo *NULL_INDEX_INFO&#123;<span class="hljs-literal">nullptr</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>TableInfo：维护表的有关数据，其中包含的主要对象：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** The table schema */</span><br>Schema schema_;<br><span class="hljs-comment">/** The table name */</span><br><span class="hljs-keyword">const</span> std::string name_;<br><span class="hljs-comment">/** An owning pointer to the table heap */</span><br>std::unique_ptr&lt;TableHeap&gt; table_;<br><span class="hljs-comment">/** The table OID */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">table_oid_t</span> oid_;<br></code></pre></td></tr></table></figure></li><li><p>IndexInfo：维护有关索引的元数据，其中包含的主要对象：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** The schema for the index key */</span><br>Schema key_schema_;<br><span class="hljs-comment">/** The name of the index */</span><br>std::string name_;<br><span class="hljs-comment">/** An owning pointer to the index */</span><br>std::unique_ptr&lt;Index&gt; index_;<br><span class="hljs-comment">/** The unique OID for the index */</span><br><span class="hljs-keyword">index_oid_t</span> index_oid_;<br><span class="hljs-comment">/** The name of the table on which the index is created */</span><br>std::string table_name_;<br><span class="hljs-comment">/** The size of the index key, in bytes */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> key_size_;<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-整体逻辑"><a href="#1-2-整体逻辑" class="headerlink" title="1.2 整体逻辑"></a>1.2 整体逻辑</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220402113526733.png" alt="image-20220402113526733"></p><ol><li>上层组件与Execution Engine交互。</li><li>在Execution Engine中，首先调用Execution Factory递归创建Executor。然后不断调用Executor的Next()方法，生成Tuple。</li><li>在创建Executor时，需要提供Execution Plan与Execution Context。</li></ol><h3 id="1-3-AbstractExpression"><a href="#1-3-AbstractExpression" class="headerlink" title="1.3 AbstractExpression"></a>1.3 AbstractExpression</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220402141339718.png" alt="image-20220402141339718"></p><p>​    该抽象类是所有表达式的基类。它会被建模为树，即每个表达式可能有可变数量的子级。</p><p>​    里面主要实现的方法有以下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>    <span class="hljs-comment">// 通过使用给定模式评估元组获得的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Value <span class="hljs-title">Evaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Tuple *tuple, <span class="hljs-keyword">const</span> Schema *schema)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 返回通过评估join的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Value <span class="hljs-title">EvaluateJoin</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Tuple *left_tuple, <span class="hljs-keyword">const</span> Schema *left_schema, <span class="hljs-keyword">const</span> Tuple *right_tuple,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">const</span> Schema *right_schema)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 返回通过评估聚合获得的值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Value <span class="hljs-title">EvaluateAggregate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;Value&gt; &amp;group_bys, <span class="hljs-keyword">const</span> std::vector&lt;Value&gt; &amp;aggregates)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/** The children of this expression. Note that the order of appearance of children may matter. */</span><br>    std::vector&lt;<span class="hljs-keyword">const</span> AbstractExpression *&gt; children_;<br>    <span class="hljs-comment">/** The return type of this expression. */</span><br>    TypeId ret_type_;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220403160141549.png" alt="image-20220403160141549"></p><ul><li><p>ConstantValueExpression </p><p>  ​    Evaluate()方法返回这个常量。这个Expression主要作为后面类型节点的子树。EvaluateAggregate()方法是给ComparisonExpression的EvaluateAggregate()使用的，可以不管。</p></li><li><p>ColumnValueExpression </p><p>  ​    成员变量<code>tuple_idx_</code>在join操作中指明该列来自于左边的表还是右边的表，<code>col_idx_</code>代表该列在schema中的下标。</p><p>  ​    Evaluate()方法根据输入的tuple和schema返回tuple中该列对应的value。</p><p>  ​    EvaluateJoin()方法与前者不同的是，它接受join操作中两个表的两个tuple，根据tuple_idx_返回真正是该列对应的tuple中对应的value。</p></li><li><p>AggregateValueExpression </p><p>  ​    对应aggregate相关的列，根据类型分为group_by（分组依据）和aggregate（对该列进行取最大值等聚合操作）两种</p><p>  唯一的EvaluateAggregate()方法的用途是分别传入group_by和aggregate对应的value，返回该列对应的那一个value。</p></li><li><p>ComparisonExpression </p><p>  ​    它的两个子树可能是一个</p><ul><li>ColumnValueExpression和一个ConstantValueExpression，Evaluate()对tuple的某列与常数比较判断大小（即WHERE）</li><li>两个ColumnValueExpression，EvaluateJoin()对两个tuple的两列判断是否相等（即JOIN ON）</li><li>一个AggregateValueExpression和一个ComparisonExpression，EvaluateAggregate()对某列aggregate的结果（或者group用到的某列）与常数比较判断大小（即HAVING）。</li></ul></li></ul><h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2 实验过程"></a>2 实验过程</h2><h3 id="2-1-Sequential-Scan"><a href="#2-1-Sequential-Scan" class="headerlink" title="2.1 Sequential Scan"></a>2.1 Sequential Scan</h3><p>​    该执行器用于顺序遍历表并<strong>一次返回一条</strong>记录。其中，SeqScanPlanNode包含将要扫描的表编号以及断言（predicate），如果某条记录不满足<code>predicate</code>，则不允许生成记录，相当于where。</p><p>​    该部分还是比较简单的，定义一个<code>TableIterator</code>用于遍历<code>TableHeap</code>。这里要注意的是：不能直接将<code>TableIterator</code>返回的<code>Tuple</code>作为输出，因为有可能<code>plan</code>中的<code>out_schema</code>仅仅只是<code>TableHeapIterator</code>的一个映射（意思就是可能只需要查询部分列，需要筛选出需要查询的列）。大致筛选代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 筛选哪些列将要返回</span><br>std::vector&lt;Value&gt; values;<br>values.<span class="hljs-built_in">reserve</span>(output_schema-&gt;<span class="hljs-built_in">GetColumnCount</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-built_in">capacity</span>(); ++i) &#123;<br>  values.<span class="hljs-built_in">push_back</span>(output_schema-&gt;<span class="hljs-built_in">GetColumn</span>(i).<span class="hljs-built_in">GetExpr</span>()-&gt;<span class="hljs-built_in">Evaluate</span>(<br>      <span class="hljs-comment">// 注意这里由于TableIterator重载了*运算符，这里返回的是其指向tuple</span><br>      &amp;(*iter_), &amp;(exec_ctx_-&gt;<span class="hljs-built_in">GetCatalog</span>()-&gt;<span class="hljs-built_in">GetTable</span>(plan_-&gt;<span class="hljs-built_in">GetTableOid</span>())-&gt;schema_)));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这样，再使用<code>Tuple temp_tuple(values, output_schema);</code>生成新的<code>Tuple</code>，进行判断<code>predicate</code>即可</p><h3 id="2-2-Insert"><a href="#2-2-Insert" class="headerlink" title="2.2 Insert"></a>2.2 Insert</h3><p>​    InsertExecutor<strong>将记录插入表中并更新索引</strong>。这里的要求是不仅要实现原始插入（<code>Insert into ... Values (...)</code>），还要实现子查询插入（<code>Insert into ... Select ...</code>）。这里要知道的是，要通过<code>exec_ctx_-&gt;GetCatalog()</code>获取<code>catalog</code>，并调用<code>catalog_-&gt;GetTableIndexes(table_info_-&gt;name_)</code>得到某张表的索引。插入索引有提供好的API，直接调用即可。</p><p>​    另外，判断有无子计划通过<code>plan_-&gt;IsRawInsert()</code>，如果有，则需要模仿<code>ExecutionEngine</code>的<code>Execute</code>方法进行子执行器调用。</p><h3 id="2-3-Update"><a href="#2-3-Update" class="headerlink" title="2.3 Update"></a>2.3 Update</h3><p>​    UpdateExecutor<strong>修改指定表中的现有记录并更新其索引。</strong>挺简单，调用子查询器获得<code>Tuple</code>，再使用提供的API生成新元组，最后使用<code>TableHeap</code>中的API进行更新即可。</p><h3 id="2-4-Delete"><a href="#2-4-Delete" class="headerlink" title="2.4 Delete"></a>2.4 Delete</h3><p>​    DeleteExecutor从表中删除记录，并从所有表的索引中删除与其有关的项。和更新差不多，根据子查询器的结果来调用TableHeap标记删除状态，然后更新索引。</p><h3 id="2-5-Nestde-Loop-Join"><a href="#2-5-Nestde-Loop-Join" class="headerlink" title="2.5 Nestde Loop Join"></a>2.5 Nestde Loop Join</h3><p>​    NestedLoopJoinExecutor实现了一个基本的嵌套循环联接，他将两个子执行器中的记录组合在一起。</p><p>​    该执行器应实现本课程中介绍的简单嵌套循环连接算法。也就是说，对于联接的外部表中的每行记录，应考虑内部表中的每行记录。如果满足联接谓词，则应返回记录。这里的实现可以通过计算笛卡尔积并做筛选的方式。可以在<code>Init</code>中计算<code>Join</code>的结果，然后通过<code>Next</code>读取结果。注意使用<code>EvaluateJoin</code>判断两个行是否匹配。然后将匹配列输出到一个<code>output</code>，将每一行push到<code>result</code>中。在Next中返回即可。</p><h3 id="2-6-Hash-Join"><a href="#2-6-Hash-Join" class="headerlink" title="2.6 Hash Join"></a>2.6 Hash Join</h3><p>​    HashJoinExecutor实现了一个哈希连接操作，该操作将来自其两个子执行器的记录组合在一起。顾名思义，哈希连接实在哈希表的帮助下实现的。</p><p>​    这里没有提供哈希方法，所以需要我们来实现，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> bustub &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashJoinKey</span> &#123;</span><br>  Value key_;<br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> HashJoinKey &amp;other) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> key_.<span class="hljs-built_in">CompareEquals</span>(other.key_) == CmpBool::CmpTrue; &#125;<br>&#125;;<br>&#125;  <span class="hljs-comment">// namespace bustub</span><br><br><span class="hljs-keyword">namespace</span> std &#123;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>bustub::HashJoinKey&gt; &#123;<br>  <span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> bustub::HashJoinKey &amp;key)</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> bustub::HashUtil::<span class="hljs-built_in">HashValue</span>(&amp;key.key_); &#125;<br>&#125;;<br>&#125;  <span class="hljs-comment">// namespace std</span><br></code></pre></td></tr></table></figure><p>​    同样的，依旧在<code>Init</code>中求出所有结果，在<code>Next</code>中进行返回。在遍历时，先把左表的内容散列到哈希表里，然后再遍历右表，构造结果。总体思路是先将左表中的全部列根据join条件散列到一张哈希表中，然后遍历右表，右表中的每行数据都要根据join条件的哈希结果在之前得到的哈希表中找到所有行，并一一组合。这样得到的结果才能是笛卡尔积。</p><h3 id="2-7-Aggregation"><a href="#2-7-Aggregation" class="headerlink" title="2.7 Aggregation"></a>2.7 Aggregation</h3><p>​    此执行器将来自单个子执行器的多条记录的结果合并到一条记录中。这是所有执行器最难实现的一个，是基于哈希表实现的，但由于已经提供了一些API，所以只需要调用即可。通过将子查询器的数据插入到哈希表中，然后遍历时判断是否满足having条件。</p><h3 id="2-8-Limit"><a href="#2-8-Limit" class="headerlink" title="2.8 Limit"></a>2.8 Limit</h3><p>​    LimitExecutor<strong>约束其子执行器输出的记录行数</strong>。如果其子执行器生成的记录数小于LimitPlanNode中指定的限制，则此执行器无效，并返回其接收到的所有记录。该执行器实现比较简单，保存一个计数器，然后遍历即可。</p><h3 id="2-9-Distinct"><a href="#2-9-Distinct" class="headerlink" title="2.9 Distinct"></a>2.9 Distinct</h3><p>​    DistinctExecutor<strong>消除从其子执行器得到的重复记录</strong>。在唯一确定的情况下，您的DistinctExecutor应该考虑输入元组的所有列。该执行器实现可以通过哈希表，也就是所有相同的行都会映射到一个相同的key，然后通过其进行去重。</p><h2 id="3-自问自答"><a href="#3-自问自答" class="headerlink" title="3 自问自答"></a>3 自问自答</h2><blockquote><ol><li><p>为什么不增加一个专门的Projection Executor，而是要利用output_schema来实现projection呢？</p><p> ​    对于类似<code>join</code>这种需要将中间结果存储在临时table中的复杂<code>executor</code>，使用<code>output_schema</code>能及时地进行<code>projection</code>操作，可以大大减少存储开销</p></li><li><p>Hash Join，Sort Merge Join 的优缺点，什么时候应该用哪个？</p></li></ol></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/sun-lingyu/p/15316626.html">CMU15-445 Lab3 Query Execution全记录 - sun-lingyu - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb lab_twentyonepilots的博客-CSDN博客_cmu15-445</a></p>]]></content>
    
    
    <categories>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4399面经</title>
    <link href="/2022/03/29/%E6%9D%82%E7%83%A9/4399%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/03/29/%E6%9D%82%E7%83%A9/4399%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一面（13分钟）"><a href="#一面（13分钟）" class="headerlink" title="一面（13分钟）"></a>一面（13分钟）</h2><ol><li>快排and归并</li><li>双亲委派机制</li><li>beanfactory和applicationcontext的区别</li><li>如何解决粘包/拆包</li><li>拥塞控制</li><li>mysql索引？用b+树的好处</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂烩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project2：Hash Index</title>
    <link href="/2022/03/27/CMU15445/Project2%EF%BC%9AHash-Index/"/>
    <url>/2022/03/27/CMU15445/Project2%EF%BC%9AHash-Index/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    本Project将要设计一个以可扩展哈希索引实现的哈希表。</p><h2 id="2-实验内容"><a href="#2-实验内容" class="headerlink" title="2 实验内容"></a>2 实验内容</h2><h3 id="2-1-Page-layouts"><a href="#2-1-Page-layouts" class="headerlink" title="2.1 Page layouts"></a>2.1 Page layouts</h3><p>​    哈希表是要通过DBMS的<code>BufferPoolManager</code>来访问。这意味着不能分配内存来存储信息。所有的东西都必须存储在磁盘页中，这样它们就可以从<code>DiskManager</code>中读/写。如果你创建了一个哈希表，把它的页面写到磁盘上，然后重新启动DBMS，应该能够在重新启动后从磁盘加载回哈希表。</p><p>​    为了支持在页面之上读/写哈希表桶，你将实现两个<code>Page</code>类来存储哈希表的数据。这是要教你如何从<code>BufferPoolManager</code>中分配内存作为页。</p><p><strong>Hash Table Directory Page</strong></p><p>​    此类保存哈希表的所有元数据。它分为如下表所示的字段：</p><table><thead><tr><th>Variable Name</th><th>Size</th><th>Description</th></tr></thead><tbody><tr><td><code>page_id_</code></td><td>4 bytes</td><td>该页面ID</td></tr><tr><td><code>lsn_</code></td><td>4 bytes</td><td>日志序列号</td></tr><tr><td><code>global_depth_</code></td><td>4 bytes</td><td>目录的全局深度</td></tr><tr><td><code>local_depths_</code></td><td>512 bytes</td><td>每个桶的局部深度数组（uint8）</td></tr><tr><td><code>bucket_page_ids_</code></td><td>2048 bytes</td><td>存储桶 page_id_t 数组</td></tr></tbody></table><p><code>bucket_page_ids_ </code>数组将存储桶 id 映射到 <code>page_id_t</code> ids。 <code>bucket_page_ids_ </code>中的第 i 个元素是第 i 个桶的<code>page_id</code>。</p><p>实现<code>src/include/storage/page/hash_table_directory_page.h</code>和<code>src/storage/page/hash_table_directory_page.cpp</code></p><p><strong>Hash  Table Bucket Page</strong></p><p><code>Hash Table Bucket Page</code> 包含三个数组：</p><table><thead><tr><th>Variable Name</th><th>Description</th></tr></thead><tbody><tr><td><code>occupied_</code></td><td>如果<code>array_</code>的第i个索引曾经被占用过，那么<code>occupied_</code>的第i位就是1。</td></tr><tr><td><code>readable_</code></td><td>如果 <code>array_</code> 的第 i 个索引持有可读值，则 <code>readable_</code> 的第 i 位为 1。</td></tr><tr><td><code>array_</code></td><td>保存键值对的数组。</td></tr></tbody></table><p>​    <code>Hash Table Bucket Page</code>中可用的槽数取决于所存储的键和值的类型。您只需要支持固定长度的键和值。键/值的大小在单个哈希表实例中是相同的，但您不能假设它们对于所有实例都相同（例如，哈希表 #1 可以具有 32 位<code>keys</code>，而哈希表 #2 可以具有64 位<code>keys</code>）。</p><p>​    实现<code>src/include/storage/page/hash_table_bucket_page.h</code>和<code>src/storage/page/hash_table_bucket_page.cpp</code>。</p><p>​    每个 <code>Hash Table Directory/Bucket page</code>对应缓冲池获取的内存页的内容（即字节数组 data_）。每次尝试读取或写入页面时，您需要首先使用其唯一的 <code>page_id </code>从缓冲池中获取页面，然后重新解释强制转换为目录或存储桶页面，并在任何写入或读取操作后取消固定页面。</p><hr><p>​    要必须实现的唯一函数如下：    </p><p>Bucket Page: - Insert - Remove - IsOccupied - IsReadable - KeyAt - ValueAt</p><p>Directory Page: - GetGlobalDepth - IncrGlobalDepth - SetLocalDepth - SetBucketPageId - GetBucketPageId</p><h3 id="2-2-Hash-Table-Implementation"><a href="#2-2-Hash-Table-Implementation" class="headerlink" title="2.2 Hash Table Implementation"></a>2.2 Hash Table Implementation</h3><p>​    实现一个使用可扩展散列方案的散列表。它需要支持插入（<code>Insert</code>）、点搜索（<code>GetValue</code>）和删除（<code>Remove</code>）。有许多帮助函数实现或记录了可扩展哈希表的<code>.h</code>文件和 <code>cpp </code>文件。唯一严格的 API 要求是遵守 <code>Insert</code>、<code>GetValue</code>和<code>Remove</code>。您还必须保留原样的 VerifyIntegrity 函数。请随意设计和实现您认为合适的附加功能。`</p><p>​    您的哈希表必须同时支持唯一键和非唯一键。不允许相同键的重复值。这意味着 <code>(key_0, value_0)</code> 和 <code>(key_0, value_1)</code>可以存在于同一个哈希表中，但不能存在 <code>(key_0, value_0) </code>和 <code>(key_0, value_0)</code>。 Insert 方法仅在尝试插入现有的键值对时才返回 false。</p><p>​    您的哈希表实现必须隐藏键/值类型和相关比较器的详细信息，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendibleHashTable</span> &#123;</span><br>   <span class="hljs-comment">// ---</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>​    这些类已经为您实现：</p><table><thead><tr><th>Class Name</th><th>Description</th></tr></thead><tbody><tr><td><code>KeyType</code></td><td>哈希表中每个键的类型。这只会是<code> GenericKey</code>，<code>GenericKey </code>的实际大小是使用模板参数指定和实例化的，并且取决于索引属性的数据类型。</td></tr><tr><td><code>ValueType</code></td><td>哈希表中每个值的类型。这将只是 64 位 RID。</td></tr><tr><td><code>KeyComparator</code></td><td>用于比较两个 <code>KeyType</code>实例是否小于/大于彼此的类。这些将包含在 <code>KeyType </code>实现文件中。 <code>KeyComparator</code> 类型的变量本质上是函数；例如，给定两个键 <code>KeyType key1</code> 和 <code>KeyType key2</code>，以及一个键比较器 <code>KeyComparator cmp</code>，您可以通过 <code>cmp(key1, key2)</code> 比较键</td></tr></tbody></table><p>请注意，可以简单地使用 == 运算符对 <code>ValueType</code>实例进行相等测试。</p><p><strong>Extendible Hashing Implementation Details</strong></p><p>​    此实现要求您实现存储桶拆分/合并和目录增长/收缩。可扩展散列的一些实现跳过了桶的合并，因为它可能在某些情况下导致抖动。我们在这里实现它是为了提供对数据结构的全面理解，并为学习如何管理<code>latches</code>、<code>locks</code>、<code>page operations</code>（获取/锁定/删除/等）提供更多机会。</p><p>目录索引</p><p>​    当插入你的哈希索引时，你将希望使用最小显著位来索引到目录。当然，也可以正确地使用最重要的位，但使用最不重要的位会使目录扩展操作更简单。</p><p>拆分桶</p><p>​    如果没有插入空间，则必须拆分存储桶。如果您发现这样更容易，您可以在桶装满后立即拆分。但是，仅当插入溢出页面时，参考解决方案才会拆分。因此，您可能会发现提供的 API 更适合这种方法。与往常一样，欢迎您考虑自己的内部 API。</p><p>合并桶</p><p>​    当一个桶变空时，必须尝试合并。有一些方法可以通过检查桶的占用率和它们的分割图像来更积极地进行合并，但这些昂贵的检查和额外的合并会增加激动。</p><p>​    为了使事情相对简单，我们提供了以下合并规则：</p><ul><li>只能合并空桶。</li><li>只有当它们的分割图像具有相同的局部深度时，桶才能与其分割图像合并。</li><li>只有局部深度大于 0 的桶才能被合并。</li></ul><p>​    如果您对“分割图像”感到困惑，请查看算法和代码文档。这个概念很自然地就消失了。</p><p>目录增长</p><p>​    这没有什么花哨的规则。您要么必须增加目录，要么不需要。</p><p>目录缩减</p><p>​    只有当每个桶的本地深度严格小于目录的全局深度时才会收缩目录。你可能会看到其他关于目录收缩的测试，但这个测试是微不足道的，因为我们在目录页中保留了本地深度。</p><p><strong>Performance</strong></p><p>​    一个重要的性能细节是仅在需要时才使用写锁和闩锁。总是使用写锁将不可避免地在 Gradescope 上超时。</p><p>​    此外，一种潜在的优化是将您自己的扫描类型考虑到存储桶页面上，这可以避免在某些情况下重复扫描。您会发现检查存储桶页面的许多内容通常涉及全面扫描，因此您可以一次性收集所有这些信息。</p><h3 id="2-3-Concurrency-Control"><a href="#2-3-Concurrency-Control" class="headerlink" title="2.3 Concurrency Control"></a>2.3 Concurrency Control</h3><p>​    到此为止，你可以假设你的哈希表只支持单线程执行。在这最后一个任务中，你将修改你的实现，使其支持多线程同时读/写该表。</p><p>​    你需要在每个桶上设置<code>Latch</code>，这样当一个线程在向一个桶写东西时，其他线程就不会同时读取或修改该索引。你也应该允许多个读者在同一时间读取同一个桶。</p><p>​    当您需要拆分或合并存储桶以及全局深度发生变化时，您将需要锁定整个哈希表。</p><h3 id="Requirements-And-Hints"><a href="#Requirements-And-Hints" class="headerlink" title="Requirements And Hints"></a>Requirements And Hints</h3><p><code>Latchs</code></p><p>​    在这个项目中有两个需要注意的<code>Latches</code>。</p><p>​    第一个是<code>extendible_hash_table.h</code> 中的<code>table_latch_</code>，它在可扩展哈希表上获取锁存器。这来自<code>src/include/common/rwlatch.h</code> 中的 <code>RWLatch </code>类。正如您在代码中看到的，它由 <code>std::mutex</code>支持。</p><p>​    第二个是 <code>src/include/storage/page.h </code>中内置的页面锁定功能。这是您必须用来保护您的存储桶页面的方法。请注意，要对 <code>table_latch_ </code>进行读锁定，您可以从 <code>RWLatch.h</code> 中调用 <code>RLock</code>，但要对存储桶页面进行读锁定，您必须重新解释<code>reinterpret_cast&lt;Page *&gt;</code> 到页面指针，并从页面调用 RLatch 方法。</p><p>​    我们建议您查看可扩展哈希表类，查看其成员，并准确分析哪些锁存器将允许哪些行为。我们还建议您对存储桶页面执行相同的操作。</p><p>​    项目4将通过LockManager.h中的LockManager锁定来探索并发控制。在这个项目中，你根本不需要LockManager。</p><p>事务指针</p><p>​    您可以在需要时简单地将 nullptr 作为事务指针参数传递。这个 <code>Transaction</code> 对象来自 <code>src/include/concurrency/transaction.h</code>。它提供了方法来存储您在遍历哈希表时获取闩锁的页面。您无需执行此操作即可通过测试。</p><h2 id="3-实验思路"><a href="#3-实验思路" class="headerlink" title="3 实验思路"></a>3 实验思路</h2><h3 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h3><p>​    该部分主要是实现<code>Hash Directory Page</code>和<code>Hash Bucket Page</code>，也就是下图左右两部分</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220331144214428.png" alt="image-20220331144214428"></p><p>（由于经常将<code>directory</code>中的<code>bucket</code>和其指向的<code>bucket</code>弄混，故将<code>directory</code>中的称为<code>slot</code>，其指向的称为<code>bucket</code>）</p><p>​    <strong>hash directory page要实现的主要方法如下：</strong></p><p><code>GetGlobalDepthMask</code>：获得全局高度的mask</p><p><code>CanShrink</code>：判断是否可以收缩，只有当有bucket的高度不等于global的高度时才可以</p><p><code>GetLocalHighBit</code>：获得该<code>slot</code>指向的<code>bucket</code>的LHB（最低位）</p><p><code>GetSplitImageIndex</code>：获得该<code>bucket</code>分割后的<code>bucket</code>对应的LHB</p><p>​     <strong>hash Bucket Page要实现的主要方法如下：</strong></p><p><code>GetValue</code>：获取<code>key</code>对应的值，直接遍历到<code>BUCKET_ARRAY_SIZE</code>即可</p><p><code>Insert</code>：插入，插入到可读位的第一个即可</p><p><code>Remove</code>：一样的，遍历到<code>key``value</code>相同位将<code>readable</code>设置即可</p><h4 id="occupied和readable的作用"><a href="#occupied和readable的作用" class="headerlink" title="occupied和readable的作用"></a>occupied和readable的作用</h4><p>值得注意的是，该部分<code>occupied_</code>和<code>readable_</code>均为<code>char</code>数组，也就是说需要同个位运算来确定某个位是否可读或曾被占用。</p><h4 id="零长度数组"><a href="#零长度数组" class="headerlink" title="零长度数组"></a>零长度数组</h4><p>​    在<code>HashTableBucketPage</code>中，保存键值对的数组是这么定义的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MappingType array_[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>这是一个Zero-length array（零长度数组）。它位于结构体/类的最后，本身不占用空间。在声明结构体的时候分配内存，去除掉其他元素的部分就是零长度数组可以访问的部分。</p><p>而类的实例化是不能定义大小的。但是，我们的类比较特殊，它的实际意义是一个页面，而页面的大小是固定的。从测试代码可以看到该类实例化是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> bucket_page = <span class="hljs-keyword">reinterpret_cast</span>&lt;HashTableBucketPage&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, IntComparator&gt; *&gt;(<br>    bpm-&gt;<span class="hljs-built_in">NewPage</span>(&amp;bucket_page_id, <span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">GetData</span>());<br></code></pre></td></tr></table></figure><p>​    定义了一个页面，页面的<code>data</code>部分是全零的字节。使用<code>reinterpret_cast</code>，将这块空白解释为我们的对象。由于类中的成员函数是在代码段的，这块空白实际上被解释为类中的成员函数，内存分配与结构体类似。本题中已经根据页面大小为我们算好了<code>BUCKET_ARRAY_SIZE</code>，所以可以放心地取用这个零成员数组了。</p><h3 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h3><p>​    该部分就是设计<code>Extendible Hash Table</code>了，这一块还是挺难的，难点在于<code>split</code>和<code>merge</code>方法的实现，另外，在设计时还要考虑并发性。</p><p>​    设计前，最好先在纸上模拟下，想好插入和删除主要流程，再动手写代码，可以参考以下两篇文章：</p><blockquote><p><a href="http://www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing-new.html">www.mathcs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing-new.html</a></p><p><a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">Extendible Hashing (Dynamic approach to DBMS) - GeeksforGeeks</a></p></blockquote><p>​    下面来讲讲各个函数的实现思路：</p><h4 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h4><p>​    这一块刚开始觉得好像没有什么需要初始化的，但要注意的是，我们需要初始化<code>directory_page</code>的<code>id</code>以及对应的高度才可以进行后续的操作，另外还可以初始化两个<code>bucket</code></p><h4 id="辅助性函数"><a href="#辅助性函数" class="headerlink" title="辅助性函数"></a>辅助性函数</h4><p><strong>找到对应的<code>bucket index</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 通过HASH 值 &amp; mask 得到对应的 bucket index</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">HASH_TABLE_TYPE::KeyToDirectoryIndex</span><span class="hljs-params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Hash</span>(key) &amp; dir_page-&gt;<span class="hljs-built_in">GetGlobalDepthMask</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根据<code>bucket_page_id</code>得到相应的页指针和<code>bucket_page</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;Page *, HASH_TABLE_BUCKET_TYPE *&gt; <span class="hljs-title">HASH_TABLE_TYPE::FetchBucketPage</span><span class="hljs-params">(<span class="hljs-keyword">page_id_t</span> bucket_page_id)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> bucket_page = buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(bucket_page_id);<br>  <span class="hljs-keyword">auto</span> bucket_page_data = <span class="hljs-keyword">reinterpret_cast</span>&lt;HASH_TABLE_BUCKET_TYPE *&gt;(bucket_page-&gt;<span class="hljs-built_in">GetData</span>());<br>  <span class="hljs-keyword">return</span> std::pair&lt;Page *, HASH_TABLE_BUCKET_TYPE *&gt;(bucket_page, bucket_page_data);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>​    没什么好说，直接通过key找到对应bucket_page，在调用之前写好的<code>GetValue</code>即可</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>​    首先获取一些数据结构，以下是经常使用的三个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> dir_page_data = <span class="hljs-built_in">FetchDirectoryPage</span>();<br><span class="hljs-keyword">auto</span> bucket_page_id = <span class="hljs-built_in">KeyToPageId</span>(key, dir_page_data);<br><span class="hljs-keyword">auto</span> [bucket_page, bucket_page_data] = <span class="hljs-built_in">FetchBucketPage</span>(bucket_page_id);<br></code></pre></td></tr></table></figure><p>​    如果判断对应的<code>page_data</code>没满，直接插入即可，否则，执行<code>SplitInsert</code></p><p>​    进入循环，首先获取常用变量<code>old_global_depth</code>，<code>bucket_idx</code>，<code>bucket_page_id</code>，<code>[bucket_page, bucket_page_data]</code>。</p><p>​    然后对<code>bucket</code>进行分割，首先检查目录是否需要增加，需要则标记。然后将bucket的深度++，调用<code>GetSplitImageIndex</code>得到分割bucet的LHB，然后生成<code>split bucket</code>。然后遍历原<code>bucket</code>中的可读元素，将部分元素rehash到<code>split bucket</code>中。</p><p>​    然后如果<code>dir_page_data</code>大小增加了，要将新增的<code>slot</code>指向相应的<code>bucket</code>。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>​    与插入操作相反，如果<code>remove</code>后空了，则需要进行<code>merge</code>操作</p><p>​    遍历所有<code>bucket id</code>，由于目录大小可能会变小，所以for中不写判断条件，当<code>i &gt;= dir_page_data-&gt;Size()</code>，则<code>break</code>。<code>merge</code>时判断<code>bucket</code>是否为空，为空，再对<code>split bucket</code>深度进行判断，如果为原<code>bucket</code>深度，则将这两个深度–，然后将分割bucket的<code>pageID</code>赋给原<code>bucket</code>。然后遍历找到原pageID和分割pageID对应的bucketIdx，将他们的pageID都设置为分割pageID。这样操作完后，无论分割bucket还是原bucket，它们的page都是分割后的page。</p><h2 id="4-自问自答"><a href="#4-自问自答" class="headerlink" title="4 自问自答"></a>4 自问自答</h2><blockquote><ol><li><p>什么是<code>split image</code>？</p><p> ​    我的理解是split出来的bucket对应的LHB</p></li><li><p><code>GetLocalHighBit</code>的作用是什么？</p><p> ​    得到某个bucket对应的LHB</p></li><li><p><code>mask</code>的作用是什么？</p><p> ​    用于计算Hash Value后n位的（通常，n为depth的位数，例如depth为2，则mask为011）</p></li><li><p><code>occupied</code>的作用是什么？</p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project0：C++ Primer</title>
    <link href="/2022/03/23/CMU15445/Project0%EF%BC%9AC-Primer/"/>
    <url>/2022/03/23/CMU15445/Project0%EF%BC%9AC-Primer/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    这个project是个预热，帮助提前了解实验环境和c++基本操作。目标 就是 实现一些操作矩阵的函数</p><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2 环境搭建"></a>2 环境搭建</h2><ol><li><p>打开<code>bustub</code>的github地址，<a href="https://github.com/cmu-db/bustub.git">https://github.com/cmu-db/bustub.git</a></p></li><li><p>将项目克隆到本地</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --bare https://github.com/cmu-db/bustub.git bustub-public<br></code></pre></td></tr></table></figure></li><li><p>在自己的github仓库中新建一个<code>bustub-private</code>，并打开终端执行下面语句</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd bustub-public# 进入官网目录<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> If you pull / push over HTTPS</span><br>git push --mirror https://github.com/student/bustub-private.git<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> If you pull / push over SSH</span><br>git push --mirror git@github.com:student/bustub-private.git<br></code></pre></td></tr></table></figure></li><li><p>这样，就可以在自己的仓库进行操作了，注意：官方的分支是<code>master</code>，现在github默认分支<code>main</code>，可以修改默认分支为<code>master</code>即可。然后把自己仓库的项目克隆到本地</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> If you pull / push over HTTPS</span><br>git clone https://github.com/student/bustub-private.git<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> If you pull / push over SSH</span><br>git clone git@github.com:student/bustub-private.git<br></code></pre></td></tr></table></figure></li><li><p>添加远程仓库，方便拉最新的版本</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add public https://github.com/cmu-db/bustub.git</span><br><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>originhttps://github.com/student/bustub-private.git (fetch)<br>originhttps://github.com/student/bustub-private.git (push)<br>publichttps://github.com/cmu-db/bustub.git (fetch)<br>publichttps://github.com/cmu-db/bustub.git (push)<br></code></pre></td></tr></table></figure></li><li><p>拉最新的版本</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git pull public master</span><br></code></pre></td></tr></table></figure></li><li><p>接下来，构建项目，如果在win10上，则需要wsl；linux，mac直接执行以下语句即可</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo build_support/packages.sh</span><br><span class="hljs-meta">#</span><span class="bash"> 构建语句</span><br><span class="hljs-meta">$</span><span class="bash"> mkdir build</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta">$</span><span class="bash"> cmake ..</span><br><span class="hljs-meta">$</span><span class="bash"> make</span><br><span class="hljs-meta">#</span><span class="bash"> 测试</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta">$</span><span class="bash"> make check-tests</span><br><span class="hljs-meta">#</span><span class="bash"> 如果都显示绿色，则环境搭建成功了</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-项目代码"><a href="#3-项目代码" class="headerlink" title="3 项目代码"></a>3 项目代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//===----------------------------------------------------------------------===//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                         BusTub</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// p0_starter.h</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Identification: src/include/primer/p0_starter.h</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Copyright (c) 2015-2020, Carnegie Mellon University Database Group</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//===----------------------------------------------------------------------===//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;common/exception.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> bustub &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The Matrix type defines a common</span><br><span class="hljs-comment"> * interface for matrix operations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> &#123;</span><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new Matrix instance.</span><br><span class="hljs-comment">   * @param rows The number of rows</span><br><span class="hljs-comment">   * @param cols The number of columns</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Matrix</span>(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols) : <span class="hljs-built_in">rows_</span>(rows), <span class="hljs-built_in">cols_</span>(cols), <span class="hljs-built_in">linear_</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (rows_ &lt;= <span class="hljs-number">0</span> || cols_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      rows_ = cols_ = <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      linear_ = <span class="hljs-keyword">new</span> T[rows_ * cols_];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/** The number of rows in the matrix */</span><br>  <span class="hljs-keyword">int</span> rows_;<br>  <span class="hljs-comment">/** The number of columns in the matrix */</span><br>  <span class="hljs-keyword">int</span> cols_;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A flattened array containing the elements of the matrix.</span><br><span class="hljs-comment">   */</span><br>  T *linear_;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/** @return The number of rows in the matrix */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetRowCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/** @return The number of columns in the matrix */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetColumnCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Get the (i,j)th matrix element.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Throw OUT_OF_RANGE if either index is out of range.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param i The row index</span><br><span class="hljs-comment">   * @param j The column index</span><br><span class="hljs-comment">   * @return The (i,j)th matrix element</span><br><span class="hljs-comment">   * @throws OUT_OF_RANGE if either index is out of range</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">GetElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Set the (i,j)th matrix element.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Throw OUT_OF_RANGE if either index is out of range.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param i The row index</span><br><span class="hljs-comment">   * @param j The column index</span><br><span class="hljs-comment">   * @param val The value to insert</span><br><span class="hljs-comment">   * @throws OUT_OF_RANGE if either index is out of range</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, T val)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Fill the elements of the matrix from `source`.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Throw OUT_OF_RANGE in the event that `source`</span><br><span class="hljs-comment">   * does not contain the required number of elements.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param source The source container</span><br><span class="hljs-comment">   * @throws OUT_OF_RANGE if `source` is incorrect size</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FillFrom</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;T&gt; &amp;source)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Destroy a matrix instance.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Matrix</span>() &#123; <span class="hljs-keyword">delete</span>[] linear_; &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The RowMatrix type is a concrete matrix implementation.</span><br><span class="hljs-comment"> * It implements the interface defined by the Matrix type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RowMatrix</span> :</span> <span class="hljs-keyword">public</span> Matrix&lt;T&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new RowMatrix instance.</span><br><span class="hljs-comment">   * @param rows The number of rows</span><br><span class="hljs-comment">   * @param cols The number of columns</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">RowMatrix</span>(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols) : Matrix&lt;T&gt;(rows, cols), <span class="hljs-built_in">data_</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (rows &lt;= <span class="hljs-number">0</span> || cols &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Empty</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      data_ = <span class="hljs-keyword">new</span> T *[<span class="hljs-keyword">this</span>-&gt;rows_ * <span class="hljs-keyword">this</span>-&gt;cols_];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-keyword">this</span>-&gt;rows_; row++) &#123;<br>        data_[row] = &amp;<span class="hljs-keyword">this</span>-&gt;linear_[row * <span class="hljs-keyword">this</span>-&gt;cols_];<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @return The number of rows in the matrix</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetRowCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;rows_; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @return The number of columns in the matrix</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetColumnCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;cols_; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Get the (i,j)th matrix element.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Throw OUT_OF_RANGE if either index is out of range.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param i The row index</span><br><span class="hljs-comment">   * @param j The column index</span><br><span class="hljs-comment">   * @return The (i,j)th matrix element</span><br><span class="hljs-comment">   * @throws OUT_OF_RANGE if either index is out of range</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function">T <span class="hljs-title">GetElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-keyword">this</span>-&gt;rows_ || j &gt;= <span class="hljs-keyword">this</span>-&gt;cols_ || i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;RowMatrix::GetElement() out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> data_[i][j];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Set the (i,j)th matrix element.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Throw OUT_OF_RANGE if either index is out of range.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param i The row index</span><br><span class="hljs-comment">   * @param j The column index</span><br><span class="hljs-comment">   * @param val The value to insert</span><br><span class="hljs-comment">   * @throws OUT_OF_RANGE if either index is out of range</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, T val)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-keyword">this</span>-&gt;rows_ || j &gt;= <span class="hljs-keyword">this</span>-&gt;cols_ || i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;RowMatrix::SetElement() out of range&quot;</span>);<br>    &#125;<br>    data_[i][j] = val;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Fill the elements of the matrix from `source`.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Throw OUT_OF_RANGE in the event that `source`</span><br><span class="hljs-comment">   * does not contain the required number of elements.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param source The source container</span><br><span class="hljs-comment">   * @throws OUT_OF_RANGE if `source` is incorrect size</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FillFrom</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;T&gt; &amp;source)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(source.<span class="hljs-built_in">size</span>()) != <span class="hljs-keyword">this</span>-&gt;rows_ * <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;RowMatrix::FillFrom() out of range&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-keyword">this</span>-&gt;rows_; row++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-keyword">this</span>-&gt;cols_; col++) &#123;<br>        <span class="hljs-built_in">SetElement</span>(row, col, source[<span class="hljs-keyword">this</span>-&gt;cols_ * row + col]);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Destroy a RowMatrix instance.</span><br><span class="hljs-comment">   */</span><br>  ~<span class="hljs-built_in">RowMatrix</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">delete</span>[] data_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A 2D array containing the elements of the matrix in row-major format.</span><br><span class="hljs-comment">   */</span><br>  T **data_;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The RowMatrixOperations class defines operations</span><br><span class="hljs-comment"> * that may be performed on instances of `RowMatrix`.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RowMatrixOperations</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Compute (`matrixA` + `matrixB`) and return the result.</span><br><span class="hljs-comment">   * Return `nullptr` if dimensions mismatch for input matrices.</span><br><span class="hljs-comment">   * @param matrixA Input matrix</span><br><span class="hljs-comment">   * @param matrixB Input matrix</span><br><span class="hljs-comment">   * @return The result of matrix addition</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">Add</span>(<span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;<br>    <span class="hljs-keyword">if</span> (!matrixA || !matrixB || matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>() ||<br>        matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> rows = matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>();<br>    <span class="hljs-keyword">int</span> cols = matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    <span class="hljs-keyword">auto</span> result = std::make_unique&lt;RowMatrix&lt;T&gt;&gt;(rows, cols);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; rows; row++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; cols; col++) &#123;<br>        T sum = matrixA-&gt;<span class="hljs-built_in">GetElement</span>(row, col) + matrixB-&gt;<span class="hljs-built_in">GetElement</span>(row, col);<br>        result-&gt;<span class="hljs-built_in">SetElement</span>(row, col, sum);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Compute the matrix multiplication (`matrixA` * `matrixB` and return the result.</span><br><span class="hljs-comment">   * Return `nullptr` if dimensions mismatch for input matrices.</span><br><span class="hljs-comment">   * @param matrixA Input matrix</span><br><span class="hljs-comment">   * @param matrixB Input matrix</span><br><span class="hljs-comment">   * @return The result of matrix multiplication</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">Multiply</span>(<span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;<br>    <span class="hljs-keyword">if</span> (!matrixA || !matrixB || matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> rows_a = matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>();<br>    <span class="hljs-keyword">int</span> commons = matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    <span class="hljs-keyword">int</span> cols_b = matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    <span class="hljs-keyword">auto</span> result = std::make_unique&lt;RowMatrix&lt;T&gt;&gt;(rows_a, cols_b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row_a = <span class="hljs-number">0</span>; row_a &lt; rows_a; row_a++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col_b = <span class="hljs-number">0</span>; col_b &lt; cols_b; col_b++) &#123;<br>        T sum&#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> common = <span class="hljs-number">0</span>; common &lt; commons; common++) &#123;<br>          sum += matrixA-&gt;<span class="hljs-built_in">GetElement</span>(row_a, common) * matrixB-&gt;<span class="hljs-built_in">GetElement</span>(common, col_b);<br>        &#125;<br>        result-&gt;<span class="hljs-built_in">SetElement</span>(row_a, col_b, sum);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Simplified General Matrix Multiply operation. Compute (`matrixA` * `matrixB` + `matrixC`).</span><br><span class="hljs-comment">   * Return `nullptr` if dimensions mismatch for input matrices.</span><br><span class="hljs-comment">   * @param matrixA Input matrix</span><br><span class="hljs-comment">   * @param matrixB Input matrix</span><br><span class="hljs-comment">   * @param matrixC Input matrix</span><br><span class="hljs-comment">   * @return The result of general matrix multiply</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">GEMM</span>(<span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixB,<br>                                            <span class="hljs-keyword">const</span> RowMatrix&lt;T&gt; *matrixC) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(<span class="hljs-built_in">Multiply</span>(matrixA, matrixB).<span class="hljs-built_in">get</span>(), matrixC);<br>  &#125;<br>&#125;;<br>&#125;  <span class="hljs-comment">// namespace bustub</span><br></code></pre></td></tr></table></figure><p><code>make starter</code></p><p><code>./test/starter-test</code></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220324122701196.png" alt="image-20220324122701196"></p><p>注意：测试时记得到对应<code>test</code>文件下删掉<code>Disabled_</code>。不然通过不了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2020/project0/">Project #0 - C++ Primer | CMU 15-445/645 :: Intro to Database Systems (Fall 2020)</a></p><p><a href="https://xhy3054.github.io/cpp-unique-ptr/">c++智能指针－－unique_ptr - line - 千里之行 (xhy3054.github.io)</a></p><p><a href="https://www.i4k.xyz/article/winneyDD/102686433">gdb调试GTest，GTest加参数运行_winneyDD的博客-程序员信息网_gdb gtest - 程序员信息网 (i4k.xyz)</a></p>]]></content>
    
    
    <categories>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project1：Buffer Pool Manager</title>
    <link href="/2022/03/23/CMU15445/Project1%EF%BC%9ABuffer-Pool-Manager/"/>
    <url>/2022/03/23/CMU15445/Project1%EF%BC%9ABuffer-Pool-Manager/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    缓冲池作为<strong>物理页面在主内存和磁盘的移动介质</strong>。这使得DBMS操作大于系统可用内存量的数据库。</p><p>​    我们只需要实现提供的API即可</p><h2 id="2-实验内容"><a href="#2-实验内容" class="headerlink" title="2 实验内容"></a>2 实验内容</h2><h3 id="2-1-LRU-Replacement-Policy"><a href="#2-1-LRU-Replacement-Policy" class="headerlink" title="2.1 LRU Replacement Policy"></a>2.1 LRU Replacement Policy</h3><p>​    该部分需要完成跟踪缓冲池中页面的使用情况。</p><p>​    需要实现<code>LRUReplacer</code> in <code>src/include/buffer/lru_replacer.h</code>和它对应的cpp文件<code>src/buffer/lru_replacer.cpp</code></p><p>​    <code>LRUReplacer</code>的大小和缓冲池相同，因为包含了<code>BufferPoolManager</code>的所有<code>frames</code>。但并不是所有<code>frames</code>都被认为在<code>LRUReplacer</code>，<code>LRUReplacer</code>被初始化为没有<code>frame</code>。然后，在 <code>LRUReplacer</code> 中只会考虑新未固定的那些。</p><p>​    需要实现以下方法：</p><ul><li><code>Victim(T*)</code>：删除与<code>Replacer</code>跟踪的所有元素相比最近被访问次数最少的对象，将其内容存储在输出参数中并返回True。如果<code>Replacer</code>是空的，则返回False。</li><li><code>Pin(T)</code>：这个方法应该在一个页面被<code>pin</code>在<code>BufferPoolManager</code>的一个<code>frame</code>上之后被调用。它应该从<code>LRUReplacer</code>中删除包含<code>pin</code>的页面的<code>frame</code>。</li><li><code>Unpin(T)</code>：当一个页面的<code>pin_count</code>变成0的时候，这个方法应该被调用。这个方法应该把包含<code>unpin</code>的页面的<code>frame</code>添加到<code>LRUReplacer</code>。</li><li><code>Size()</code>：该方法返回当前在<code>LRUReplacer</code>中的<code>frame</code>的数量。</li></ul><blockquote><p>理解pin和unpin：pin是指取走特定页，unpin是指添加page，这里注意实现的重复添加时后一次添加是不起作用的</p></blockquote><h3 id="2-2-Buffer-Pool-Manager"><a href="#2-2-Buffer-Pool-Manager" class="headerlink" title="2.2 Buffer Pool Manager"></a>2.2 Buffer Pool Manager</h3><p>​    实现一个缓冲池管理器，负责从<code>DiskManager</code>中获取数据库页面并存储到内存中。要注意将旧页面逐出，将脏页写入磁盘，为新页腾出空间。</p><p>​    lab已经实现了实际读取和写入磁盘的代码（<code>DiskManager</code>），我们要实现要注意以下几点：</p><ul><li> 所有内存页面通过<code>Page</code>对象表示，每个<code>Page</code>对象包含一块内存，而且<code>Page</code>只是相当于一个内存容器，可以重用相同的<code>Page</code>来存储数据。也就是说，同一个<code>Page</code>对象可能包含不同的物理页面。</li><li><code>Page</code>对象的标识符 (<code>page_id</code>) 跟踪它包含的物理页面；如果 <code>Page</code>对象不包含物理页面，则其 <code>page_id</code>必须设置为 <code>INVALID_PAGE_ID</code>。</li><li>每个 Page 对象还维护一个计数器，用于“固定”该页面的线程数。不允许<code>BufferPoolManager</code>释放已固定的页面。</li><li>每个 <code>Page</code> 对象要跟踪它是否脏。要记录页面在取消固定之前是否被修改。<code>BufferPoolManager</code>必须将脏页的内容写回磁盘，然后才能重用该对象。</li><li>对于<code>FetchPageImpl</code>，如果空闲列表中没有可用的页面，并且所有其他的页面都被钉住了，你应该返回NULL。<code>FlushPageImpl</code>应该刷新一个页面，不管它的引脚状态如何。</li></ul><p>​    <code>BufferPoolManager</code>实现将使用前面步骤中创建的 <code>LRUReplacer</code>类。它将使用 <code>LRUReplacer</code>来跟踪访问 <code>Page</code>对象的时间，以便在必须释放帧以腾出空间从磁盘复制新物理页面时决定驱逐哪个对象。</p><p>​    在源文件 (<code>src/buffer/buffer_pool_manager.cpp</code>) 中实现头文件 (<code>src/include/buffer/buffer_pool_manager.h</code>) 中定义的以下函数：</p><ul><li><code>FetchPageImpl(page_id)</code>：从缓冲池中获取请求的页面</li><li><code>NewPageImpl(page_id)</code>：在缓冲池中创建一个新页面</li><li><code>UnpinPageImpl(page_id, is_dirty)</code>：从缓冲池中取消固定（<code>unpin</code>）目标页面</li><li><code>FlushPageImpl(page_id)</code>：将目标页刷入磁盘</li><li><code>DeletePageImpl(page_id)</code>：从缓冲池中删除某页</li><li><code>FlushAllPagesImpl()</code>：将缓冲池中的所有页面刷新到磁盘</li></ul><h3 id="2-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#2-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="2.3 PARALLEL BUFFER POOL MANAGER"></a>2.3 PARALLEL BUFFER POOL MANAGER</h3><p>​    实现一个并行缓冲池管理器（<code>ParallelBufferPoolManager</code>），它包含多个``BufferPoolManagerInstances<code>。对于每个操作，</code>ParallelBufferPoolManager<code>选择一个 </code>BufferPoolManagerInstance`并委托给该实例。</p><p>​    使用模运算来映射到对应的实例，实现以下函数：</p><ul><li><code>ParallelBufferPoolManager(num_instances, pool_size, disk_manager, log_manager)</code></li><li><code>~ParallelBufferPoolManager()</code></li><li><code>GetPoolSize()</code></li><li><code>GetBufferPoolManager(page_id)</code></li><li><code>FetchPgImp(page_id)</code></li><li><code>UnpinPgImp(page_id, is_dirty)</code></li><li><code>FlushPgImp(page_id)</code></li><li><code>NewPgImp(page_id)</code></li><li><code>DeletePgImp(page_id)</code></li><li><code>FlushAllPagesImpl()</code></li></ul><h2 id="3-实验思路"><a href="#3-实验思路" class="headerlink" title="3 实验思路"></a>3 实验思路</h2><h3 id="3-1-Task1"><a href="#3-1-Task1" class="headerlink" title="3.1 Task1"></a>3.1 Task1</h3><p>​    设计一个<code>LRUReplacer</code>，里面维护着<code>unpinned page</code>，指的是那些不被使用但任有意义的<code>page</code>。</p><p>​    LeetCode上有类似的题<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUReplacer</span> :</span> <span class="hljs-keyword">public</span> Replacer &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Create a new LRUReplacer.</span><br><span class="hljs-comment">   * @param num_pages the maximum number of pages the LRUReplacer will be required to store</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LRUReplacer</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> num_pages)</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Destroys the LRUReplacer.</span><br><span class="hljs-comment">   */</span><br>  ~<span class="hljs-built_in">LRUReplacer</span>() <span class="hljs-keyword">override</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Victim</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> *frame_id)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pin</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> frame_id)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unpin</span><span class="hljs-params">(<span class="hljs-keyword">frame_id_t</span> frame_id)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// TODO(student): implement me!</span><br>  std::mutex latch_;<br>  std::list&lt;<span class="hljs-keyword">frame_id_t</span>&gt; list_unpinned_;<br>  std::unordered_map&lt;<span class="hljs-keyword">frame_id_t</span> , std::list&lt;<span class="hljs-keyword">frame_id_t</span>&gt;::iterator&gt; map_frames_;<br>  <span class="hljs-keyword">size_t</span> pages_num;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​    这里放<code>.h</code>就好了。</p><h3 id="3-2-Task2"><a href="#3-2-Task2" class="headerlink" title="3.2 Task2"></a>3.2 Task2</h3><p>​    设计时要先弄清楚以下数据结构：</p><p><code>Page</code></p><p><code>DiskManager</code></p><p>​    以下变量：</p><p><code>pages_</code>：保存<code>Buffer Pool</code>中存在的<code>page</code></p><p><code>page_table_</code>：维护<code>page_id</code>与<code>frame_id</code>的映射</p><p><code>replacer_</code>：可以理解为一个查找器，查找<code>unpinned</code>的页面并进行替换，实现的是LRU方式则用哈希表+链表维护对应的页表（<code>frame</code>）号</p><p><code>free_list_</code>：记录<code>Buffer Pool</code>中哪些缓存页是可用的，里面的页数据都是无意义的，没有线程在使用</p><blockquote><p>注意frame与page：两者其实是一个东西，在Buffer Pool通常称为frame，在磁盘中称为Page</p><p>譬如<code>page_id</code>和<code>frame_id</code>：前者指的是某一个page编号，比如disk上第十个page；后者指的是<code>BufferPoolManager</code>中的页框号码。</p></blockquote><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220325223314700.png" alt="image-20220325223314700"></p><h2 id="4-自问自答"><a href="#4-自问自答" class="headerlink" title="4 自问自答"></a>4 自问自答</h2><blockquote><ol><li><p>为什么有了<code>replacer</code>还要有<code>free_list</code>？</p><p> ​    <code>replacer</code>里维护的是没有线程操作，但还存在内存中的页，也就是<code>unpinned</code>的页，它们随时可能会被<code>delete</code>进入<code>free_list</code>；<code>free_list</code>中维护的已经刷入磁盘的页，它们在缓冲池的页框已经空了。可以认为<code>unpinned</code>里的随时可以回收，<code>free</code>的已经回收。</p></li><li><p><code>frame</code>和<code>page</code>究竟有什么区别？</p><p> ​    buffer pool 的操作的基本单位为一段逻辑连续的字节数组，在磁盘上表现为<strong>页（page）</strong>，有唯一的标识 <strong>page_id</strong>；在内存中表现为<strong>帧（frame）</strong>，有唯一的标识 <strong>frame_id</strong>。通过<strong>page table</strong>来记录哪些<code>frame</code>存的哪些<code>page</code></p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220401113354109.png" alt="image-20220401113354109"></p></li><li><p>为什么需要替换策略？</p><p> ​    管理帧的内存池大小一般来说是远小于磁盘的，因此在内存池满了后，再从磁盘加载新的页到内存池，需要<strong>某种替换策略（replacer）</strong>将一些不再使用的页踢出内存池以腾出空间。</p></li><li><p>为什么DBMS要设计一个BPM来管理内存，而不要OS来管理内存？</p><ul><li>OS会将Page当作一个临时数据，当查询结束就会删除Page；使用DBMS可以设计更多的方案，例如选择替换策略</li></ul></li><li><p>Buffer pool的作用，为什么要用Buffer Pool，和操作系统的虚拟内存有什么区别？</p><p> ​    Buffer Pool是数据库内部分配的一个大的内存区域，用来存储从磁盘中获取的页面（在MySQL中，默认大小为128MB）</p></li></ol></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/366788722">BufferPoolManager] - 知乎 (zhihu.com)</a></p><p><a href="https://developer.huawei.com/consumer/cn/forum/topic/0201838624537360242?fid=0101592429757310384">MySQL 的 Buffer Pool，终于被我搞懂了-华为开发者论坛 (huawei.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里支付宝营销平台一面</title>
    <link href="/2022/03/22/%E6%9D%82%E7%83%A9/%E9%98%BF%E9%87%8C%E6%94%AF%E4%BB%98%E5%AE%9D%E8%90%A5%E9%94%80%E5%B9%B3%E5%8F%B0%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/03/22/%E6%9D%82%E7%83%A9/%E9%98%BF%E9%87%8C%E6%94%AF%E4%BB%98%E5%AE%9D%E8%90%A5%E9%94%80%E5%B9%B3%E5%8F%B0%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<ol><li>自我介绍</li><li>为什么第一志愿没有通过</li><li>项目介绍</li><li>项目表结构怎么样</li><li>如果redis宕机，导致扣减失败了怎么办</li><li>redis还能用在哪些场景中？</li><li>redis寻主？</li><li>多线程有用到吗？讲下线程池的参数</li><li>如何实现最终一致性的？</li><li>http状态码</li><li>口述两个队列实现一个栈</li><li>设计模式（抽象工厂）</li><li>单例模式的四种实现方式</li><li>有张表，字段为a，b，c，创建联合索引abc，问 where b = 3 and a &gt; 2 and c = 2会走索引吗？走了哪些</li><li>事务隔离级别</li><li>数据库特性</li><li>RPC和http的区别</li><li>netty是怎么用的呢</li><li>如何解决粘包拆包</li><li>软问题。。。</li></ol><p>笔试</p><p>​    火车站的最优排班。例如有10个火车进出站时间为【1，2】【3，4】【4，5】【6，7】【4，7】【1，7】【8，9】【9，10】【10，11】【11，12】</p><p>​    如果有别的火车在站中，则其他的不能进站。求出怎么让更多的火车在站中</p><p>​    没写出来。。想歪了，其实DFS就行，先按进站时间排序，然后每次固定一个火车在站，递归其他火车在站中的情况，最后取最优解即可。</p><p><strong>总结</strong></p><ol><li>还是会紧张，还被面试官说了QAQ，被软问题问得有些懵了</li><li>最后问面试官建议时，得到了以下回复：1，不要忽视毛概，马克思这些课，学校开设就有他的意义，认真学学可以提高沟通能力和奖学金。2，提高软实力，和别人合作时要给其他人参与感，一起讨论，即使最后结果还是自己的答案。3，多刷题。</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂烩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第285场周赛</title>
    <link href="/2022/03/20/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC285%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/20/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC285%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-hills-and-valleys-in-an-array/">6027. 统计数组中峰和谷的数量 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countHillValley</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; nums[i] == nums[i + <span class="hljs-number">1</span>]) i ++;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// for (auto num: vec) cout &lt;&lt; num &lt;&lt; endl;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (vec[i - <span class="hljs-number">1</span>] &gt; vec[i] &amp;&amp; vec[i + <span class="hljs-number">1</span>] &gt; vec[i]) res ++;<br>            <span class="hljs-keyword">if</span> (vec[i - <span class="hljs-number">1</span>] &lt; vec[i] &amp;&amp; vec[i] &gt; vec[i + <span class="hljs-number">1</span>]) res ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/count-collisions-on-a-road/">6028. 统计道路上的碰撞次数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countCollisions</span><span class="hljs-params">(string directions)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; directions.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (directions[i] == <span class="hljs-string">&#x27;R&#x27;</span> || directions[i] == <span class="hljs-string">&#x27;S&#x27;</span>) flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag) ans ++;<br>        &#125;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = directions.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (directions[i] == <span class="hljs-string">&#x27;L&#x27;</span> || directions[i] == <span class="hljs-string">&#x27;S&#x27;</span>) flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag) ans ++;    <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-points-in-an-archery-competition/">6029. 射箭比赛中的最大得分 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maximumBobPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numArrows, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; aliceArrows)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = aliceArrows.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> maxScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>, arrows = <span class="hljs-number">0</span>;;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bobArrows</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                    score += j;<br>                    arrows += aliceArrows[j] + <span class="hljs-number">1</span>;<br>                    bobArrows[j] = aliceArrows[j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arrows &gt; numArrows) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (score &gt; maxScore) &#123;<br>                maxScore = score;<br>                bobArrows[<span class="hljs-number">0</span>] += (numArrows - arrows);<br>                ans = bobArrows;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/">6030. 由单个字符重复的最长子字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>要用线段树，不太会</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC中经典数据结构题集</title>
    <link href="/2022/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LC%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86/"/>
    <url>/2022/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LC%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1206-设计跳表——对链表的二分优化"><a href="#1206-设计跳表——对链表的二分优化" class="headerlink" title="1206. 设计跳表——对链表的二分优化"></a><a href="https://leetcode-cn.com/problems/design-skiplist/">1206. 设计跳表</a>——对链表的二分优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Skiplist</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-comment">// 向右向下指针</span><br>        Node *right, *down;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-built_in">Node</span>(Node *right, Node *down, <span class="hljs-keyword">int</span> val): <span class="hljs-built_in">right</span>(right), <span class="hljs-built_in">down</span>(down), <span class="hljs-built_in">val</span>(val) &#123;&#125;<br>    &#125;*head;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">32</span>;<br>    vector&lt;Node*&gt; pathList;<br><br>    <span class="hljs-built_in">Skiplist</span>() &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">-1</span>);<br>        pathList.<span class="hljs-built_in">reserve</span>(MAX_LEVEL);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        Node *p = head;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            <span class="hljs-comment">// 左右寻找目标区间</span><br>            <span class="hljs-keyword">while</span> (p-&gt;right &amp;&amp; p-&gt;right-&gt;val &lt; target) &#123;<br>                p = p-&gt;right;<br>            &#125;<br>            <span class="hljs-comment">// 没找到目标值，则继续往下走</span><br>            <span class="hljs-keyword">if</span> (!p-&gt;right || p-&gt;right-&gt;val &gt; target) &#123;<br>                p = p-&gt;down;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//找到目标值，结束</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">//从上至下记录搜索路径</span><br>        pathList.<span class="hljs-built_in">clear</span>();<br>        Node *p = head;<br>        <span class="hljs-comment">// 从上到下去搜索 次小于num的 数字，等于就是另外一种实现里的 prevs</span><br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            <span class="hljs-comment">// 向右找到次小于num的p</span><br>            <span class="hljs-keyword">while</span>(p-&gt;right &amp;&amp; p-&gt;right-&gt;val &lt; num) &#123;<br>                p = p-&gt;right;<br>            &#125;<br>            pathList.<span class="hljs-built_in">push_back</span>(p);<br>            p = p-&gt;down;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> insertUp = <span class="hljs-literal">true</span>;<br>        Node *downNode = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 从下至上搜索路径回溯，50%概率</span><br>        <span class="hljs-comment">// 这里实现是会保证不会超过当前的层数的，然后靠头结点去额外加层， 即每次新增一层</span><br>        <span class="hljs-keyword">while</span>(insertUp &amp;&amp; pathList.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            Node *insert = pathList.<span class="hljs-built_in">back</span>();<br>            pathList.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-comment">// add 新节点</span><br>            insert-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(insert-&gt;right, downNode, num);<br>            <span class="hljs-comment">// 把新结点赋值为downNode</span><br>            downNode = insert-&gt;right;<br>            <span class="hljs-comment">// 50%</span><br>            insertUp = (<span class="hljs-built_in">rand</span>() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 新增一层</span><br>        <span class="hljs-keyword">if</span> (insertUp) &#123;<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-literal">NULL</span>, downNode, num), head, <span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        Node *p = head;<br>        <span class="hljs-keyword">bool</span> seen = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            <span class="hljs-comment">// 当前层向右找到次小的点</span><br>            <span class="hljs-keyword">while</span> (p-&gt;right &amp;&amp; p-&gt;right-&gt;val &lt; num) &#123;<br>                p = p-&gt;right;<br>            &#125;<br>            <span class="hljs-comment">// 无效点，或者 太大， 则到下一层去</span><br>            <span class="hljs-keyword">if</span> (!p-&gt;right || p-&gt;right-&gt;val &gt; num) &#123;<br>                p = p-&gt;down;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 搜索到目标结点，进行删除操作，结果记录为true</span><br>                <span class="hljs-comment">// 继续往下层搜索，删除一组目标结点</span><br>                seen = <span class="hljs-literal">true</span>;<br>                p-&gt;right = p-&gt;right-&gt;right;<br>                p = p-&gt;down;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> seen;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Skiplist object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Skiplist* obj = new Skiplist();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;search(target);</span><br><span class="hljs-comment"> * obj-&gt;add(num);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;erase(num);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="460-LFU-缓存——双链表-双哈希表"><a href="#460-LFU-缓存——双链表-双哈希表" class="headerlink" title="460. LFU 缓存——双链表+双哈希表"></a><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a>——双链表+双哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        Node *left, *right;<br>        <span class="hljs-keyword">int</span> key, val;<br>        <span class="hljs-built_in">Node</span> (<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _val) &#123;<br>            key = _key, val = _val;<br>            left = right = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> &#123;</span><br>        Block *left, *right;<br>        Node *head, *tail;<br>        <span class="hljs-keyword">int</span> cnt;<br>        <span class="hljs-built_in">Block</span>(<span class="hljs-keyword">int</span> _cnt) &#123;<br>            cnt = _cnt;<br>            left = right = <span class="hljs-literal">NULL</span>;<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>            head-&gt;right = tail, tail-&gt;left = head;<br>        &#125;<br>        ~<span class="hljs-built_in">Block</span>() &#123;<br>            <span class="hljs-keyword">delete</span> head;<br>            <span class="hljs-keyword">delete</span> tail;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *p)</span> </span>&#123;<br>            p-&gt;right = head-&gt;right;<br>            head-&gt;right-&gt;left = p;<br>            head-&gt;right = p;<br>            p-&gt;left = head;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *p)</span> </span>&#123;<br>            p-&gt;right-&gt;left = p-&gt;left;<br>            p-&gt;left-&gt;right = p-&gt;right;<br>        &#125;   <br>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> head-&gt;right == tail;<br>        &#125;<br>    &#125;*head, *tail;<br><br>    <span class="hljs-keyword">int</span> n;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, Node*&gt; hash_node;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, Block*&gt; hash_block;<br><br>    <span class="hljs-built_in">LFUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        n = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Block</span>(<span class="hljs-number">0</span>), tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Block</span>(INT_MAX);<br>        head-&gt;right = tail, tail-&gt;left = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Block *p)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Block</span>(p-&gt;cnt + <span class="hljs-number">1</span>);<br>        cur-&gt;right = p-&gt;right;<br>        p-&gt;right-&gt;left = cur;<br>        cur-&gt;left = p;<br>        p-&gt;right = cur;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Block *p)</span> </span>&#123;<br>        p-&gt;right-&gt;left = p-&gt;left;<br>        p-&gt;left-&gt;right = p-&gt;right;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash_block.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>        <span class="hljs-keyword">auto</span> block = hash_block[key];<br>        <span class="hljs-keyword">auto</span> node = hash_node[key];<br>        block-&gt;<span class="hljs-built_in">remove</span>(node);<br>        <span class="hljs-keyword">if</span> (block-&gt;right-&gt;cnt != block-&gt;cnt + <span class="hljs-number">1</span>) <span class="hljs-built_in">insert</span>(block);<br>        block-&gt;right-&gt;<span class="hljs-built_in">insert</span>(node);<br>        hash_block[key] = block-&gt;right;<br>        <span class="hljs-keyword">if</span> (block-&gt;<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">remove</span>(block);<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (hash_block.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> node = hash_node[key];<br>            node-&gt;val = value;<br>            <span class="hljs-built_in">get</span>(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <br>            <span class="hljs-keyword">if</span> (hash_block.<span class="hljs-built_in">size</span>() == n) &#123;<br>                <span class="hljs-keyword">auto</span> p = head-&gt;right-&gt;tail-&gt;left;<br>                head-&gt;right-&gt;<span class="hljs-built_in">remove</span>(p);<br>                <span class="hljs-keyword">if</span> (head-&gt;right-&gt;<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">remove</span>(head-&gt;right);<br>                hash_block.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>                hash_node.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>                <span class="hljs-keyword">delete</span> p;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            <span class="hljs-keyword">if</span> (head-&gt;right-&gt;cnt &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">insert</span>(head);<br>            head-&gt;right-&gt;<span class="hljs-built_in">insert</span>(p);<br>            hash_block[key] = head-&gt;right;<br>            hash_node[key] = p;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LFUCache* obj = new LFUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="146-LRU-缓存——链表-哈希表"><a href="#146-LRU-缓存——链表-哈希表" class="headerlink" title="146. LRU 缓存——链表+哈希表"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a>——链表+哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> key, val;<br>        Node *next, *prev;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;;<br>    &#125; *L, *R;<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, Node*&gt; hash; <br>    <span class="hljs-keyword">int</span> n;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        n = capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L-&gt;next = R, R-&gt;prev = L;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_node</span><span class="hljs-params">(Node *p)</span> </span>&#123;<br>        p-&gt;next = L-&gt;next, L-&gt;next-&gt;prev = p, p-&gt;prev = L, L-&gt;next = p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_node</span><span class="hljs-params">(Node *p)</span> </span>&#123;<br>        p-&gt;next-&gt;prev = p-&gt;prev, p-&gt;prev-&gt;next = p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> p = hash[key];<br>            <span class="hljs-built_in">delete_node</span>(p);<br>            <span class="hljs-built_in">insert_node</span>(p);<br>            <span class="hljs-keyword">return</span> p-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> p = hash[key];<br>            <span class="hljs-built_in">delete_node</span>(p);<br>            p-&gt;val = value;<br>            <span class="hljs-built_in">insert_node</span>(p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (n == hash.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> q = R-&gt;prev;<br>                <span class="hljs-built_in">delete_node</span>(q);<br>                hash.<span class="hljs-built_in">erase</span>(q-&gt;key);<br>            &#125;<br>            <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            hash[key] = p;<br>            <span class="hljs-built_in">insert_node</span>(p);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="707-设计链表——链表"><a href="#707-设计链表——链表" class="headerlink" title="707. 设计链表——链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表——链表</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> val;<br>        Node *next;<br>        <span class="hljs-built_in">Node</span> (<span class="hljs-keyword">int</span> _val) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125;*head;<br><br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        head = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index &amp;&amp; p; i ++) p = p-&gt;next;<br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> p-&gt;val; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>        cur-&gt;next = head;<br>        head = cur;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> p = head;<br>            <span class="hljs-keyword">while</span> (p-&gt;next) p = p-&gt;next;<br>            p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &lt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">addAtHead</span>(val);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) len ++;<br>            <span class="hljs-keyword">if</span> (index == len) <span class="hljs-built_in">addAtTail</span>(val);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; len) &#123;<br>                <span class="hljs-keyword">auto</span> p = head;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i ++) p = p-&gt;next;<br>                <span class="hljs-keyword">auto</span> cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>                cur-&gt;next = p-&gt;next;<br>                p-&gt;next = cur;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) len ++;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; len) &#123;<br>            <span class="hljs-keyword">if</span> (!index) head = head-&gt;next;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">auto</span> p = head;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;index - <span class="hljs-number">1</span>; i ++) p = p-&gt;next;<br>                p-&gt;next = p-&gt;next-&gt;next;<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(index);</span><br><span class="hljs-comment"> * obj-&gt;addAtHead(val);</span><br><span class="hljs-comment"> * obj-&gt;addAtTail(val);</span><br><span class="hljs-comment"> * obj-&gt;addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj-&gt;deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="705-设计哈希集合——哈希set"><a href="#705-设计哈希集合——哈希set" class="headerlink" title="705. 设计哈希集合——哈希set"></a><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合——哈希set</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1997</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; h[N];<br><br>    <span class="hljs-built_in">MyHashSet</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;h, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++) <br>            <span class="hljs-keyword">if</span> (h[i] == key) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> t = key % N;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">find</span>(h[t], key);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span>) h[t].<span class="hljs-built_in">push_back</span>(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> t = key % N;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">find</span>(h[t], key);<br>        <span class="hljs-keyword">if</span> (k != <span class="hljs-number">-1</span>) h[t].<span class="hljs-built_in">erase</span>(h[t].<span class="hljs-built_in">begin</span>() + k);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;    <br>        <span class="hljs-keyword">int</span> t = key % N;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">find</span>(h[t], key);<br>        <span class="hljs-keyword">return</span> k != <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashSet* obj = new MyHashSet();</span><br><span class="hljs-comment"> * obj-&gt;add(key);</span><br><span class="hljs-comment"> * obj-&gt;remove(key);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;contains(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射——HashMap</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">int</span> key, val;<br>        Node *next;<br>        <span class="hljs-built_in">Node</span> (<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1331</span>;<br>    vector&lt;Node*&gt; data;<br><br>    <span class="hljs-built_in">MyHashMap</span>() &#123;<br>        data = vector&lt;Node*&gt;(N, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = key % N;<br>        Node *pre = data[idx];<br>        Node *cur = pre;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;key == key) &#123;<br>                cur-&gt;val = value;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            pre = cur;<br>            cur = cur-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = key % N;<br>        <span class="hljs-keyword">if</span> (data[idx] == <span class="hljs-literal">nullptr</span>) &#123;<br>            data[idx] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">append</span>(key, value);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = key % N;<br>        Node *cur = data[idx];<br>        <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;key == key) <span class="hljs-keyword">return</span> cur-&gt;val;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = key % N;<br>        Node *cur = data[idx];<br>        Node *pre = cur;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;key == key) &#123;<br>                <span class="hljs-keyword">if</span> (pre == cur) data[idx] = cur-&gt;next;<br>                <span class="hljs-keyword">else</span> pre-&gt;next = cur-&gt;next;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            pre = cur;<br>            cur = cur-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap* obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="208-实现-Trie-——前缀树"><a href="#208-实现-Trie-——前缀树" class="headerlink" title="208. 实现 Trie ——前缀树 "></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie ——前缀树 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>        <span class="hljs-keyword">bool</span> is_end;<br>        Node *son[<span class="hljs-number">26</span>];<br>        <span class="hljs-built_in">Node</span>() &#123;<br>            is_end = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++) son[i] = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125; *root;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: word) &#123;<br>            <span class="hljs-keyword">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p-&gt;son[u] == <span class="hljs-literal">NULL</span>) p-&gt;son[u] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            p = p-&gt;son[u];<br>        &#125;<br>        p-&gt;is_end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: word) &#123;<br>            <span class="hljs-keyword">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p-&gt;son[u] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;is_end;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: prefix) &#123;<br>            <span class="hljs-keyword">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p-&gt;son[u] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中的锁机制</title>
    <link href="/2022/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    锁机制用于<strong>管理对共享资源的并发访问</strong>。对于不同引擎，所使用的锁机制是不同的。接下来会对InnoDB存储引擎和MyISAM进行分析</p><h3 id="1-1-行锁与表锁"><a href="#1-1-行锁与表锁" class="headerlink" title="1.1 行锁与表锁"></a>1.1 行锁与表锁</h3><p>​    顾名思义：表锁就是对整张表进行加锁，而行锁则是锁定某行、某几行数据或者行之间的间隙。</p><p>​    各引擎对锁的支持情况如下：</p><table><thead><tr><th></th><th>行锁</th><th>表锁</th></tr></thead><tbody><tr><td>InnoDB</td><td>√</td><td>√</td></tr><tr><td>MyISAM</td><td></td><td>√</td></tr></tbody></table><p><strong>行锁</strong></p><p>​    行锁是作用在索引上的。</p><p>​    InnoDB中，每一个InnoDB表都需要一个聚簇索引，有且只有一个。如果为该表设置了一个主键，那么MySQL将主键作为聚簇索引；如果你不定义一个主键，那么MySQL会把第一个唯一索引（NOT NULL）作为聚簇索引；如果这两种情况都不是，那就创建一个<code>GEN_CLUST_INDEX</code>的隐藏聚簇索引。</p><p>​    因为是聚簇索引，所以B+树上的叶子节点都存储了数据行，那么如果现在是二级索引呢？InnoDB中的二级索引的叶节点存储的是主键值（或者说聚簇索引的值），所以通过二级索引查询数据时，还需要将对应的主键去聚簇索引中再次进行查询。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/1614350-20201115221104598-1160606998.png" alt="img"></p><p>​    以两条SQL的执行为例，讲解下InnoDB对于单行数据的加锁原理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">49</span>;<br>update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Tom&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    第一条SQL使用主键查询，只需要在 id = 49 这个主键索引上加上锁。第二条 SQL 使用二级索引来查询，那么首先在 name = Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id = 49 这个主键索引上加锁。</p><p>​    也就是说使用主键索引需要加一把锁，使用二级索引需要在二级索引和主键索引上各加一把锁。</p><p>​    根据索引对单行数据进行更新的加锁原理了解了，那如果更新操作涉及多个行呢，比如下面 SQL 的执行场景。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">update <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">49</span>;<br></code></pre></td></tr></table></figure><p>​    上述 SQL 的执行过程如下图所示。MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新改行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/1614350-20201115221131283-1993522185.png" alt="img"></p><p><strong>表锁</strong></p><p>​    前面说过，查询列有索引时，InnoDB就会使用行锁锁住对应的索引行。但是没有索引时，就需要使用表锁，把整张表锁住了</p><p>​    表锁使用的是一种一次性锁技术，也就是说，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。</p><p>​    除了使用 unlock tables 显示释放锁之外，会话持有其他表锁时执行lock table 语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者 begin 开启事务时，也会释放之前持有的锁。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220318155713820.png" alt="image-20220318155713820"></p><p>​    表锁由 MySQL Server 实现，行锁则是存储引擎实现，不同的引擎实现的不同。在 MySQL 的常用引擎中 InnoDB 支持行锁，而 MyISAM 则只能使用 MySQL Server 提供的表锁。    </p><p><strong>两种锁的比较</strong></p><p>​    表锁：加锁过程的开销小，加锁的速度快；不会出现死锁的情况；锁定的粒度大，发生锁冲突的几率大，并发度低；</p><ul><li>一般在执行<strong>DDL语句</strong>时会对整个表进行加锁，比如说 ALTER TABLE 等操作；</li><li>如果对InnoDB的表使用行锁，<strong>被锁定字段不是主键，也没有针对它建立索引的话</strong>，那么将会锁整张表；</li><li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。</li></ul><p>行锁：加锁过程的开销大，加锁的速度慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p><ul><li><strong>最大程度的支持并发</strong>，同时也带来了最大的锁开销。</li><li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li><li>行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li></ul><h2 id="2-MyISAM表锁"><a href="#2-MyISAM表锁" class="headerlink" title="2 MyISAM表锁"></a>2 MyISAM表锁</h2><h3 id="2-1-MyISAM表级锁模式"><a href="#2-1-MyISAM表级锁模式" class="headerlink" title="2.1 MyISAM表级锁模式"></a>2.1 MyISAM表级锁模式</h3><ul><li>表共享读锁（Table Read Lock）：不会阻塞其他线程对同一个表的读操作请求，但会<strong>阻塞其他线程的写操作请求</strong>；</li><li>表独占写锁（Table Write Lock）：一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，<strong>都会被阻塞</strong>；</li></ul><p>​    默认情况下，写锁比读锁具有更高的优先级；当一个锁释放后，那么它会优先相应写锁等待队列中的锁请求，然后再是读锁中等待的获取锁的请求。</p><p>​    这种设定也是MyISAM表不适合于有大量更新操作和查询操作的原因。</p><ul><li>大量更新操作可能会造成查询操作很难以获取读锁，从而过长的阻塞。</li><li>一些需要长时间运行的查询操作，也会使得线程“饿死”，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用<strong>中间表</strong>等措施对SQL语句做一定的“分解”，使每一步查询都能在较短的时间内完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。）</li></ul><blockquote><p>我们可以通过一些设置来调节MyISAM的调度行为：</p><ul><li>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利；</li><li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低；</li><li>通过指定INSERT、UPDATE、DELETE语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级；</li><li>给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ul></blockquote><h3 id="2-2-MyISAM对表加锁分析"><a href="#2-2-MyISAM对表加锁分析" class="headerlink" title="2.2 MyISAM对表加锁分析"></a>2.2 MyISAM对表加锁分析</h3><p>​    MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。</p><p>​    在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p><p>​    MyISAM存储引擎支持<strong>并发插入</strong>，以减少给定表的读操作和写操作之间的争用：</p><p>​    如果MyISAM表在数据文件中<strong>没有空闲块</strong>（由于删除或更新导致的空行），则行始终插入数据文件的末尾。在这种情况下，你可以自由混合并发使用MyISAM表的 INSERT 和 SELECT 语句而不需要加锁（你可以在其他线程进行读操作的情况下，同时将行插入到MyISAM表中）。</p><p>​    如果文件中有空闲块，则并发插入会被禁止，但当所有的空闲块重新填充有新数据时，它又会自动启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p><ul><li>当concurrent_insert=0时，不允许并发插入功能。</li><li>当concurrent_insert=1时，允许对没有空闲块的表使用并发插入，新数据位于数据文件结尾（缺省）。</li><li>当concurrent_insert=2时，不管表有没有空想快，都允许在数据文件结尾并发插入。</li></ul><h3 id="2-3-显式加表锁的应用"><a href="#2-3-显式加表锁的应用" class="headerlink" title="2.3 显式加表锁的应用"></a>2.3 显式加表锁的应用</h3><p>​    上面已经提及了表锁的加锁方式，一般表锁都是隐式加锁的，不需要我们去主动声明，但是也有需要显式加锁的情况，这里简单做下介绍：</p><p>给MyISAM表显式加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表 order_detail，其中记录有订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(total) <span class="hljs-keyword">FROM</span> orders;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(subtotal) <span class="hljs-keyword">FROM</span> order_detail;<br></code></pre></td></tr></table></figure><p>​    这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK tables orders read <span class="hljs-keyword">local</span>,order_detail read <span class="hljs-keyword">local</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(total) <span class="hljs-keyword">FROM</span> orders;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(subtotal) <span class="hljs-keyword">FROM</span> order_detail;<br>Unlock tables;<br></code></pre></td></tr></table></figure><h2 id="3-InnoDB行锁与表锁"><a href="#3-InnoDB行锁与表锁" class="headerlink" title="3 InnoDB行锁与表锁"></a>3 InnoDB行锁与表锁</h2><h3 id="3-1-InnoDB锁模式"><a href="#3-1-InnoDB锁模式" class="headerlink" title="3.1 InnoDB锁模式"></a>3.1 InnoDB锁模式</h3><ol><li><p>InnoDB中的<strong>行锁</strong></p><p> InnoDB实现了以下两种类型的行锁</p><ul><li>共享锁（S）：加了锁的记录，所有事务都能去读取但不能修改，同时阻止其他事务获得相同数据集的排他锁；</li><li>排他锁（X）：允许已经获得排他锁的事务去更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁；</li></ul><p> 补充：行锁是加在索引上的，如果当你的查询语句不走索引的话，那么它就会升级到表锁，最终造成效率低下，所以在写SQL语句时需要特别注意。</p></li><li><p>InnoDB<strong>表锁</strong>——意向锁</p><p> ​    由于表锁和行锁虽然锁定范围不同，但是会相互冲突。当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。</p><p> ​    意向锁也是表级锁，分为读意向锁（IS锁）和写意向锁（IX锁）。当事务要在记录上加上行锁时，要首先在表上加上意向锁。这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了，从而就能提高效率。</p><p> ​    意向锁之间是不会产生冲突的，它只会阻塞表级读锁或写锁。意向锁不于行级锁发生冲突。</p></li></ol><h3 id="3-2-锁模式的兼容矩阵"><a href="#3-2-锁模式的兼容矩阵" class="headerlink" title="3.2 锁模式的兼容矩阵"></a>3.2 锁模式的兼容矩阵</h3><p>​    下面表显示了了各种锁之间的兼容情况：</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td></td><td></td><td></td><td></td></tr><tr><td>IX</td><td></td><td>兼容</td><td></td><td>兼容</td></tr><tr><td>S</td><td></td><td></td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td></td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>（注意上面的X与S是说表级的X锁和S锁，意向锁不和行级锁发生冲突）</p><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；如果两者不兼容，那么该事务就需要等待锁的释放。</p><h3 id="3-3-InnoDB的加锁方法"><a href="#3-3-InnoDB的加锁方法" class="headerlink" title="3.3 InnoDB的加锁方法"></a>3.3 InnoDB的加锁方法</h3><ul><li><p>意向锁是 InnoDB 自动加的，不需要用户干预；</p></li><li><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加上排他锁；</p></li><li><p>对于普通的SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集添加共享锁或排他锁</p><ul><li>共享锁（S）：<code>select * from table_name where ... lock in share mode</code>。此时其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X）：<code>select * from table_name where ... for update</code>。其他session可以查询记录，但是不能对该记录加共享锁或排他锁，只能等待锁释放后在加锁。</li></ul></li></ul><p><strong>select for update</strong></p><p>​    在执行这个<code>select</code>查询语句的时候，会将对应的索引访问条目加上排他锁（X锁），也就是说这个语句对应的锁就相当于<code>update</code>带来的效果;</p><p><strong>使用场景：</strong>为了让确保自己查找到的数据一定是最新数据，并且查找到后的数据值允许自己来修改，此时就需要用到<code>select for update</code>语句；</p><p><strong>性能分析</strong>：<code>select for update</code>语句相当于一个<code>update</code>语句。在业务繁忙的情况下，如果事务没有及时地<code>commit</code>或者<code>rollback</code>可能会造成事务长时间的等待，从而影响数据库的并发使用效率。</p><p><strong>select lock in share mode</strong></p><p>​    <code>in share mode</code>子句的作用就是将查找的数据加上一个share锁，这个就是表示其他的事务只能对这些数据进行简单的 select 操作，而不能进行 DML 操作。</p><p><strong>使用场景</strong>：为了确保自己查询的数据不会被其他事务正在修改，也就是确保自己查询到的数据是最新的数据，并且不允许其他事务来修改数据。与<code>select for update</code>不同的是，本事务在查找完之后不一定能去更新数据，因为有可能其他事务也对同数据集使用了 <code>in share mode</code>的方式加上了S锁；</p><p><strong>性能分析</strong>：<code>select lock in share mode</code>语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的<code>commit</code>或者<code>rollback</code>也可能会造成大量的事务等待。</p><h2 id="4-行锁的类型"><a href="#4-行锁的类型" class="headerlink" title="4 行锁的类型"></a>4 行锁的类型</h2><p>​    接下来根据应用场景的不同，又可以将行锁进行进一步的划分：<code>Next-Key Lock</code>、<code>Gap Lock</code>、<code>Record Lock</code>以及<code>插入意向GAP锁</code>。</p><p>​    不同的锁锁定的位置是不同的，比如说记录锁只锁定对应的记录，而间隙锁锁住记录和记录之间的间隙，Next-key Lock则锁住所属记录之间的间隙。不同的锁类型锁定的范围大致如图所示：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220318165041572.png" alt="image-20220318165041572"></p><h3 id="4-1-记录锁（Record-Lock）"><a href="#4-1-记录锁（Record-Lock）" class="headerlink" title="4.1 记录锁（Record Lock）"></a>4.1 记录锁（Record Lock）</h3><p>​    记录锁最简单的一种行锁形式。</p><h3 id="4-2-间隙锁（Gap-Lock）"><a href="#4-2-间隙锁（Gap-Lock）" class="headerlink" title="4.2 间隙锁（Gap Lock）"></a>4.2 间隙锁（Gap Lock）</h3><p>​    当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（参考上面所说的空闲块）的记录，就叫做间隙。</p><p>​    从上面这句话可以表明间隙锁是所在两个存在的索引之间，是一个开区间，像最开始的那张索引图，15和18之间，是有（16，17）这个间隙存在的。</p><p>​    共享间隙锁与独占间隙锁之间是没有区别的，两者之间并不冲突。其存在的目的都是防止其他事务往间隙中插入新的纪录，故而一个事务所采取的间隙锁是不会去阻止另外一个事务在同一个间隙中加锁的。</p><p>​    在 RU 和 RC 两种隔离级别下，即使使用 <code>select in share mode </code>或 <code>select for update</code>，也无法防止<strong>幻读</strong>（读后写的场景）。因为这两种隔离级别下只会有<strong>行锁</strong>，而不会有<strong>间隙锁</strong>。而如果是 RR 隔离级别的话，就会在间隙上加上间隙锁。</p><h3 id="4-3-临键锁（Next-key-Lock）"><a href="#4-3-临键锁（Next-key-Lock）" class="headerlink" title="4.3 临键锁（Next-key Lock）"></a>4.3 临键锁（Next-key Lock）</h3><p>​    临键锁是记录锁与与间隙锁的结合，所以临键锁与间隙锁是一个同时存在的概念，并且临键锁是个左开有闭的却比如(16, 18]。</p><p>​     MySQL 默认隔离级别是RR，在这种级别下，如果你使用 <code>select in share mode </code>或者 <code>select for update </code>语句，那么InnoDB会使用临键锁（记录锁 + 间隙锁），因而可以防止幻读；</p><p>​    但还有种情况是隔离级别是 RR，如果使用普通的<code>select</code>语句，那么此时 InnoDB 引擎将是使用快照读，应该是不会有幻读幻读问题。</p><h3 id="4-4-插入意向锁（Insert-Intention-Lock）"><a href="#4-4-插入意向锁（Insert-Intention-Lock）" class="headerlink" title="4.4 插入意向锁（Insert Intention Lock）"></a>4.4 插入意向锁（Insert Intention Lock）</h3><p>​    不同类型的锁之间的兼容如下表所示：</p><table><thead><tr><th></th><th>RECORED</th><th>GAP</th><th>NEXT-KEY</th><th>II GAP（插入意向锁）</th></tr></thead><tbody><tr><td>RECORED</td><td></td><td>兼容</td><td></td><td>兼容</td></tr><tr><td>GAP</td><td>兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>NEXT-KEY</td><td></td><td>兼容</td><td></td><td>兼容</td></tr><tr><td>II GAP</td><td>兼容</td><td></td><td></td><td>兼容</td></tr></tbody></table><p>（其中行表示已有的锁，列表示意图加上的锁）</p><p>其中，第一行表示已有的锁，第一列表示要加的锁。插入意向锁较为特殊，所以我们先对插入意向锁做个总结，如下：</p><ul><li>插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；</li><li>插入意向锁与间隙锁和 <code>Next-key </code>锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 <code>Next-key</code>锁，则会阻塞。</li></ul><p>其他类型的锁的规则较为简单：</p><ul><li>间隙锁不和其他锁（不包括插入意向锁）冲突；</li><li>记录锁和记录锁冲突，<code>Next-key</code>锁和 <code>Next-key</code> 锁冲突，记录锁和 <code>Next-key</code>锁冲突；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/jojop/p/13982679.html">【MySQL】MySQL中的锁机制 - 周二鸭 - 博客园 (cnblogs.com)</a></p><p>《MySQL是怎样运行的》</p><blockquote><p>本文很多都摘抄自己其他文章，仅作个人学习使用，未进行传播，如有侵权，联系即删</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从实现一个RPC来分析其原理及用途</title>
    <link href="/2022/03/15/%E6%A1%86%E6%9E%B6/RPC/%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%9D%A5%E5%88%86%E6%9E%90%E5%85%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E9%80%94/"/>
    <url>/2022/03/15/%E6%A1%86%E6%9E%B6/RPC/%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%9D%A5%E5%88%86%E6%9E%90%E5%85%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E9%80%94/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><h3 id="1-1-什么是RPC"><a href="#1-1-什么是RPC" class="headerlink" title="1.1 什么是RPC"></a>1.1 什么是RPC</h3><p>​    RPC(Remote Procedure Call)——远程过程调用，是一种通过网络从远程计算机程序请求服务，而不需要了解底层网络技术的协议。</p><p>​    解决的问题是：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单</strong>。</p><h3 id="1-2-RPC简要原理"><a href="#1-2-RPC简要原理" class="headerlink" title="1.2 RPC简要原理"></a>1.2 RPC简要原理</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315212947355.png" alt="image-20220315212947355"></p><ol><li>服务消费方（<code>client</code>）调用以本地调用方式调用服务； </li><li><code>client stub</code>接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </li><li><code>client stub</code>找到服务地址，并将消息发送到服务端； </li><li><code>server stub</code>收到消息后进行解码； </li><li><code>server stub</code>根据解码结果调用本地的服务； </li><li>本地服务执行并将结果返回给<code>server stub</code>； </li><li><code>server stub</code>将返回结果打包成消息并发送至消费方； </li><li><code>client stub</code>接收到消息，并进行解码； </li><li>服务消费方得到最终结果。</li></ol><h3 id="1-3-为什么用RPC，而不用HTTP"><a href="#1-3-为什么用RPC，而不用HTTP" class="headerlink" title="1.3 为什么用RPC，而不用HTTP"></a>1.3 为什么用RPC，而不用HTTP</h3><p>​    首先，这两个并不是一种概念，RPC是一种<strong>设计</strong>，用于解决<strong>不同服务之间的调用问题</strong>，RPC实现一般会包含<strong>传输协议</strong>和<strong>序列化协议</strong>两个。</p><p>​    而HTTP是一种<strong>传输协议</strong>，RPC可以使用HTTP作为传输协议，也可以直接使用TCP，不同的协议对应不同的场景</p><p>​    通常，使用TCP的RPC效率比使用HTTP更高</p><p><strong>传输效率</strong></p><ul><li>TCP，通常自定义上层协议，请求报文体积更小</li><li>HTTP，请求中会包含很多无用的内容</li></ul><p><strong>性能消耗</strong></p><ul><li>TCP，可以基于各种序列化框架进行，效率比较高</li><li>HTTP，大部分通过json实现，字节大小和序列化耗时都更消耗性能</li></ul><p><strong>跨平台</strong></p><ul><li>TCP：通常要求客户端和服务端为统一平台</li><li>HTTP：可以在各种异构平台运行</li></ul><p><strong>总结</strong></p><p>​    RPC 的 TCP 方式主要用于系统内部的服务调用，性能消耗低，传输效率高。而且封装了“服务发现”，“负载均衡”，“熔断降级”一类面向服务的高级特性</p><p>​    HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p><p>将通俗点，就是RPC就像地区方言（有些方言可能就是普通话），只有内部知道，双方都需要知道方言，不然没法沟通；HTTP就是普通话，基本都能懂，也会说</p><h2 id="2-如何设计一个RPC"><a href="#2-如何设计一个RPC" class="headerlink" title="2 如何设计一个RPC"></a>2 如何设计一个RPC</h2><p>​    RPC的设计一般都会包含五个模块：协议模块，序列化模块，网络模块，服务端模块和客户端模块。</p><p>​    协议模块一般是指：请求和响应参数的封装，服务的描述等</p><p>​    序列化模块：提供将对象通过<strong>某种方法</strong>把对象以字节序列的形式保存起来的API</p><p>​    网络传输模块：定义网络传输协议，提供服务调用功能</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220316162829467.png" alt="image-20220316162829467"></p><p>以下结合netty传输来设计</p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nowcoder.com/discuss/588903?source_id=profile_create_nctrack&channel=-1">(近)万字总结，RPC 项目相关问题及解答_技术交流_牛客网 (nowcoder.com)</a></p><p><a href="https://blog.csdn.net/qq_41054313/article/details/88424454">(109条消息) java int转byte数组_Dan淡淡的心的博客-CSDN博客_int转byte数组</a></p><p><a href="https://www.zhihu.com/question/41609070">(25 封私信 / 1 条消息) 既然有 HTTP 请求，为什么还要用 RPC 调用？ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为式：模板方法模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    定义如下：定义一个操作中算法的框架，而<strong>将一些步骤延迟到子类中</strong>。</p><p>​    模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 </p><p>​    模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320155637537.png" alt="image-20220320155637537"></p><h2 id="2-代码框架"><a href="#2-代码框架" class="headerlink" title="2 代码框架"></a>2 代码框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <span class="hljs-comment">//模板方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span> </span>&#123; <br>        PrimitiveOperation1();<br>        PrimitiveOperation2();<br>        PrimitiveOperation3(); <br>    &#125;<br>    <span class="hljs-comment">//基本方法—具体方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation1</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-comment">//实现代码 </span><br>    &#125;<br>    <span class="hljs-comment">//基本方法—抽象方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-comment">//基本方法—钩子方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> virtual <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation3</span><span class="hljs-params">()</span> </span>&#123;&#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> override <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation2</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-comment">//实现代码 </span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> override <span class="hljs-keyword">void</span> <span class="hljs-title">PrimitiveOperation3</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-comment">//实现代码 </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-设计分析"><a href="#3-设计分析" class="headerlink" title="3 设计分析"></a>3 设计分析</h2><p>开发一个利息计算模块</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320160907771.png" alt="image-20220320160907771"></p><p>​    代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Template;<br><br><span class="hljs-keyword">import</span> java.io.Console;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account account;<br>        account = <span class="hljs-keyword">new</span> CurrentAccount();<br>        account.Handle(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">//基本方法——具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">Validate</span><span class="hljs-params">(String account, String password)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;账号：&quot;</span> + account);<br>        System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + password);<br>        <span class="hljs-comment">//模拟登录</span><br>        <span class="hljs-keyword">if</span> (account.equals(<span class="hljs-string">&quot;张无忌&quot;</span>) &amp;&amp; password.equals(<span class="hljs-string">&quot;123456&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//基本方法——抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CalculateInterest</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//基本方法——具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">&quot;显示利息！&quot;</span>); &#125;<br>    <span class="hljs-comment">//模板方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span><span class="hljs-params">(String account, String password)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!Validate(account,password)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;账户或密码错误！&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        CalculateInterest();<br>        Display();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentAccount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">//覆盖父类的抽象基本方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CalculateInterest</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;按活期利率计算利息！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavingAccount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">//覆盖父类的抽象基本方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CalculateInterest</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;按定期利率计算利息！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</li><li>代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为</li><li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则</li></ol><p>缺点：</p><ol><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象</li></ol><p><strong>适用场景</strong></p><ul><li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现的场景</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制e</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为式：策略模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    定义为：定义一些独立的类来封装不同的算法，并让它们可以相互替换。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320153127331.png" alt="image-20220320153127331"></p><p>​    <code>Context</code>是用适用算法的角色</p><h2 id="2-代码框架"><a href="#2-代码框架" class="headerlink" title="2 代码框架"></a>2 代码框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStrategy</span> </span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//声明抽象算法 </span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStrategy</span> </span>&#123; <br>    <span class="hljs-comment">//算法的具体实现 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-comment">//算法A </span><br>    &#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> AbstractStrategy strategy; <br>    <span class="hljs-comment">//维持一个对抽象策略类的引用 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(AbstractStrategy strategy)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.strategy= strategy; <br>    &#125;<br>    <span class="hljs-comment">//调用策略类中的算法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123; <br>        strategy.algorithm(); <br>    &#125; <br>&#125;<br><br><span class="hljs-comment">// 客户端代码...</span><br>Context context = <span class="hljs-keyword">new</span> Context(); <br>AbstractStrategy strategy; <br>strategy = <span class="hljs-keyword">new</span> ConcreteStrategyA(); <br><span class="hljs-comment">//可在运行时指定类型 </span><br>context.setStrategy(strategy); <br>context.algorithm();<br></code></pre></td></tr></table></figure><h2 id="3-设计分析"><a href="#3-设计分析" class="headerlink" title="3 设计分析"></a>3 设计分析</h2><p>​    实现电影院打折方案</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320153523078.png" alt="image-20220320153523078"></p><p>​    代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Strategy;<br><br><span class="hljs-keyword">import</span> DesignPatterns.JavaDesign.FactoryMethod.XMLUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MovieTicket mt = <span class="hljs-keyword">new</span> MovieTicket();<br>        <span class="hljs-keyword">double</span> originalPrice = <span class="hljs-number">60.0</span>;<br>        <span class="hljs-keyword">double</span> currentPrice; mt.setPrice(originalPrice); System.out.println(<span class="hljs-string">&quot;原始价为：&quot;</span> + originalPrice); System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);<br>        Discount discount;<br>        discount = <span class="hljs-keyword">new</span> ChildrenDiscount();  <span class="hljs-comment">// &lt;-------可用xml优化</span><br>        <span class="hljs-comment">//读取配置文件并反射生成具体折扣对象</span><br>        mt.setDiscount(discount);<br>        <span class="hljs-comment">//注入折扣对象</span><br>        currentPrice = mt.getPrice();<br>        System.out.println(<span class="hljs-string">&quot;折后价为：&quot;</span> + currentPrice);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电影票类：环境类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieTicket</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;<br>    <span class="hljs-keyword">private</span> Discount discount;<br>    <span class="hljs-comment">//维持一个对抽象折扣类的引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br>    <span class="hljs-comment">//注入一个折扣类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDiscount</span><span class="hljs-params">(Discount discount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.discount = discount;<br>    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//调用折扣类的折扣价计算方法</span><br>        <span class="hljs-keyword">return</span> discount.calculate(<span class="hljs-keyword">this</span>.price);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//折扣类：抽象策略类</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Discount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> price)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//学生票折扣类：具体策略类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Discount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学生票：&quot;</span>);<br>        <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.8</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//儿童票折扣类：具体策略类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildrenDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Discount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;儿童票：&quot;</span>);<br>        <span class="hljs-keyword">return</span> price - <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//VIP会员票折扣类：具体策略类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VIPDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Discount</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> price)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;VIP票：&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;增加积分！&quot;</span>);<br>        <span class="hljs-keyword">return</span> price * <span class="hljs-number">0.5</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>符合“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为。</li><li>策略模式提供了管理相关的算法族的办法</li><li>策略模式提供了一种算法的复用机制</li><li>使用策略模式可以避免多重条件选择语句</li></ol><p>缺点</p><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类</li><li>无法同时在客户端使用多个策略类</li></ol><p><strong>适用场景</strong></p><ul><li>一个系统需要动态地在几种算法中选择一种</li><li>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行为式：观察者模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    观察者模式是使用频率最高的设计模式之一。</p><p>​    基本是：<strong>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</strong>。</p><p>​    别名又称为<strong>发布-订阅模式</strong>，<strong>模型-视图模式</strong>，<strong>源-监听者模式</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220317135413512.png" alt="image-20220317135413512"></p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><p>​    使用观察者模式来进行多人联机对战游戏的设计</p><h3 id="2-1-栗子"><a href="#2-1-栗子" class="headerlink" title="2.1 栗子"></a>2.1 栗子</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220317135633752.png" alt="image-20220317135633752"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Observer;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义观察目标对象</span><br>        AllyControlCenter acc;<br>        acc = <span class="hljs-keyword">new</span> ConcreteAllyControlCenter(<span class="hljs-string">&quot;金庸群侠&quot;</span>);<br>        <span class="hljs-comment">// 定义四个观察者对象</span><br>        Observer player1, player2, player3, player4;<br>        player1 = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;杨过&quot;</span>);<br>        acc.join(player1);<br><br>        player2 = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;令狐冲&quot;</span>);<br>        acc.join(player2);<br><br>        player3 = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        acc.join(player3);<br><br>        player4 = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;段誉&quot;</span>);<br>        acc.join(player4);<br><br>        player1.beAttacked(acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 声明支援盟友方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beAttacked</span><span class="hljs-params">(AllyControlCenter acc)</span></span>;  <span class="hljs-comment">// 声明遭受攻击方法</span><br>&#125;<br><br><span class="hljs-comment">// 战队成员类：具体观察者类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 支援盟友方法的实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;坚持住，&quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;来救你&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法notifyObserver</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beAttacked</span><span class="hljs-params">(AllyControlCenter acc)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;被攻击&quot;</span>);<br>        acc.notifyObserver(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllyControlCenter</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String allyName;  <span class="hljs-comment">// 战队名称</span><br>    <span class="hljs-keyword">protected</span> ArrayList&lt;Observer&gt; players = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAllyName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> allyName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAllyName</span><span class="hljs-params">(String allyName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.allyName = allyName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(Observer obs)</span> </span>&#123;<br>        System.out.println(obs.getName() + <span class="hljs-string">&quot;加入&quot;</span> + <span class="hljs-keyword">this</span>.allyName);<br>        players.add(obs);<br>    &#125;<br><br>    <span class="hljs-comment">// 注销方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quit</span><span class="hljs-params">(Observer obs)</span> </span>&#123;<br>        System.out.println(obs.getName() + <span class="hljs-string">&quot;退出&quot;</span> + <span class="hljs-keyword">this</span>.allyName);<br>        players.remove(obs);<br>    &#125;<br><br>    <span class="hljs-comment">// 声明抽象通知方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 具体战队控制中心类：具体目标类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAllyControlCenter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AllyControlCenter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteAllyControlCenter</span><span class="hljs-params">(String allyName)</span> </span>&#123;<br>        System.out.println(allyName + <span class="hljs-string">&quot;战队组建成功！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>        <span class="hljs-keyword">this</span>.allyName = allyName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.allyName + <span class="hljs-string">&quot;战队紧急通知，盟友&quot;</span> + name);<br>        <span class="hljs-comment">// 遍历观察者集合，调用每一个盟友的支援方法</span><br>        <span class="hljs-keyword">for</span> (Observer player : players) &#123;<br>            <span class="hljs-keyword">if</span> (!((Observer)player).getName().equalsIgnoreCase(name)) &#123;<br>                ((Observer)player).help();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    在本例中，实现了两次对象之间的联动，当一个游戏玩家<code>Player</code>对象的<code>beAttacked()</code>方法被调用时，将调用<code>AllyControlCenter</code>的<code>notifyObserver()</code>方法来进行处理，而在<code>notifyObserver()</code>方法中又将调用其他Player对象的<code>help()</code>方法。</p><p>Player.beAttacked() –&gt; AllyControlCenter.notifyObserver() –&gt;Player</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</li><li>观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码</li></ol><p>缺点：</p><ol><li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间</li><li>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ol><h2 id="4-场景使用"><a href="#4-场景使用" class="headerlink" title="4 场景使用"></a>4 场景使用</h2><h3 id="4-1-Spring中ApplicationContext的使用"><a href="#4-1-Spring中ApplicationContext的使用" class="headerlink" title="4.1 Spring中ApplicationContext的使用"></a>4.1 Spring中ApplicationContext的使用</h3><p>​    <code>ApplicationContext</code>事件机制是观察者设计模式的实现，通过 <code>ApplicationEvent</code>类和 <code>ApplicationListener </code>接口，可以实现 <code>ApplicationContext</code>事件处理。    如果容器中有一个 <strong>ApplicationListener Bean</strong> ，每当 <strong>ApplicationContext</strong> 发布 <strong>ApplicationEvent</strong> 时，<strong>ApplicationListener Bean</strong> 将自动被触发。这种事件机制都必须需要程序显示的触发。</p><p>​    ApplicationContext事件监听</p><p>​    当ApplicationContext内的Bean对象初始化完成时，此时可以通过监听 ContextRefreshedEvent 得到通知</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220317144156644.png" alt="image-20220317144156644"></p><p>​    将对象添加到容器中</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220317144210447.png" alt="image-20220317144210447"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220317144215098.png" alt="image-20220317144215098"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220317144221216.png" alt="image-20220317144221216"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wangmourena/article/details/107784802">(111条消息) 设计模式之Spring中观察者模式_字节跳动的博客-CSDN博客_spring中的观察者模式</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构式：代理模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构式：外观模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    外观模式是使用频率非常高的结构式设计模式。定义如下：为子系统中一组接口提供一个统一的入口，外部与其内部的通信通过一个统一的外观类进行。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320141134145.png" alt="image-20220320141134145"></p><h2 id="2-代码框架"><a href="#2-代码框架" class="headerlink" title="2 代码框架"></a>2 代码框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemA</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 业务代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 业务代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemC</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodC</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 业务代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SubSystemA obj1 = <span class="hljs-keyword">new</span> SubSystemA();<br>    <span class="hljs-keyword">private</span> SubSystemB obj1 = <span class="hljs-keyword">new</span> SubSystemB();<br>    <span class="hljs-keyword">private</span> SubSystemC obj1 = <span class="hljs-keyword">new</span> SubSystemC();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span><span class="hljs-params">()</span> </span>&#123;<br>        obj.MethodA();<br>        obj.MethodB();<br>        obj.MethodC();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> </span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(string[] args)</span> </span>&#123; <br>        Facade facade = <span class="hljs-keyword">new</span> Facade(); facade.Method(); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-设计分析"><a href="#3-设计分析" class="headerlink" title="3 设计分析"></a>3 设计分析</h2><h3 id="3-1-栗子"><a href="#3-1-栗子" class="headerlink" title="3.1 栗子"></a>3.1 栗子</h3><p>​    开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320141855040.png" alt="image-20220320141855040"></p><p>​    代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Facade;<br><br><span class="hljs-keyword">import</span> sun.misc.BASE64Encoder;<br><br><span class="hljs-keyword">import</span> javax.sound.sampled.AudioFormat;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EncryptFacade ef = <span class="hljs-keyword">new</span> EncryptFacade();<br>        ef.FileEncrypt(<span class="hljs-string">&quot;src.txt&quot;</span>, <span class="hljs-string">&quot;des.txt&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileReader</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Read</span><span class="hljs-params">(String fileNameSrc)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;读取文件，获取明文：&quot;</span>);<br>        FileInputStream fs = <span class="hljs-keyword">null</span>;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">try</span> &#123;<br>            fs = <span class="hljs-keyword">new</span> FileInputStream(fileNameSrc);<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-keyword">while</span>((data = fs.read())!= -<span class="hljs-number">1</span>) &#123;<br>                sb = sb.append((<span class="hljs-keyword">char</span>)data);<br>            &#125;<br>            fs.close();<br>            System.out.println(sb);<br>        &#125;<span class="hljs-keyword">catch</span>(FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件不存在！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件操作错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CipherMachine</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Encrypt</span><span class="hljs-params">(String plainText)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;数据加密，将明文转换为密文：&quot;</span>);<br>        String es = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">char</span>[] chars = plainText.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch: chars) &#123;<br>            String c = String.valueOf(ch % <span class="hljs-number">7</span>); es += c;<br>        &#125;<br>        System.out.println(es);<br>        <span class="hljs-keyword">return</span> es;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileWriter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(String encryptStr,String fileNameDes)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存密文，写入文件。&quot;</span>);<br>        FileOutputStream fs = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fs = <span class="hljs-keyword">new</span> FileOutputStream(fileNameDes);<br>            <span class="hljs-keyword">byte</span>[] str = encryptStr.getBytes(StandardCharsets.UTF_8);<br>            fs.write(str,<span class="hljs-number">0</span>, str.length);<br>            fs.flush();<br>            fs.close();<br>        &#125;<span class="hljs-keyword">catch</span>(FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;文件不存在！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            System.out.println(e.getMessage());<br>            System.out.println(<span class="hljs-string">&quot;文件操作错误！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptFacade</span> </span>&#123; <br>    <span class="hljs-comment">//维持对其他对象的引用 </span><br>    <span class="hljs-keyword">private</span> FileReader reader; <br>    <span class="hljs-keyword">private</span> CipherMachine cipher; <br>    <span class="hljs-keyword">private</span> FileWriter writer;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EncryptFacade</span><span class="hljs-params">()</span> </span>&#123; <br>        reader = <span class="hljs-keyword">new</span> FileReader(); <br>        cipher = <span class="hljs-keyword">new</span> CipherMachine(); <br>        writer = <span class="hljs-keyword">new</span> FileWriter(); &#125;<br>        <span class="hljs-comment">//调用其他对象的业务方法 </span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FileEncrypt</span><span class="hljs-params">(String fileNameSrc, String fileNameDes)</span> </span>&#123;<br>        String plainStr = reader.Read(fileNameSrc);<br>        String encryptStr = cipher.Encrypt(plainStr); <br>        writer.Write(encryptStr, fileNameDes); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-优化"><a href="#3-2-优化" class="headerlink" title="3.2 优化"></a>3.2 优化</h3><p>​    如何在不修改客户端代码的前提下使用新的外观类呢？解决方法之一是：引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220320144853344.png" alt="image-20220320144853344"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li> 对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</li><li>实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li></ol><p>缺点</p><ol><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li></ol><p><strong>适用场景</strong></p><ul><li><p>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式</p></li><li><p>客户端程序与多个子系统之间存在很大的依赖性。</p></li><li><p>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联 </p><p>  系，而通过外观类建立联系，降低层之间的耦合度</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构式：组合模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    组合模式为：组合多个对象形成<strong>树形结构</strong>以表示具有”整体——部分“关系的层次结构。</p><p>​    组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。</p><p>​    在组合模式中引入了抽象构件类<code>Component</code>，它是所有容器类和叶子类的公共父类，客户端针对<code>Component</code>进行编程。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315160507105.png" alt="image-20220315160507105"></p><p>​    该模式的关键在于定义了一个抽象构件类，它<strong>既可以代表叶子，又可以代表容器</strong>，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</p><p>​    同时容器对象与抽象构件类之间还建立一个<strong>聚合关联</strong>关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构</p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><h3 id="2-1-栗子"><a href="#2-1-栗子" class="headerlink" title="2.1 栗子"></a>2.1 栗子</h3><p>​    杀毒软件框架设计，客户可以一致地对待文件和文件夹</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315160838041.png" alt="image-20220315160838041"></p><p>代码大概如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Composite;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//针对抽象构件编程</span><br>        AbstractFile file1, file2, file3, file4, file5, folder1, folder2, folder3, folder4;<br>        folder1 = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;Sunny的资料&quot;</span>);<br>        folder2 = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;图像文件&quot;</span>);<br>        folder3 = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;文本文件&quot;</span>);<br>        folder4 = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;视频文件&quot;</span>);<br>        file1 = <span class="hljs-keyword">new</span> ImageFile(<span class="hljs-string">&quot;小龙女.jpg&quot;</span>);<br>        file2 = <span class="hljs-keyword">new</span> ImageFile(<span class="hljs-string">&quot;张无忌.gif&quot;</span>);<br>        file3 = <span class="hljs-keyword">new</span> TextFile(<span class="hljs-string">&quot;九阴真经.txt&quot;</span>);<br>        file4 = <span class="hljs-keyword">new</span> TextFile(<span class="hljs-string">&quot;葵花宝典.doc&quot;</span>);<br>        file5 = <span class="hljs-keyword">new</span> VideoFile(<span class="hljs-string">&quot;笑傲江湖.rmvb&quot;</span>);<br>        folder2.add(file1);<br>        folder2.add(file2);<br>        folder3.add(file3);<br>        folder3.add(file4);<br>        folder4.add(file5);<br>        folder1.add(folder2);<br>        folder1.add(folder3);<br>        folder1.add(folder4);<br>        <span class="hljs-comment">//从“Sunny的资料”节点开始进行杀毒操作</span><br>        folder1.killVirus();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象文件类：抽象构件</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFile</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(AbstractFile file)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AbstractFile file)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractFile <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killVirus</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//图像文件类：叶子构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFile</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageFile</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractFile <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killVirus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//模拟杀毒</span><br>        System.out.println(<span class="hljs-string">&quot;----对图像文件&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;进行杀毒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//文本文件类：叶子构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFile</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TextFile</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractFile <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killVirus</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//模拟杀毒</span><br>        System.out.println(<span class="hljs-string">&quot;----对文本文件&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;进行杀毒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//视频文件类：叶子构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFile</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VideoFile</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractFile <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对不起，不支持该方法！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killVirus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//模拟杀毒</span><br>        System.out.println(<span class="hljs-string">&quot;----对视频文件&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;进行杀毒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//文件夹类：容器构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Folder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFile</span> </span>&#123;<br>    <span class="hljs-comment">//定义集合fileList，用于存储AbstractFile类型的成员</span><br>    <span class="hljs-keyword">private</span> ArrayList&lt;AbstractFile&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;AbstractFile&gt;();<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Folder</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        fileList.add(file);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(AbstractFile file)</span> </span>&#123;<br>        fileList.remove(file);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractFile <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (AbstractFile) fileList.get(i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killVirus</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;****对文件夹&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;进行杀毒&quot;</span>);<br>        <span class="hljs-comment">//模拟杀毒</span><br>        <span class="hljs-comment">// 递归调用成员构件的killVirus()方法</span><br>        <span class="hljs-keyword">for</span> (Object obj : fileList) &#123;<br>            ((AbstractFile) obj).killVirus();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-原来方案的问题"><a href="#2-2-原来方案的问题" class="headerlink" title="2.2 原来方案的问题"></a>2.2 原来方案的问题</h3><p>​    由于在AbstractFile中声明了大量用于管理和访问成员构件的方法，例如add()、remove()等方法，我们不得不在新增的文件类中实现这些方法，提供对应的错误提示和异常处理</p><p>​    解决方案1：将叶子构件的add()、remove()等方法的实现代码移至AbstractFile类中，由AbstractFile提供统一的默认实现</p><p>​    解决方案2：除此之外，还有一种解决方法是在抽象构件AbstractFile中不声明任何用于访问和管理成员构件的方法</p><p>​    根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式</p><h3 id="2-3-透明组合模式"><a href="#2-3-透明组合模式" class="headerlink" title="2.3 透明组合模式"></a>2.3 透明组合模式</h3><p>​        透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法，这样做的好处是确保所有的构件类都有相同的接口。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315164205913.png" alt="image-20220315164205913"></p><p>​    透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。</p><h3 id="2-4-安全组合模式"><a href="#2-4-安全组合模式" class="headerlink" title="2.4 安全组合模式"></a>2.4 安全组合模式</h3><p>​    安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315164253322.png" alt="image-20220315164253322"></p><p>​    安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高，在Java AWT中使用的组合模式就是安全组合模式。  </p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p><strong>优点</strong></p><ol><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ol><p><strong>缺点</strong></p><p>​    在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂</p><p><strong>适用场景</strong></p><ol><li> 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构式：适配器模式</title>
    <link href="/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那个类可以一起工作，其别名为包装类。</p><p>​    根据适配器类与适配者类的关系不同，适配器模式可分为<strong>对象适配器</strong>和<strong>类适配器</strong>两种</p><ul><li>在对象适配器模式中，适配器与适配者之间是关联关系；</li><li>在类适配器模式中，适配器与适配者之间是继承（或实现）关系</li></ul><p>​    一般来说，对象适配器使用频率更高</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315141136533.png" alt="image-20220315141136533"></p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><p>​    使用适配器模式重用算法库中的算法</p><h3 id="2-1-栗子"><a href="#2-1-栗子" class="headerlink" title="2.1 栗子"></a>2.1 栗子</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315142428170.png" alt="image-20220315142428170"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Adapter;<br><br><span class="hljs-keyword">import</span> com.tencentcloudapi.cdn.v20180606.models.Sort;<br><br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScoreOperation operation; <span class="hljs-comment">// 针对抽象目标接口编程</span><br>        operation = <span class="hljs-keyword">new</span> OperationAdapter();<span class="hljs-comment">// 可使用配置文件</span><br>        <span class="hljs-keyword">int</span> scores[] = &#123;<span class="hljs-number">84</span>, <span class="hljs-number">76</span>, <span class="hljs-number">58</span>, <span class="hljs-number">79</span>, <span class="hljs-number">91</span>, <span class="hljs-number">84</span>, <span class="hljs-number">66</span>&#125;;<br>        <span class="hljs-keyword">int</span> result[];<br>        <span class="hljs-keyword">int</span> score;<br><br>        System.out.println(<span class="hljs-string">&quot;成绩排序结果&quot;</span>);<br>        result = operation.sort(scores);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : scores) &#123;<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;查找成绩91：&quot;</span>);<br>        score = operation.search(result, <span class="hljs-number">91</span>);<br>        <span class="hljs-keyword">if</span> (score != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;找到成绩91&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有找到成绩91&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象成绩操作类：目标接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreOperation</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span> array[]); <span class="hljs-comment">//成绩排序</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> key)</span></span>;    <span class="hljs-comment">//成绩排序</span><br>&#125;<br><br><span class="hljs-comment">// 快速排序类：适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] quickSort(<span class="hljs-keyword">int</span> array[]) &#123;<br>        sort(array, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> x = array[mid];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span> (array[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span> (array[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) swap(array, i, j);<br>        &#125;<br>        sort(array, l, j);<br>        sort(array, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> t = a[i];<br>        a[i] = a[j];<br>        a[j] = t;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 二分查找类：适配者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearch</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> high = array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (array[mid] &lt; key) low = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[mid] &gt; key) high = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 操作适配器：适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ScoreOperation</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> QuickSort sortObj;  <span class="hljs-comment">// 定义适配器QuickSort对象</span><br>    <span class="hljs-keyword">private</span> BinarySearch searchObj; <span class="hljs-comment">// 定义适配器BinarySearch对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperationAdapter</span><span class="hljs-params">()</span> </span>&#123;<br>        sortObj = <span class="hljs-keyword">new</span> QuickSort();<br>        searchObj = <span class="hljs-keyword">new</span> BinarySearch();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] array) &#123;<br>        <span class="hljs-keyword">return</span> sortObj.quickSort(array);    <span class="hljs-comment">// 调用适配器类QuickSort的排序方法</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> searchObj.binarySearch(array, key);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-类适配器"><a href="#2-2-类适配器" class="headerlink" title="2.2 类适配器"></a>2.2 类适配器</h3><p>​    类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315145425366.png" alt="image-20220315145425366"></p><p>一般适配器的代码大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-title">implemements</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        specificRequest();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    由于Java、C#等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器；此外，如果适配者Adapter为最终 （Final）类，也无法使用类适配器。</p><h3 id="2-3-双向适配器"><a href="#2-3-双向适配器" class="headerlink" title="2.3 双向适配器"></a>2.3 双向适配器</h3><p>​    在<strong>对象适配器</strong>的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，<strong>适配者可以通过它调用目标类中的方法</strong>，<strong>目标类也可以通过它调用适配者类中的方法</strong>，那么该适配器就是一个双向适配器</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315145936709.png" alt="image-20220315145936709"></p><p>​    在实际开发中，很少使用双向适配器</p><h3 id="2-4-缺省适配器"><a href="#2-4-缺省适配器" class="headerlink" title="2.4 缺省适配器"></a>2.4 缺省适配器</h3><p>​    缺省适配器模式(Default Adapter Pattern)：当<strong>不需要实现一个接口所提供的所有方法</strong>时，可先设计一个<strong>抽象类</strong>实现该接口，并为接口中每个方法提供一个<strong>默认实现（空方法）</strong>，那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220315151221409.png" alt="image-20220315151221409"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong>    </p><p><strong>优点</strong></p><ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 </li></ol><p><strong>缺点</strong>（对象适配器）</p><ol><li>要在适配器中置换适配者类的某些方法比较麻烦</li></ol><p><strong>适用场景</strong></p><ol><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 </li></ol><h2 id="4-场景使用"><a href="#4-场景使用" class="headerlink" title="4 场景使用"></a>4 场景使用</h2><h3 id="4-1-Spring的Aop对适配器模式的使用"><a href="#4-1-Spring的Aop对适配器模式的使用" class="headerlink" title="4.1 Spring的Aop对适配器模式的使用"></a>4.1 Spring的Aop对适配器模式的使用</h3><p>​    AOP的大致流程是这样的：使用<strong>代理模式</strong>（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， <strong>并在代理类的方法前，设置拦截器</strong>，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。</p><p>​    Advice（通知）的类型有：<code>BeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>ThreowSadvice</code>的。</p><p>​    在每个类型Advice（通知）都有对应的拦截器，<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceInterceptor</code>、<code>ThrowsAdviceInterceptor</code>。</p><p>​    Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。下面我们看看具体的代码。</p><p>代码大致如下：</p><p>MethodBeforeAdvice类：<code>Adaptee</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodBeforeAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeforeAdvice</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>Adapter类接口： <code>Target</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AdvisorAdapter</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsAdvice</span><span class="hljs-params">(Advice advice)</span></span>;<br><br><span class="hljs-function">MethodInterceptor <span class="hljs-title">getInterceptor</span><span class="hljs-params">(Advisor advisor)</span></span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>MethodBeforeAdviceAdapter类：<code>Adapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeAdviceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AdvisorAdapter</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsAdvice</span><span class="hljs-params">(Advice advice)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (advice <span class="hljs-keyword">instanceof</span> MethodBeforeAdvice);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> MethodInterceptor <span class="hljs-title">getInterceptor</span><span class="hljs-params">(Advisor advisor)</span> </span>&#123;<br>MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MethodBeforeAdviceInterceptor(advice);<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>DefaultAdvisorAdapterRegistry类：<code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultAdvisorAdapterRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AdvisorAdapterRegistry</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br> <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="hljs-keyword">new</span> ArrayList&lt;AdvisorAdapter&gt;(<span class="hljs-number">3</span>);<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultAdvisorAdapterRegistry</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//这里注册了适配器</span><br>registerAdvisorAdapter(<span class="hljs-keyword">new</span> MethodBeforeAdviceAdapter());<br>registerAdvisorAdapter(<span class="hljs-keyword">new</span> AfterReturningAdviceAdapter());<br>registerAdvisorAdapter(<span class="hljs-keyword">new</span> ThrowsAdviceAdapter());<br>&#125;<br> <br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">wrap</span><span class="hljs-params">(Object adviceObject)</span> <span class="hljs-keyword">throws</span> UnknownAdviceTypeException </span>&#123;<br><span class="hljs-keyword">if</span> (adviceObject <span class="hljs-keyword">instanceof</span> Advisor) &#123;<br><span class="hljs-keyword">return</span> (Advisor) adviceObject;<br>&#125;<br><span class="hljs-keyword">if</span> (!(adviceObject <span class="hljs-keyword">instanceof</span> Advice)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(adviceObject);<br>&#125;<br>Advice advice = (Advice) adviceObject;<br><span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;<br><span class="hljs-comment">// So well-known it doesn&#x27;t even need an adapter.</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);<br>&#125;<br><span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-keyword">this</span>.adapters) &#123;<br><span class="hljs-comment">// Check that it is supported.</span><br><span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;<span class="hljs-comment">//这里调用了适配器的方法</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);<br>&#125;<br>&#125;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(advice);<br>&#125;<br> <br><span class="hljs-keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="hljs-keyword">throws</span> UnknownAdviceTypeException &#123;<br>List&lt;MethodInterceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;MethodInterceptor&gt;(<span class="hljs-number">3</span>);<br>Advice advice = advisor.getAdvice();<br><span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;<br>interceptors.add((MethodInterceptor) advice);<br>&#125;<br><span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-keyword">this</span>.adapters) &#123;<br><span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;<span class="hljs-comment">//这里调用了适配器的方法</span><br>interceptors.add(adapter.getInterceptor(advisor));<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (interceptors.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());<br>&#125;<br><span class="hljs-keyword">return</span> interceptors.toArray(<span class="hljs-keyword">new</span> MethodInterceptor[interceptors.size()]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAdvisorAdapter</span><span class="hljs-params">(AdvisorAdapter adapter)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.adapters.add(adapter);<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团3-12笔试</title>
    <link href="/2022/03/15/%E7%AC%94%E8%AF%95/%E7%BE%8E%E5%9B%A23-12%E7%AC%94%E8%AF%95/"/>
    <url>/2022/03/15/%E7%AC%94%E8%AF%95/%E7%BE%8E%E5%9B%A23-12%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>​    输入n个数字，判断每个数字满足以下两个条件之一：是11的倍数数位里面1的个数大于等于2，如果满足输入yes，否则输出no</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">11</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x) &#123;<br>            <span class="hljs-keyword">int</span> t = x % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>) cnt ++;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &gt;= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">while</span> (n --) &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(x)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>​    输入n(0&lt;n&lt;1000)个数字，每个数字可能是1或者是-1，问连续的序列的乘积是正数的数有多少个？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为了使序列的乘积为正数，那么-1的个数一定要是偶数个，所以我们将输入的-1转换为1，输入的1转换为0</span><br><span class="hljs-comment"> * 然后就可以利用前缀和先预处理然后O(1)地求出每段的-1的个数啦。</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>) x = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> x = <span class="hljs-number">0</span>;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + x;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">int</span> tmp = sum[i] - sum[j];<br>            <span class="hljs-keyword">if</span> (tmp % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ans ++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>​    n个顾客点餐，每个顾客可以点两份餐，数据保证点的餐的种类在1-m，但是饭店现在只可以提供一份1-m种类的餐各一份。</p><p>​    问最多可以满足多少位顾客的点餐需求。（0&lt;n&lt;20)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span></span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">25</span>, M = <span class="hljs-number">45</span>;<br><span class="hljs-keyword">int</span> q[N][<span class="hljs-number">2</span>], cnt;<br><span class="hljs-keyword">int</span> st[N], full[M];<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; q[i][<span class="hljs-number">0</span>] &gt;&gt; q[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) full[i] = <span class="hljs-number">1</span>;<br>    cnt = m / <span class="hljs-number">2</span>; <span class="hljs-comment">// 最多可以满意的顾客数</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 当前顾客号，已选人数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sum &lt;= cnt) res = <span class="hljs-built_in">max</span>(res, sum);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = u; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x1 = q[i][<span class="hljs-number">0</span>], x2 = q[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (full[x1] == <span class="hljs-number">0</span> || full[x2] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        full[x1] --, full[x2] --;<br>        sum ++;<br>        <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, sum);<br>        sum --;<br>        full[x1] ++, full[x2] ++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>​    n个房间（0&lt;n&lt;=10)，初始的时候A在第一个房间，现在有一个游戏，游戏时长为m（0&lt;m&lt;=10000)秒，给出m 秒每秒的炸弹所在的房间，A需要在每秒避开这些炸弹，也就是A不能在有炸弹的房间。A可以在每秒后选择移动到n个房间中的一个，但是需要消耗1个能量，当然也可以不移动，问A最少需要消耗多少能量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by 86139 on 2022/3/12.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> dp[N][<span class="hljs-number">13</span>];<br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">2 1 1 2</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i]);<br>    &#125;<br>    <span class="hljs-comment">// dp[i][j] 表示 第i秒在第j个房间的最小消耗</span><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//第1秒肯定没有消耗</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>        dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>            <span class="hljs-keyword">if</span> (q[i] != j) &#123; <span class="hljs-comment">// 第 i 秒肯定不能选a[i]这个房间</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (j != k) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][k] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][k]);<br>                &#125;<br>            &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        res = <span class="hljs-built_in">min</span>(res, dp[m][i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h2><p>​    首先输入一个数n(0&lt;n&lt;100000)，表示树的结点的个数，然后输入n个数表示每个结点的颜色，0表示白色，1表示黑色。 接下来输入n个数，表示第i个结点的父节点，如果是0就表示这个结点时根节点。 </p><p>​    然后，对于白色结点，如果他的子节点中存在一个黑色结点或者它是叶子结点，那么他就是好结点；对于黑色结点，如果它的所有子节点都是白色或者它是叶子结点，那么它就是好结点。 </p><p>​     问，树里面白色好结点和黑色好结点的个数。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里3.14笔试</title>
    <link href="/2022/03/14/%E7%AC%94%E8%AF%95/%E9%98%BF%E9%87%8C3-14%E7%AC%94%E8%AF%95/"/>
    <url>/2022/03/14/%E7%AC%94%E8%AF%95/%E9%98%BF%E9%87%8C3-14%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>题目大意：给出一个16进制的字符串，要求统计其二进制表示中1的个数<br><code>len &lt;= 2*10^5</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by 86139 on 2022/3/14.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 0xeeeeedddddccccc11111</span><br><span class="hljs-comment"> * 45</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; map;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map[<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-number">0</span>;<br>    map[<span class="hljs-string">&#x27;1&#x27;</span>] = <span class="hljs-number">1</span>;<br>    map[<span class="hljs-string">&#x27;2&#x27;</span>] = <span class="hljs-number">1</span>;<br>    map[<span class="hljs-string">&#x27;3&#x27;</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">&#x27;4&#x27;</span>] = <span class="hljs-number">1</span>;<br>    map[<span class="hljs-string">&#x27;5&#x27;</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">&#x27;6&#x27;</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">&#x27;7&#x27;</span>] = <span class="hljs-number">3</span>;<br>    map[<span class="hljs-string">&#x27;8&#x27;</span>] = <span class="hljs-number">1</span>;<br>    map[<span class="hljs-string">&#x27;9&#x27;</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">3</span>;<br>    map[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-number">3</span>;<br>    map[<span class="hljs-string">&#x27;e&#x27;</span>] = <span class="hljs-number">3</span>;<br>    map[<span class="hljs-string">&#x27;f&#x27;</span>] = <span class="hljs-number">4</span>;<br><br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        ans += map[s[i]];<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>题目大意：给出大小为<code>n ∗ m </code>的01矩阵，从每个0的位置上下左右看，问所有在位置上下左右看一共能看到多少个1.(视线是一条直线)<br><code>n,m&lt;=1e3</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by 86139 on 2022/3/14.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-keyword">int</span> q[N][N], l[N][N], r[N][N], u[N][N], d[N][N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2 4</span><br><span class="hljs-comment">0 1 0 0</span><br><span class="hljs-comment">1 0 1 0</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>            cin &gt;&gt; q[i][j];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            l[i][j] = l[i][j - <span class="hljs-number">1</span>] | q[i][j];<br>            u[i][j] = u[i - <span class="hljs-number">1</span>][j] | q[i][j];<br>        &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j &gt;= <span class="hljs-number">1</span>; --j) &#123;<br>            r[i][j] = r[i][j + <span class="hljs-number">1</span>] | q[i][j];<br>            d[i][j] = d[i + <span class="hljs-number">1</span>][j] | q[i][j];<br>        &#125;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!q[i][j]) res += l[i][j] + r[i][j] + u[i][j] + d[i][j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>​    题目大意：你有一个8*8的棋盘，每个格子上的棋有rgb三种状态，你在上面玩消消乐(可能不是?)，每次选一个格子，将它的连通块全部消掉。消掉之后还指定了一种方向让所有棋子向一个方向下落。还有一种填充棋子的方法，需要你模拟这个过程(输出每次消除的棋子个数)。<br><code>opt &lt; = 10000</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by 86139 on 2022/3/14.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">rbbbrrrb</span><br><span class="hljs-comment">ggggbrbr</span><br><span class="hljs-comment">rrrggbrr</span><br><span class="hljs-comment">gbrgbrrr</span><br><span class="hljs-comment">bgbgrrrg</span><br><span class="hljs-comment">bgbgbrrb</span><br><span class="hljs-comment">rggrgggg</span><br><span class="hljs-comment">bgbrgrgr</span><br><span class="hljs-comment">bbrgggggbbgbbbrg</span><br><span class="hljs-comment">bbgbrgbgbbgbbbrg</span><br><span class="hljs-comment">brgbgbbggbbgbbbr</span><br><span class="hljs-comment">gbbgbbbrggrbbgrb</span><br><span class="hljs-comment">bgrbbrgggrbrgbrr</span><br><span class="hljs-comment">brgbrgbrgrgbrgbr</span><br><span class="hljs-comment">brbbrbbbrbrrggrg</span><br><span class="hljs-comment">ggrbrgbgbrgggrbr</span><br><span class="hljs-comment">1 5 w</span><br><span class="hljs-comment">1 4 d</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> cnt;<br><span class="hljs-keyword">char</span> g[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>string s[<span class="hljs-number">15</span>];<br><span class="hljs-keyword">int</span> v[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br><span class="hljs-keyword">int</span> nw[<span class="hljs-number">15</span>]; <span class="hljs-comment">// 用于标记某行某列的元素适用情况</span><br><span class="hljs-keyword">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;, dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j)<br>            cin &gt;&gt; g[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i) cin &gt;&gt; s[i];<br>    <span class="hljs-keyword">while</span> (n --) &#123;<br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-keyword">char</span> op;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; op;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j)<br>                v[i][j] = <span class="hljs-number">0</span>;<br><br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(x, y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;w&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j) &#123;  <span class="hljs-comment">// 遍历每一列</span><br>                vector&lt;<span class="hljs-keyword">char</span>&gt; tmp;<br>                tmp.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i) <span class="hljs-keyword">if</span> (!v[i][j]) tmp.<span class="hljs-built_in">push_back</span>(g[i][j]); <span class="hljs-comment">// 将该列未标记的元素添加到tmp</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-built_in">size</span>(); ++i) g[i + <span class="hljs-number">1</span>][j] = tmp[i];  <span class="hljs-comment">// 填充到上一列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tmp.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i) g[i][j] = s[j][nw[j] ++]; <span class="hljs-comment">// 填补下面的空格，s[j][nw[j]++]表示第j行的第nw[j]个元素</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;s&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j) &#123;<br>                vector&lt;<span class="hljs-keyword">char</span>&gt; tmp;<br>                tmp.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i) <span class="hljs-keyword">if</span> (!v[i][j]) tmp.<span class="hljs-built_in">push_back</span>(g[i][j]);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">8</span>, k = tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; --i, --k) g[i][j] = tmp[k];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">8</span> - tmp.<span class="hljs-built_in">size</span>(); j &gt;= <span class="hljs-number">1</span>; --j) g[i][j] = s[j][nw[j]++];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i) &#123;<br>                vector&lt;<span class="hljs-keyword">char</span>&gt; tmp;<br>                tmp.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j) <span class="hljs-keyword">if</span> (!v[i][j]) tmp.<span class="hljs-built_in">push_back</span>(g[i][j]);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; tmp.<span class="hljs-built_in">size</span>(); ++j) g[i][j + <span class="hljs-number">1</span>] = tmp[j];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = tmp.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j) g[i][j] = s[i][nw[i]++];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;d&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; ++i) &#123;<br>                vector&lt;<span class="hljs-keyword">char</span>&gt; tmp;<br>                tmp.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">8</span>; ++j) <span class="hljs-keyword">if</span> (!v[i][j]) tmp.<span class="hljs-built_in">push_back</span>(g[i][j]);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">8</span>, k = tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; --j, --k) g[i][j] = tmp[k];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">8</span> - tmp.<span class="hljs-built_in">size</span>(); j &gt;= <span class="hljs-number">1</span> ; --j) g[i][j] = s[i][nw[i]++];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 标记连通块</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    v[x][y] = <span class="hljs-number">1</span>;<br>    cnt ++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> nx = x + dx[i], ny = y + dy[i];<br>        <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">1</span> || nx &gt; <span class="hljs-number">8</span> || ny &lt; <span class="hljs-number">1</span> || ny &gt; <span class="hljs-number">8</span> || v[nx][ny] || g[x][y] != g[nx][ny]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(nx, ny);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建式：建造者模式</title>
    <link href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。</p><p>​    定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314154653486.png" alt="image-20220314154653486"></p><p>​    建造者模式和抽象工厂模式的不同：</p><ol><li>建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品</li><li>在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导Director类如何去生成对象，<strong>侧重于一步步构造一个复杂对象</strong>，然后将结果返回</li></ol><p>​    举个例子，如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。 </p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><p>​    使用建造者模式来实现游戏角色的创建</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314155330853.png" alt="image-20220314155330853"></p><p>​    代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Builder;<br><br><span class="hljs-keyword">import</span> DesignPatterns.JavaDesign.FactoryMethod.XMLUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ActorBuilder ab;<br>        <span class="hljs-comment">//针对抽象建造者编程</span><br>        ab = <span class="hljs-keyword">new</span> AngelBuilder();<br>        <span class="hljs-comment">//反射生成具体建造者对象</span><br>        ActorController ac = <span class="hljs-keyword">new</span> ActorController();<br>        Actor actor;<br>        actor = ac.construct(ab);<br>        <span class="hljs-comment">//通过指挥者创建完整的建造者对象</span><br>        String type = actor.getType();<br>        System.out.println(type + <span class="hljs-string">&quot;的外观：&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;性别：&quot;</span> + actor.getSex());<br>        System.out.println(<span class="hljs-string">&quot;面容：&quot;</span> + actor.getFace());<br>        System.out.println(<span class="hljs-string">&quot;服装：&quot;</span> + actor.getCostume());<br>        System.out.println(<span class="hljs-string">&quot;发型：&quot;</span> + actor.getHairstyle());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String type;    <span class="hljs-comment">//角色类型</span><br>    <span class="hljs-keyword">private</span> String sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> String face;    <span class="hljs-comment">//脸型</span><br>    <span class="hljs-keyword">private</span> String costume; <span class="hljs-comment">//服装</span><br>    <span class="hljs-keyword">private</span> String hairstyle;   <span class="hljs-comment">//发型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.type = type;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFace</span><span class="hljs-params">(String face)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.face = face;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCostume</span><span class="hljs-params">(String costume)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.costume = costume;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHairstyle</span><span class="hljs-params">(String hairstyle)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hairstyle = hairstyle;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.type);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.sex);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFace</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.face);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCostume</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.costume);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHairstyle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.hairstyle);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//角色建造器：抽象建造者</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Actor actor = <span class="hljs-keyword">new</span> Actor();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSex</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCostume</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHairstyle</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//工厂方法，返回一个完整的游戏角色对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Actor <span class="hljs-title">createActor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> actor;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//英雄角色建造器：具体建造者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActorBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildType</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setType(<span class="hljs-string">&quot;英雄&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSex</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setFace(<span class="hljs-string">&quot;英俊&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCostume</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setCostume(<span class="hljs-string">&quot;盔甲&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHairstyle</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setHairstyle(<span class="hljs-string">&quot;飘逸&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//天使角色建造器：具体建造者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AngelBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActorBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildType</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setType(<span class="hljs-string">&quot;天使&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSex</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setSex(<span class="hljs-string">&quot;女&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setFace(<span class="hljs-string">&quot;漂亮&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCostume</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setCostume(<span class="hljs-string">&quot;白裙&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHairstyle</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setHairstyle(<span class="hljs-string">&quot;披肩长发&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//恶魔角色建造器：具体建造者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevilBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActorBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildType</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setType(<span class="hljs-string">&quot;恶魔&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSex</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setSex(<span class="hljs-string">&quot;妖&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setFace(<span class="hljs-string">&quot;丑陋&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCostume</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setCostume(<span class="hljs-string">&quot;黑衣&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHairstyle</span><span class="hljs-params">()</span> </span>&#123;<br>        actor.setHairstyle(<span class="hljs-string">&quot;光头&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//游戏角色创建控制器：指挥者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActorController</span> </span>&#123;<br>    <span class="hljs-comment">//逐步构建复杂产品对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Actor <span class="hljs-title">construct</span><span class="hljs-params">(ActorBuilder ab)</span> </span>&#123;<br>        Actor actor;<br>        ab.buildType();<br>        ab.buildSex();<br>        ab.buildFace();<br>        ab.buildCostume();<br>        ab.buildHairstyle();<br>        actor = ab.createActor();<br>        <span class="hljs-keyword">return</span> actor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在建造者模式中，客户端只需实例化指挥者类，指挥者类针对抽象建造者编程，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品。</p><p>​    在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者</li><li>可以更加精细地控制产品的创建过程</li></ol><p>缺点：</p><ol><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本</li></ol><p><strong>适用场景</strong></p><ol><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li><li>对象的创建过程独立于创建该对象的类</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建式：原型模式</title>
    <link href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    原型模式大概是：<strong>创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象</strong></p><p>​    工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。</p><p>​    通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是<strong>相互独立</strong>的</p><p>​    </p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><h3 id="2-1-栗子"><a href="#2-1-栗子" class="headerlink" title="2.1 栗子"></a>2.1 栗子</h3><p>​    使用原型模式来实现工作周报的快速创建</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314150001843.png" alt="image-20220314150001843"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Prototype;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        WeeklyLog log_previous = <span class="hljs-keyword">new</span> WeeklyLog();<br>        <span class="hljs-comment">//创建原型对象</span><br>        log_previous.setName(<span class="hljs-string">&quot;张无忌&quot;</span>);<br>        log_previous.setDate(<span class="hljs-string">&quot;第12周&quot;</span>);<br>        log_previous.setContent(<span class="hljs-string">&quot;这周工作很忙，每天加班！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;****周报****&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;周次：&quot;</span> + log_previous.getDate());<br>        System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + log_previous.getName());<br>        System.out.println(<span class="hljs-string">&quot;内容：&quot;</span> + log_previous.getContent());<br>        System.out.println(<span class="hljs-string">&quot;--------------------------------&quot;</span>);<br>        WeeklyLog log_new;<br>        log_new = log_previous.clone(); <span class="hljs-comment">//调用克隆方法创建克隆对象</span><br>        log_new.setDate(<span class="hljs-string">&quot;第13周&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;****周报****&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;周次：&quot;</span> + log_new.getDate());<br>        System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + log_new.getName());<br>        System.out.println(<span class="hljs-string">&quot;内容：&quot;</span> + log_new.getContent());<br>        System.out.println(log_previous == log_new);<br>        System.out.println(log_previous.getDate() == log_new.getDate());<br>        System.out.println(log_previous.getName() == log_new.getName());<br>        System.out.println(log_previous.getContent() == log_new.getContent());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeeklyLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String date;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDate</span><span class="hljs-params">(String date)</span> </span>&#123; <span class="hljs-keyword">this</span>.date = date; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123; <span class="hljs-keyword">this</span>.content = content; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.name); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDate</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.date); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.content); &#125;<br>    <span class="hljs-comment">//克隆方法clone()，此处使用Java语言提供的克隆机制</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WeeklyLog <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        Object obj = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123; obj = <span class="hljs-keyword">super</span>.clone();<br>            <span class="hljs-keyword">return</span> (WeeklyLog)obj;<br>        &#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;不支持复制！&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314150105599.png" alt="image-20220314150105599"></p><h3 id="2-2-浅拷贝与深拷贝"><a href="#2-2-浅拷贝与深拷贝" class="headerlink" title="2.2 浅拷贝与深拷贝"></a>2.2 浅拷贝与深拷贝</h3><p><strong>浅拷贝</strong></p><p>​    在浅克隆中：</p><ul><li>如果原型对象的成员变量是<strong>值类型</strong>，将复制一份给克隆对象；</li><li>如果原型对象的 成员变量是<strong>引用类型</strong>，则将引用对象的<strong>地址</strong>复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量<strong>指向相同的内存地址</strong>。</li></ul><p><strong>深拷贝</strong></p><p>​    在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314150720771.png" alt="image-20220314150720771"></p><h3 id="2-3-原型管理器"><a href="#2-3-原型管理器" class="headerlink" title="2.3 原型管理器"></a>2.3 原型管理器</h3><p>​    原型管理器(Prototype Manager)是<strong>将多个原型对象存储在一个集合中供客户端使用</strong>，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314152548719.png" alt="image-20220314152548719"></p><p>​    下面模拟一个简单的公文管理器来介绍原型管理器的设计与实现</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314152651242.png" alt="image-20220314152651242"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.Prototype;<br><br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取原型管理器对象</span><br>        PrototypeManager pm = PrototypeManager.getPrototypeManager();<br>        OfficialDocument doc1,doc2,doc3,doc4;<br>        doc1 = pm.getOfficialDocument(<span class="hljs-string">&quot;far&quot;</span>); doc1.display();<br>        doc2 = pm.getOfficialDocument(<span class="hljs-string">&quot;far&quot;</span>); doc2.display();<br>        System.out.println(doc1 == doc2);<br>        doc3 = pm.getOfficialDocument(<span class="hljs-string">&quot;srs&quot;</span>);<br>        doc3.display();<br>        doc4 = pm.getOfficialDocument(<span class="hljs-string">&quot;srs&quot;</span>);<br>        doc4.display();<br>        System.out.println(doc3 == doc4);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//抽象公文接口，也可定义为抽象类，提供clone()方法的实现，将业务方法声明为抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OfficialDocument</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OfficialDocument <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//可行性分析报告(Feasibility Analysis Report)类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FAR</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OfficialDocument</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OfficialDocument <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        OfficialDocument far = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            far = (OfficialDocument) <span class="hljs-keyword">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;不支持复制！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> far;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;《可行性分析报告》&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//软件需求规格说明书(Software Requirements Specification)类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SRS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OfficialDocument</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OfficialDocument <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        OfficialDocument srs = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            srs = (OfficialDocument)<span class="hljs-keyword">super</span>.clone();<br>        &#125;<span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;不支持复制！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> srs;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;《软件需求规格说明书》&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//原型管理器（使用饿汉式单例实现）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeManager</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个Hashtable，用于存储原型对象</span><br>    <span class="hljs-keyword">private</span> Hashtable ht=<span class="hljs-keyword">new</span> Hashtable();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PrototypeManager pm = <span class="hljs-keyword">new</span> PrototypeManager();<br>    <span class="hljs-comment">//为Hashtable增加公文对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PrototypeManager</span><span class="hljs-params">()</span> </span>&#123;<br>        ht.put(<span class="hljs-string">&quot;far&quot;</span>,<span class="hljs-keyword">new</span> FAR());<br>        ht.put(<span class="hljs-string">&quot;srs&quot;</span>,<span class="hljs-keyword">new</span> SRS());<br>    &#125;<br>    <span class="hljs-comment">//增加新的公文对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOfficialDocument</span><span class="hljs-params">(String key,OfficialDocument doc)</span> </span>&#123;<br>        ht.put(key,doc);<br>    &#125;<br>    <span class="hljs-comment">//通过浅克隆获取新的公文对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OfficialDocument <span class="hljs-title">getOfficialDocument</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((OfficialDocument)ht.get(key)).clone();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PrototypeManager <span class="hljs-title">getPrototypeManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314153135181.png" alt="image-20220314153135181"></p><p>​    在<code>PrototypeManager</code>中定义了一个<code>Hashtable</code>类型的集合对象，使用“键值对”来存储原型对象，客户端可以通过Key（如“far”或“srs”）来获取对应原型对象的克隆对象。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>通过复制一个已有实例可以提高新实例的创建效率</li><li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响</li><li>可以使用深克隆的方式保存对象的状态</li></ol><p>缺点：</p><ol><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则</li><li>实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li></ol><p><strong>适用场景</strong></p><ol><li> 创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建式：单例模式</title>
    <link href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    单例模式简单来说就是不用创建多个实例</p><p>​    单例模式有三个要点：</p><ul><li>某个类只能有一个实例</li><li>它必须自行创建这个实例</li><li>必须自行向整个系统提供这个实例</li></ul><p>​    这是最简单的设计模式，核心结构只有一个包含称为单例类的特殊类</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314135336298.png" alt="image-20220314135336298"></p><p>​    下面就直接看看单例的几种实现方式把</p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><h3 id="2-1-饿汉式单例"><a href="#2-1-饿汉式单例" class="headerlink" title="2.1 饿汉式单例"></a>2.1 饿汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.ShangGuiGu.singleton.type1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Singleton instance = Singleton.getInstance();<br>        Singleton instance2 = Singleton.getInstance();<br>        System.out.println(instance == instance2);<br>        System.out.println(instance.hashCode());<br>        System.out.println(instance2.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 饿汉式（静态变量）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 构造器私有化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-comment">// 3. 提供一个公有的静态方法，返回实例对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314140002765.png" alt="image-20220314140002765"></p><h3 id="2-2-懒汉式单例（线程不安全）"><a href="#2-2-懒汉式单例（线程不安全）" class="headerlink" title="2.2 懒汉式单例（线程不安全）"></a>2.2 懒汉式单例（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.ShangGuiGu.singleton.type3;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Singleton instance = Singleton.getInstance();<br>        Singleton instance2 = Singleton.getInstance();<br>        System.out.println(instance == instance2);<br>        System.out.println(instance.hashCode());<br>        System.out.println(instance2.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">// 提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span><br>    <span class="hljs-comment">// 即懒汉式</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-懒汉式单例（线程安全DCL）✨"><a href="#2-3-懒汉式单例（线程安全DCL）✨" class="headerlink" title="2.3 懒汉式单例（线程安全DCL）✨"></a>2.3 懒汉式单例（线程安全DCL）✨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.ShangGuiGu.singleton.test.test3;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DCL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        B b1 = B.getSingleton();<br>        B b2 = B.getSingleton();<br>        System.out.println(b1 == b2);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> B <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (B.class) &#123;<br>                b = <span class="hljs-keyword">new</span> B();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    其实可以直接在方法上加锁保证线程安全，但这样导致系统性能降低，使用<strong>双重检查锁机制</strong>更加适合。注意，这里要使用<code>volatile</code>关键字，volatile关键字会屏蔽Java虚拟机所做的一些代码优化。</p><h3 id="2-4-IoDH✨"><a href="#2-4-IoDH✨" class="headerlink" title="2.4 IoDH✨"></a>2.4 IoDH✨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.ShangGuiGu.singleton;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolderClass</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> HolderClass.instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Singleton s1, s2;<br>        s1 = Singleton.getInstance();<br>        s2 = Singleton.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314141106108.png" alt="image-20220314141106108"></p><p>​    由于静态单例对象没有作为<code>Singleton</code>的成员变量直接实例化，因此类加载时不会实例化<code>Singleton</code>，第一次调用<code>getInstance()</code>时将加载内部类<code>HolderClass</code>，在该内部类中定义了一个<code>static</code>类型的变量<code>instance</code>，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于<code>getInstance()</code>方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>​    通过IoDH,既可以实现延迟加载，还可以保证线程安全，不影响系统性能，是最好的实现方式</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>单例模式提供了对唯一实例的受控访问</li><li>节约系统资源</li><li>允许可变数目的实例</li></ol><p>缺点：</p><ol><li>没有抽象层，因此单例类的扩展有很大的困难</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”</li><li>如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</li></ol><p><strong>适用场景</strong></p><ol><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。 </li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 </li></ol><h2 id="4-场景使用"><a href="#4-场景使用" class="headerlink" title="4 场景使用"></a>4 场景使用</h2><h3 id="4-1-Spring中的单例模式"><a href="#4-1-Spring中的单例模式" class="headerlink" title="4.1 Spring中的单例模式"></a>4.1 Spring中的单例模式</h3><p>​    Spring的依赖注入（包括lazy-init方式）都是发生在 <strong>AbstractBeanFactory</strong> 的 <strong>getBean</strong> 里。 <strong>getBean</strong> 的 <strong>doGetBean</strong> 方法调用 <strong>getSingleton</strong> 进行bean的创建。lazy-init方式(lazy-init=“true”)，在用户向容器第一次索要bean时进行调用；非lazy-init方式(lazy-init=“false”)，在容器初始化时候进行调用。</p><p>​    同步线程安全的单例核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSingletonBeanRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleAliasRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SingletonBeanRegistry</span> </span>&#123;<br><br>    <span class="hljs-comment">// 通过 Map 实现单例注册表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="hljs-number">64</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;<br>        Assert.notNull(beanName, <span class="hljs-string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">// 检查缓存中是否存在实例  </span><br>            Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<br>            <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// ...忽略代码</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    singletonObject = singletonFactory.getObject();<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>                    <span class="hljs-comment">// ...忽略代码</span><br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// ...忽略代码</span><br>                &#125;<br>                <span class="hljs-comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span><br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>            <span class="hljs-keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>            <span class="hljs-keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="hljs-keyword">null</span> ? singletonObject : NULL_OBJECT));<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    Spring 对 <code>Bean </code>实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 <code>ConcurrentHashMap</code>对象。</p><p>​    使用该方式的原因是<strong>方便继承</strong>。单例注册表的构造函数是<code>protected</code>，可以继承。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zouxiangzhongyan/p/10762540.html#:~:text=%E5%A4%96%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E8%B0%83%E7%94%A8,%E6%89%93%E5%8D%B0%E5%87%BA%E4%BA%86%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">Java 静态内部类的加载时机 - は問わない - 博客园 (cnblogs.com)</a></p><p><a href="https://www.zhihu.com/question/302510306">(28 封私信) 为什么Spring使用注册表来实现单例模式？ - 知乎 (zhihu.com)</a>–<a href="https://www.zhihu.com/people/dailinfu">木木甫</a>回答</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建式：抽象工厂</title>
    <link href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <url>/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    前面介绍过，工厂方法每个工厂只能生产一个产品，会导致系统存在大量的工厂类，增加系统的开销。此时，可以将一些相关的产品组成一个“<strong>产品族</strong>”，由同一个工厂来生产。这就是抽象工厂的基本思想。</p><p>​    也就是说，一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，可以生产电视机，冰箱，空调等。</p><blockquote><p>引入两个概念</p><p>产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p>产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</p></blockquote><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314124831786.png" alt="image-20220314124831786"></p><p>​        我们只要指明<strong>一个产品所处的产品族以及它所属的等级结构</strong>，就可以唯一确定这个产品。 </p><p>​        抽象工厂模式通常是用于创建不同产品等级结构的一个产品族中的所有对象</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314125346599.png" alt="image-20220314125346599"></p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><p>​    开发一套界面皮肤库，皮肤库代码不打算公开，用户通过菜单选择皮肤，不同皮肤提供不同按钮，文本框等</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314125651230.png" alt="image-20220314125651230"></p><h3 id="2-1-工厂方法设计"><a href="#2-1-工厂方法设计" class="headerlink" title="2.1 工厂方法设计"></a>2.1 工厂方法设计</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314125704964.png" alt="image-20220314125704964"></p><p>​    可以发现，该设计存在如下问题</p><ol><li>虽然增加类时不需要修改原有代码，可是要增加大量类，导致系统越来越庞大</li><li>每个组件都需要选择一个具体工厂，选择失误很容易导致界面显示混乱</li></ol><h3 id="2-2-抽象工厂设计"><a href="#2-2-抽象工厂设计" class="headerlink" title="2.2 抽象工厂设计"></a>2.2 抽象工厂设计</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314130048403.png" alt="image-20220314130048403"></p><p>代码大概如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.AbstractFactory;<br><br><span class="hljs-keyword">import</span> DesignPatterns.JavaDesign.FactoryMethod.XMLUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//使用抽象层定义</span><br>        SkinFactory factory;<br>        Button bt;<br>        TextField tf;<br>        ComboBox cb;<br>        <span class="hljs-comment">// 可以改为使用配置文件</span><br>        factory = <span class="hljs-keyword">new</span> SummerSkinFactory();<br>        bt = factory.createButton();<br>        tf = factory.createTextField();<br>        cb = factory.createComboBox();<br>        bt.display();<br>        tf.display();<br>        cb.display();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  按钮接口：抽象产品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Button</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Spring按钮类：具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Button</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;显示浅绿色按钮。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SummerButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Button</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;显示浅蓝色按钮&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文本框接口∶抽象产品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TextField</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Spring文本框类∶具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTextField</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TextField</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out .println( <span class="hljs-string">&quot;显示绿色边框文本框。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Summer文本框类∶具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SummerTextField</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TextField</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out .println ( <span class="hljs-string">&quot;显示蓝色边框文本框。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组合框接口∶抽象产品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ComboBox</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">( )</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Spring组合框类∶具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringComboBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ComboBox</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println( <span class="hljs-string">&quot;显示绿色边框组合框。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Summer组合框类︰具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SummerComboBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ComboBox</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println ( <span class="hljs-string">&quot;显示蓝色边框组合框。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  界面皮肤工厂接口∶抽象工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SkinFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Button <span class="hljs-title">createButton</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TextField <span class="hljs-title">createTextField</span> <span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ComboBox <span class="hljs-title">createComboBox</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// Spring皮肤工厂：具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSkinFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SkinFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Button <span class="hljs-title">createButton</span><span class="hljs-params">( )</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringButton( );<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TextField <span class="hljs-title">createTextField</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringTextField ();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ComboBox <span class="hljs-title">createComboBox</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringComboBox( );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Summer皮肤工厂：具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SummerSkinFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SkinFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Button <span class="hljs-title">createButton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SummerButton();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TextField <span class="hljs-title">createTextField</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SummerTextField();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ComboBox <span class="hljs-title">createComboBox</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SummerComboBox();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    如果需要更改皮肤，只需修改配置文件即可。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>隔绝了具体类的生成</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 </li><li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ol><p>缺点：</p><ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li></ol><p><strong>适用场景</strong></p><ol><li> 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族</li><li>属于同一个产品族的产品将在一起使用</li><li>产品等级结构稳定</li></ol><h2 id="4-场景使用"><a href="#4-场景使用" class="headerlink" title="4 场景使用"></a>4 场景使用</h2><h3 id="4-1-BeanFactory在Spring中的使用"><a href="#4-1-BeanFactory在Spring中的使用" class="headerlink" title="4.1 BeanFactory在Spring中的使用"></a>4.1 BeanFactory在Spring中的使用</h3><p>​    在 Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是 BeanFactory 的子类。这样我们可以通过 IOC 容器来管理访问 Bean，根据不同的策略调用 getBean() 方法，从而获得具体对象。</p><p>​    BeanFactory 接口的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>    String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs"> `BeanFactory`的子类主要有 `ClassPathXmlApplicationContext`、`XmlWebApplicationContext`、`StaticWebApplicationContext`、`StaticApplicationContext`。在 Spring 中，`DefaultListableBeanFactory`实现了所有工厂的公共逻辑。</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java设计模式》——刘伟</p><p><a href="https://blog.csdn.net/qq_36970993/article/details/110456122">(109条消息) 抽象工厂模式在spring源码中的应用_蒙奇D灬小武的博客-CSDN博客_抽象工厂模式在spring的应用</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的七大基本原则</title>
    <link href="/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <url>/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><table><thead><tr><th>设计原则名称</th><th>定义</th><th>使用频率</th></tr></thead><tbody><tr><td>单一职责原则</td><td>一个类只负责一个功能领域中的相应职责</td><td>✨✨✨✨</td></tr><tr><td>开闭原则</td><td>软件实体应对外扩展开放，而对修改关闭</td><td>✨✨✨✨✨</td></tr><tr><td>里氏代换原则</td><td>所有引用基类对象的地方都能够透明地使用其子类的对象</td><td>✨✨✨✨✨</td></tr><tr><td>依赖倒转原则</td><td>抽象不应该依赖于细节，细节应该依赖于抽象</td><td>✨✨✨✨✨</td></tr><tr><td>接口隔离原则</td><td>使用多个专门的接口，而不使用单一的总接口</td><td>✨✨</td></tr><tr><td>合成复用原则</td><td>尽量使用对象组合，而不是继承来达到复用的目的</td><td>✨✨✨✨</td></tr><tr><td>迪米特法则</td><td>一个软件实体应当尽可能少地与其他实体发生相互作用</td><td>✨✨✨</td></tr></tbody></table><h2 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2 单一职责原则"></a>2 单一职责原则</h2><p>​    从字面意思来看，就是一个类应该做到“专注”，如果一个类承担的职责越多，可复用性将会越小。</p><p>​    比如说，见下图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313205043900.png" alt="image-20220313205043900"></p><p>​    该类承担了，<code>getConnection()</code>方法用于连接数据库， <code>findCustomers()</code>用于查询所有的客户信息，<code>createChart()</code>用于创建图表，<code>displayChart()</code>用于显示图表。很明显，这样会导致耦合度过高。</p><p>​    改进后的图是这样的：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313205307591.png" alt="image-20220313205307591"></p><ul><li>DBUtil：负责连接数据库</li><li>CustomerDAO：负责操作数据库中的Customer表</li><li> CustomerDataChart：负责图表的生成和显示</li></ul><h2 id="3-开闭原则"><a href="#3-开闭原则" class="headerlink" title="3 开闭原则"></a>3 开闭原则</h2><p>​    这个原则简单来说就是：软件实体应该<strong>尽量在不修改原有代码的基础上进行扩展</strong></p><p>​    软件实体可以是一个模块，一个由多个类组成的局部类或一个独立的类</p><p>​    该原则的好处在于：使得软件拥有更好的稳定性和延续性</p><p>​    举个栗子：</p><p>​    一个系统需要展示不同的图表，它是按如下设计的</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313210457871.png" alt="image-20220313210457871"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;pie&quot;</span>)) &#123;<br>    PieChart chart = <span class="hljs-keyword">new</span> PieChart();<br>    chart.display();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;bar&quot;</span>)) &#123;<br>    BarChart chart = <span class="hljs-keyword">new</span> BarChart();<br>    chart.display();<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>可见上述代码和设计，如果后续要添加折线图，则还要新增判断逻辑。</p><p>修改如下：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313210736720.png" alt="image-20220313210736720"></p><p>​    添加一个抽象图表类<code>AbstractChart</code>，当要显示某种图表时，则注入对应的对象即可。</p><h2 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4 里氏替换原则"></a>4 里氏替换原则</h2><p>​    该原则是指：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p><p>​    这样说感觉有点抽象，举个栗子：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物</p><p>​    里氏替换原则是实现开闭原则的重要方式，因为一般代码都是<strong>使用基类类型来对对象定义，在运行时确定其子类类型</strong>，用子类对象来替换父类对象。</p><p>​    该原则需要注意以下问题：</p><ul><li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法</li><li>尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现</li></ul><p>​    举个发邮件的栗子</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313222532136.png" alt="image-20220313222532136"></p><p>​    可以发现，无论是普通用户还是VIP，其实发邮件都是相同的，也就是这里会出现代码重复，为了减少代码重复，可以用改用则进行重构</p><p>​    重构后，增加一个抽象类</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313222735493.png" alt="image-20220313222735493"></p><h2 id="5-依赖倒转原则"><a href="#5-依赖倒转原则" class="headerlink" title="5 依赖倒转原则"></a>5 依赖倒转原则</h2><p>​    依赖倒转原则是指：抽象不应该依赖细节，细节应该依赖于抽象。说人话就是，要<strong>面向接口/抽象类编程，而不是面向实现编程</strong></p><p>​    这也就要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类。</p><p>​    因为使用抽象层进行编程，可以提高系统的灵活性，对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 </p><p>​    常用的注入方式有三种：<strong>构造注入</strong>，<strong>设值注入</strong>，<strong>接口注入</strong>。</p><p>​    举个栗子来理解下</p><p>​    将存储在TXT或EXCEL文件中的客户信息存到数据库中，需要进行格式转换。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313224543068.png" alt="image-20220313224543068"></p><p>​    但是这有个问题，每次更改数据转化类，都需要修改CustomerDAO的源代码，系统扩展性较差。</p><p>​    重构方式如下：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313224734442.png" alt="image-20220313224734442"></p><p>​    引入抽象数据转换类<code>DataConvertor</code>，<code>CustomerDAO</code>针对抽象类<code>DataConvertor</code>编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。</p><p>​    根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会 出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增 加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即 可，原有代码无须做任何修改，满足开闭原则。</p><p>​    可以发现，3，4，5三种原则是密切联系的，开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段。只是分析的角度不同而已。</p><h2 id="6-接口隔离原则"><a href="#6-接口隔离原则" class="headerlink" title="6 接口隔离原则"></a>6 接口隔离原则</h2><p>​    该原则是指：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><p>​    简单来说，就是接口应该尽量细化，同时接口中的方法应该尽量少，每个接口只包含一个客户端所需的方法即可。</p><p>​    举个数据显示的栗子：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313225909805.png" alt="image-20220313225909805"></p><p>​    具体意义就不解释了，函数名很清晰</p><p>​    可以发现，如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错等。。</p><p>​    重构后</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313230052729.png" alt="image-20220313230052729"></p><p>​    重构后的接口粒度更细了，但要注意的是接口不能太小，如果太小会导致系 统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。    </p><h2 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7 合成复用原则"></a>7 合成复用原则</h2><p>​    该原则的含义是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。</p><p>​    简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 </p><p>在设计时：</p><ul><li>使用组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少</li><li>其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则</li></ul><blockquote><p> 继承的“危害”</p><p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。 </p></blockquote><p>​    一般来说，如果两个类之间是<code>“Has-A”</code>的关系应使用组合或聚合，如果是<code>“Is-A”</code>关系可使用继承。<code>&quot;Is-A&quot;</code>是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而<code>&quot;Has-A&quot;</code>则不同，它表示某一个角色具有某一项责任。</p><p>​    再来看一个连接数据库栗子</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313231412987.png" alt="image-20220313231412987"></p><p>​    该栗子是指，通过继承工具类的方式来连接MYSQL数据库，而如果系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。</p><p>​    重构后</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313231604180.png" alt="image-20220313231604180"></p><p>​    <code>CustomerDAO</code>和<code>DBUtil</code>之间的关系由继承关系变为关联关系。由于<code>CustomerDAO</code>针对<code>DBUtil</code>编程，根据里氏代换原则，<code>DBUtil</code>子类的对象可以覆盖 </p><p><code>DBUtil</code>对象，只需在<code>CustomerDAO</code>中注入子类对象即可使用子类所扩展的方法。</p><h2 id="8-迪米特原则"><a href="#8-迪米特原则" class="headerlink" title="8 迪米特原则"></a>8 迪米特原则</h2><p>​    该原则是指：一个软件实体应当尽可能少地与其他实体发生相互作用。 </p><p>​    迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：</p><ul><li>在类的划分上，应当尽量创建松 耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类；</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul><p>举个栗子</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313232311412.png" alt="image-20220313232311412"></p><p>​    一个业务窗口中有很多交互关系，可以发现这些关系十分复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。 </p><p>​    重构后</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313232423870.png" alt="image-20220313232423870"></p><p>​    引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建式：工厂方法</title>
    <link href="/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1 基本介绍"></a>1 基本介绍</h2><p>​    简单工厂方法模式由于每次引入新产品时，都需要通过传入参数的不同来创建不同的产品，这必定要修改工厂类的代码，违反了“开闭原则”</p><p>​    从而出现了——工厂方法模式，就是解决该问题的</p><p>​    工厂方法中，不再提供统一的工厂类来创建所有的产品对象，而是<strong>针对不同的产品提供不同的工厂</strong>。</p><p>​    一般是<strong>定义一个用于创建对象的接口，让子类决定将哪一个类实例化</strong>。如下图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314102322307.png" alt="image-20220314102322307"></p><h2 id="2-设计分析"><a href="#2-设计分析" class="headerlink" title="2 设计分析"></a>2 设计分析</h2><h3 id="2-1-简单工厂设计"><a href="#2-1-简单工厂设计" class="headerlink" title="2.1 简单工厂设计"></a>2.1 简单工厂设计</h3><p>​    通过栗子来理解把，现在某公司要设计一个系统运行日志记录器，用户可以通过修改配置文件更改日志记录方式，那么如何设计记录器的初始化和更改日志记录方式将会是一大难点。使用<strong>简单工厂模式</strong>设计如下</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314101334388.png" alt="image-20220314101334388"></p><p>​    这时候，LoggerFactory代码大概为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//日志记录器工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggerFactory</span> </span>&#123;<br><span class="hljs-comment">// 静态工厂方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title">createLogger</span><span class="hljs-params">( string args)</span></span>&#123;<br><span class="hljs-keyword">if</span>(args.equalsIgnoreCase ( <span class="hljs-string">&quot;db&quot;</span>)) &#123;<br><span class="hljs-comment">//连接数据库﹐代码省略</span><br><span class="hljs-comment">//创建数据库日志记录器对象</span><br>Logger logger : <span class="hljs-keyword">new</span> DatabaseLogger( );<span class="hljs-comment">//初始化数据库日志记录器﹐代码省略</span><br><span class="hljs-keyword">return</span> logger;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(args.equalsignorecase( <span class="hljs-string">&quot;file&quot;</span> )) &#123;<br><span class="hljs-comment">//创建日志文件</span><br><span class="hljs-comment">//创建文件日志记录器对象</span><br>Logger logger = <span class="hljs-keyword">new</span> FileLogger ( );<span class="hljs-comment">//初始化文件日志记录器﹐代码省略</span><br><span class="hljs-keyword">return</span> logger;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    这样设计问题很大，包含大量的<code>if...else...</code>代码，维护和测试难度增大，并且系统扩展不灵活</p><h3 id="2-2-工厂方法设计"><a href="#2-2-工厂方法设计" class="headerlink" title="2.2 工厂方法设计"></a>2.2 工厂方法设计</h3><p>​    使用工厂方法设计日志记录器，将会变成下面这样</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314102641800.png" alt="image-20220314102641800"></p><p>​        代码大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.FactoryMethod;<br><br><span class="hljs-comment">// 编写如下客户端测试代码∶</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        LoggerFactory factory;<br>        Logger logger;<br>        factory = <span class="hljs-keyword">new</span> FileLoggerFactory(); <span class="hljs-comment">//可引入配置文件实现</span><br>        <span class="hljs-comment">// factory = (LoggerFactory) XMLUtil.getBean();</span><br>        logger = factory.createLogger();<br>        logger.writeLog( );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 日志记录器接口︰抽象产品</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeLog</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 数据库日志记录器︰具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeLog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;数据库日志记录。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 文件日志记录器∶具体产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeLog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println( <span class="hljs-string">&quot;文件日志记录。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 日志记录器工厂接口︰抽象工厂</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoggerFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Logger <span class="hljs-title">createLogger</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 数据库日志记录器工厂类∶具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseLoggerFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoggerFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Logger <span class="hljs-title">createLogger</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//连接数据库﹐代码省略//创建数据库日志记录器对象</span><br>        Logger logger = <span class="hljs-keyword">new</span> DatabaseLogger();<span class="hljs-comment">//初始化数据库日志记录器﹐代码省略</span><br>        <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 文件日志记录器工厂类∶具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLoggerFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoggerFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Logger <span class="hljs-title">createLogger</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//创建文件日志记录器对象</span><br>        Logger logger = <span class="hljs-keyword">new</span> FileLogger( );<span class="hljs-comment">//创建文件·代码省略</span><br>        <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314104158213.png" alt="image-20220314104158213"></p><h4 id="添加xml配置文件优化"><a href="#添加xml配置文件优化" class="headerlink" title="添加xml配置文件优化"></a>添加xml配置文件优化</h4><p>xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">className</span>&gt;</span>DesignPatterns.JavaDesign.FactoryMethod.DatabaseLoggerFactory<span class="hljs-tag">&lt;/<span class="hljs-name">className</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>读取xml工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.FactoryMethod;<br><br><span class="hljs-keyword">import</span> org.w3c.dom.Document;<br><span class="hljs-keyword">import</span> org.w3c.dom.Node;<br><span class="hljs-keyword">import</span> org.w3c.dom.NodeList;<br><br><span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilder;<br><span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;<br><span class="hljs-keyword">import</span> java.io.File;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XMLUtil</span> </span>&#123;<br>    <span class="hljs-comment">// 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();<br>            DocumentBuilder builder = dFactory.newDocumentBuilder();<br>            Document doc;<br>            doc = builder.parse(<span class="hljs-keyword">new</span> File(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/main/resources/config.xml&quot;</span>));<br>            <span class="hljs-comment">// 获取包含类名的文本节点</span><br>            NodeList nl = doc.getElementsByTagName(<span class="hljs-string">&quot;className&quot;</span>);<br>            Node classNode = nl.item(<span class="hljs-number">0</span>).getFirstChild();<br>            String cName = classNode.getNodeValue();<br>            <span class="hljs-comment">// 通过类名生成实例对象并将其返回</span><br>            Class&lt;?&gt; c = Class.forName(cName);<br>            Object obj = c.newInstance();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修改客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编写如下客户端测试代码∶</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        LoggerFactory factory;<br>        Logger logger;<br>        <span class="hljs-comment">// factory = new FileLoggerFactory(); //可引入配置文件实现</span><br>        factory = (LoggerFactory) XMLUtil.getBean();<br>        logger = factory.createLogger();<br>        logger.writeLog( );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314105848133.png" alt="image-20220314105848133"></p><h3 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h3><p><strong>重载的工厂方法</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314110616056.png" alt="image-20220314110616056"></p><p>​    通过多种方式初始化日志记录器，例如可以提供默认实现，传入文件路径，或将参数封装在一个Object类型的对象中</p><p><strong>工厂方法的隐藏</strong></p><p>​    有时候需要对工厂方法函数进行隐藏</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220314110754654.png" alt="image-20220314110754654"></p><p>​    修改后的代码大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//改为抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggerFactory</span> </span>&#123; <span class="hljs-comment">//在工厂类中直接调用日志记录器类的业务方法writeLog ()</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeLog</span> <span class="hljs-params">()</span> </span>&#123;<br>Logger logger = <span class="hljs-keyword">this</span>.createLogger( );logger.writeLog ();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Logger <span class="hljs-title">createLogger</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">client</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( String args[])</span></span>&#123;<br>LoggerFactory factory;<br>factory = (LoggerFactory )XMLUtil.getBean( );<br>factory.writeLog( );<span class="hljs-comment">//直接使用工厂对象来调用产品对象的业务方法</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p><strong>优缺点分析</strong></p><p>优点：</p><ol><li>工厂方法用来创建客户所需的产品，同时<strong>隐藏了哪种具体产品类被实例化这一细节</strong>，用户只需关心产品对应的工厂，甚至都无需知道具体产品类的类名</li><li>加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，只<strong>需要添加一个具体工厂和具体产品就可以了</strong>。提高了系统的可扩展性，符合可扩展性</li></ol><p>缺点：</p><ol><li>添加新产品时需要添加对应工厂类和产品，类的个数成对增长，在一定程度上增加了系统复杂度</li><li>引入了抽象层，增加了系统的抽象和理解难度。且实现可能要用到DOM，反射技术，增加系统实现难度</li></ol><p><strong>使用场景</strong></p><ol><li>客户端不需要知道具体产品类的类名，只需要知道对应的工厂即可</li><li>抽象工厂类通过其子类来指定创建哪个对象</li></ol><h2 id="4-场景使用"><a href="#4-场景使用" class="headerlink" title="4 场景使用"></a>4 场景使用</h2><h3 id="4-1-Factory实例化Bean"><a href="#4-1-Factory实例化Bean" class="headerlink" title="4.1 Factory实例化Bean"></a>4.1 Factory实例化Bean</h3><p>​    FactoryBean是Spring容器提供的一种可以扩展容器对象实例化逻辑的接口，<strong>不要与容器BeanFacoty相混淆</strong></p><p>​    FactoryBean，其主语是Bean,定语是Factory，也就是说，它本身与其他注册到容器的对象一样，只是一个Bean而已，只不过这里类型的Bean本身就是<strong>生产对象的工厂</strong>。</p><p>​    当使用该工厂Bean时需要实现三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">该方法返回该FactoryBean“生产”的对象。我们需要实现该方法以给出自己对象实例化逻辑 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">该方法仅返回getObject()方法所返回的对象的类型。如果预先无法确定,则返回null</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该方法返回结果用于表明,getObject()“生产”的对象是否要以singleton(单例)形式存于容器中。如果以singleton形式存在,则返回true，否则返回false</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>; <br></code></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DesignPatterns.JavaDesign.FactoryMethod;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.FactoryBean;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        String bean = (String) context.getBean(<span class="hljs-string">&quot;bean&quot;</span>);<br>        System.out.println(bean);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">nameFactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//该方法返回该FactoryBean“生产”的对象</span><br>    <span class="hljs-comment">//我们需要实现该方法以给出自己对象实例化逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;w1nd&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//该方法仅返回getObject()方法所返回的对象的类型</span><br>    <span class="hljs-comment">//如果预先无法确定,则返回null</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//该方法返回结果用于表明,getObject()“生产”的对象是否要以singleton(单例)形式存于容器中</span><br>    <span class="hljs-comment">//如果以singleton形式存在,则返回true，否则返回false</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- FactoryBean实例化Bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;DesignPatterns.JavaDesign.FactoryMethod.nameFactoryBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java设计模式》——刘伟</p><p><a href="https://blog.csdn.net/lovelion/article/details/7523392">(108条消息) 创建对象与使用对象——谈谈工厂的作用_刘伟技术博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/w_linux/article/details/80063062">(109条消息) Spring 工厂方法与FactoryBean(实例化Bean)_浅然的专栏-CSDN博客_spring 工厂bean</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty入门（二）</title>
    <link href="/2022/03/13/netty/netty%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/03/13/netty/netty%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-netty工作原理"><a href="#1-netty工作原理" class="headerlink" title="1 netty工作原理"></a>1 netty工作原理</h2><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313160909453.png" alt="image-20220313160909453"></p><p>流程</p><ol><li><p>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写</p></li><li><p>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</p></li><li><p>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</p></li><li><p>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 Selector , 用于监听绑定在其上的 Socket 的网络通讯</p></li><li><p>NioEventLoopGroup(BossGroup、WorkerGroup) 可以有多个线程, 即可以含有多个 NioEventLoop</p></li><li><p>每个Boss 的 NioEventLoop 循环执行的步骤有3步</p><ol><li>轮询accept 事件</li><li>处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到 Worker 的 NIOEventLoop 上的 Selector</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ol></li><li><p>每个 Worker 的 NIOEventLoop 循环执行的步骤</p><ol><li>轮询read, write 事件</li><li>处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ol></li><li><p>每个Worker NIOEventLoop 处理业务时，会使用 Pipeline(管道), Pipeline 中包含了 Channel , 即通过 Pipeline 可以获取到对应通道, 管道中维护了很多的处理器。<strong>管道可以使用 Netty 提供的，也可以自定义</strong></p></li></ol><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2 快速入门"></a>2 快速入门</h2><p>实现</p><ol><li>Netty 服务器在 6666 端口监听，客户端能发送消息给服务器 “hello, 服务器~”</li><li>服务器可以回复消息给客户端 “hello, 客户端~”</li></ol><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--netty依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.52.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务端<code>NettyServer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.test;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<br><span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 创建BossGroup和 WorkerGroup</span><br><span class="hljs-comment">         * 1. 创建两个线程组BossGroup和 WorkerGroup</span><br><span class="hljs-comment">         * 2. BossGroup只处理请求</span><br><span class="hljs-comment">         * 3. WorkerGroup 处理真正客户端的业务</span><br><span class="hljs-comment">         * 4. 运行时，这两个都是无限循环</span><br><span class="hljs-comment">         */</span><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建服务端启动对象，并配置参数</span><br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            <span class="hljs-comment">// 链式编程</span><br>            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">// 设置两个线程组</span><br>                    .channel(NioServerSocketChannel.class)  <span class="hljs-comment">//使用NioServerSocketChannel作为服务器的通道实现</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)  <span class="hljs-comment">// 设置线程队列等待连接的个数</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)  <span class="hljs-comment">// 设置连续保持活动连接状态</span><br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">// 给workerGroup的NioEventLoop对应的管道设置处理器</span><br>                        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                         * 创建一个通道初始化对象</span><br><span class="hljs-comment">                         * 给workerGroup对应的管道设置处理器</span><br><span class="hljs-comment">                         * <span class="hljs-doctag">@param</span> socketChannel</span><br><span class="hljs-comment">                         * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            socketChannel.pipeline()    <span class="hljs-comment">// 获得这个socketChannel对应的pipeline</span><br>                                    .addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;服务器准备好...&quot;</span>);<br>            <span class="hljs-comment">// 绑定一个端口，并且同步，生成一个ChannelFuture对象</span><br>            <span class="hljs-comment">// 这里就已经启动了服务器</span><br>            ChannelFuture channelFuture = bootstrap.bind(<span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">// 对关闭通道进行监听</span><br>            <span class="hljs-comment">// 这里只是监听，只有关闭通道才进行处理，不是直接关闭通道</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义Netty服务端处理器：<code>NettyServerHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.test;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[server]：ctx&quot;</span> + ctx);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 将 msg 转换成 ByteBuffer</span><br><span class="hljs-comment">         *  说明 :</span><br><span class="hljs-comment">         *  1. 注意这个是 ByteBuf ，是 io.netty.buffer 包下的，不是 NIO 下的 Buffer</span><br><span class="hljs-comment">         *  2. ByteBuf 比 Buffer 的性能更高一点</span><br><span class="hljs-comment">         */</span><br>        ByteBuf buf = (ByteBuf) msg;<br>        <span class="hljs-comment">// 把 buf 转成 UTF8 格式的字符串</span><br>        System.out.println(<span class="hljs-string">&quot;客户端发送的msg：&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据读取完毕后，返回消息给客户端</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 把数据写入缓冲区，并刷新缓冲区</span><br><span class="hljs-comment">         * 一般来说，需要对这个发送的消息进行编码</span><br><span class="hljs-comment">         */</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;Hello，客户端&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 关闭通道</span><br>        ctx.channel().close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端<code>NettyClient</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.test;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 客户端需要一个事件循环组</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 客户端启动对象——Bootstrap，不是服务端的ServerBootstrap</span><br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            <span class="hljs-comment">// 设置相关参数</span><br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)  <span class="hljs-comment">// 设置客户端通道的实现类</span><br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;客户端准备好了...&quot;</span>);<br>            <span class="hljs-comment">// 启动客户端连接服务器端</span><br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">// 对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端处理器<code>NettyClientHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.test;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当通道准备就绪时，就会触发该方法，就可以发信息了</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[client]：ctx&quot;</span> + ctx);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;Hello, Server&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当通道有读取事件时，会触发</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;服务器发送的msg：&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;服务器的地址：&quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常处理</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.channel().close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313165849947.png" alt="image-20220313165849947"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313165908316.png" alt="image-20220313165908316"></p><h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3 分析"></a>3 分析</h2><h3 id="3-1-BossGroup-和-WorkGroup-怎么确定自己有多少个-NIOEventLoop"><a href="#3-1-BossGroup-和-WorkGroup-怎么确定自己有多少个-NIOEventLoop" class="headerlink" title="3.1 BossGroup 和 WorkGroup 怎么确定自己有多少个 NIOEventLoop"></a>3.1 BossGroup 和 WorkGroup 怎么确定自己有多少个 NIOEventLoop</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313172412321.png" alt="image-20220313172412321"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313172427404.png" alt="image-20220313172427404"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313172443477.png" alt="image-20220313172443477"></p><p>通过源码发现含有的子线程数默认为<strong>CPU核数*2</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313172635660.png" alt="image-20220313172635660"></p><p>​    我的CPU核数为8，所以有16个进程，每个进程的类型都是<code>NioEventLoop</code></p><h3 id="3-2-WorkerGroup是如何分配这些进程的"><a href="#3-2-WorkerGroup是如何分配这些进程的" class="headerlink" title="3.2 WorkerGroup是如何分配这些进程的"></a>3.2 WorkerGroup是如何分配这些进程的</h3><p>设置BossGroup进程数和WorkerGroup进程数</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313173204342.png" alt="image-20220313173204342"></p><p>重复运行5次客户端可发现</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313173257839.png" alt="image-20220313173257839"></p><p>所以，<code>WorkerGroup</code>分配的逻辑是按顺序分配的</p><h3 id="3-3-BossGroup和WorkerGroup中的Selector和TaskQueue"><a href="#3-3-BossGroup和WorkerGroup中的Selector和TaskQueue" class="headerlink" title="3.3 BossGroup和WorkerGroup中的Selector和TaskQueue"></a>3.3 BossGroup和WorkerGroup中的Selector和TaskQueue</h3><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313173537472.png" alt="image-20220313173537472"></p><h3 id="3-4-CTX上下文，Channel，Pipeline之间关系"><a href="#3-4-CTX上下文，Channel，Pipeline之间关系" class="headerlink" title="3.4 CTX上下文，Channel，Pipeline之间关系"></a>3.4 CTX上下文，Channel，Pipeline之间关系</h3><ul><li><p>CTX</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313173950859.png" alt="image-20220313173950859"></p></li><li><p>pipeline</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313174040186.png" alt="image-20220313174040186"></p></li><li><p>Pipeline</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313174136871.png" alt="image-20220313174136871"></p></li></ul><p>三者关系图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313174150117.png" alt="image-20220313174150117"></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络模型</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第284场周赛</title>
    <link href="/2022/03/13/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC284%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/13/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC284%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-k-distant-indices-in-an-array/">6031. 找出数组中的所有 K 近邻下标 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findKDistantIndices</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; idxs;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) <br>            <span class="hljs-keyword">if</span> (nums[i] == key) <br>                idxs.<span class="hljs-built_in">push_back</span>(i);<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> idx: idxs) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(i - idx) &lt;= k) &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(i);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/count-artifacts-that-can-be-extracted/">5203. 统计可以提取的工件 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;vec, set&lt;pii&gt; &amp;st)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = vec[<span class="hljs-number">0</span>]; i &lt;= vec[<span class="hljs-number">2</span>]; i++) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = vec[<span class="hljs-number">1</span>]; j &lt;= vec[<span class="hljs-number">3</span>]; j++)<br>                <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pii</span>(i, j))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">digArtifacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; artifacts, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; dig)</span> </span>&#123;<br>        set&lt;pii&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;vec : dig) st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pii</span>(vec[<span class="hljs-number">0</span>], vec[<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;vec : artifacts) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(vec, st)) ans++;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximize-the-topmost-element-after-k-moves/">5227. K 次操作后最大化顶端元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果 nums.length=1，那么如果 k 是偶数，那么栈里存在nums[0]；如果 k 是奇数，那么栈里一定没有任何元素，返回 -1−1。</span><br><span class="hljs-comment">否则，栈顶元素可以是：</span><br><span class="hljs-comment">nums 的前 k−1 个数的最大值；</span><br><span class="hljs-comment">nums 的第 k+1 个数（如果有，此时出栈前 kk 个数即可）；</span><br><span class="hljs-comment">注意，nums 的第 k 个数永远不会出现在栈顶。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumTop</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; k &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; i + <span class="hljs-number">1</span> &lt; k; i ++) &#123;<br>            mx = <span class="hljs-built_in">max</span>(mx, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            mx = <span class="hljs-built_in">max</span>(mx, nums[k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mx;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-weighted-subgraph-with-the-required-paths/">6032. 得到要求路径的最小带权子图 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>&gt; PLLI;<br><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minimumWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, <span class="hljs-keyword">int</span> src1, <span class="hljs-keyword">int</span> src2, <span class="hljs-keyword">int</span> dest)</span> </span>&#123;<br>        vector&lt;PII&gt; grid[n], fgrid[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e: edges) &#123;<br>            grid[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>]);<br>            fgrid[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">dist1</span><span class="hljs-params">(n, <span class="hljs-number">1e15</span>)</span>, <span class="hljs-title">dist2</span><span class="hljs-params">(n, <span class="hljs-number">1e15</span>)</span>, <span class="hljs-title">dist3</span><span class="hljs-params">(n, <span class="hljs-number">1e15</span>)</span></span>;<br><br>        <span class="hljs-built_in">dijkstra</span>(src1, grid, dist1);<br>        <span class="hljs-built_in">dijkstra</span>(src2, grid, dist2);<br>        <span class="hljs-built_in">dijkstra</span>(dest, fgrid, dist3);<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1e15</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            res = <span class="hljs-built_in">min</span>(res, dist1[i] + dist2[i] + dist3[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res &gt; <span class="hljs-number">1e12</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, vector&lt;PII&gt; grid[], vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; &amp;dist)</span> </span>&#123;<br>        priority_queue&lt;PLLI, vector&lt;PLLI&gt;, greater&lt;PLLI&gt;&gt; q;<br>        dist[s] = <span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, s);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cost, node] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (cost &gt; dist[node]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [ne, w]: grid[node]) &#123;<br>                <span class="hljs-keyword">if</span> (cost + w &lt; dist[ne]) &#123;<br>                    dist[ne] = cost + w;<br>                    q.<span class="hljs-built_in">emplace</span>(cost + w, ne);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抢红包：二倍均值法实现均匀分配</title>
    <link href="/2022/03/11/%E7%AE%97%E6%B3%95/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/%E6%8A%A2%E7%BA%A2%E5%8C%85%EF%BC%9A%E4%BA%8C%E5%80%8D%E5%9D%87%E5%80%BC%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9D%87%E5%8C%80%E5%88%86%E9%85%8D/"/>
    <url>/2022/03/11/%E7%AE%97%E6%B3%95/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/%E6%8A%A2%E7%BA%A2%E5%8C%85%EF%BC%9A%E4%BA%8C%E5%80%8D%E5%9D%87%E5%80%BC%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9D%87%E5%8C%80%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>​    今天面蔚来被问到了，当时实现的算法不够均匀，被面试官指出了，上网搜了下，有种二倍均值法可以实现，故在此记录</p><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1 算法介绍"></a>1 算法介绍</h2><p>​    对于钱数<code>money</code>，份数<code>person</code>，每次计算出均值<code>avgAmount = money / person</code>，再将其乘<code>2</code>，得到下一个人可分配红包的范围，进行分配以后，<code>money</code>和<code>person</code>都减少，再进行该操作，最后一个人不用随机，直接取剩余金额即可</p><h2 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2 算法实现"></a>2 算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> money = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 钱数</span><br>        <span class="hljs-keyword">int</span> person = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 份数</span><br>        <span class="hljs-keyword">int</span>[] resultArr = clickReaPacket(money, person);<br>        String s = Arrays.toString(resultArr);<br>        System.out.println(s);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] clickReaPacket(<span class="hljs-keyword">int</span> money, <span class="hljs-keyword">int</span> person) &#123;<br>        <span class="hljs-keyword">int</span>[] amountArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[person];<br>        System.out.printf(<span class="hljs-string">&quot;%s 分钱分给 %s 人\n&quot;</span>, money, person);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; amountArr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">// 注意 money 和 person 两个 int 变量做除法，应该转换其中一个为浮点类型，以保存精度</span><br>            <span class="hljs-keyword">double</span> avgAmount = ((<span class="hljs-keyword">double</span>) money) / person;<br>            <span class="hljs-keyword">double</span> doubleAvfAmount = avgAmount * <span class="hljs-number">2</span>;<br>            person --;<br>            <span class="hljs-keyword">int</span> min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">double</span> max = doubleAvfAmount;<br>            <span class="hljs-keyword">int</span> currentAmount = getRandomBetween(min, max);<br>            amountArr[i] = currentAmount;<br>            money = money - currentAmount;<br>            System.out.printf(<span class="hljs-string">&quot;剩余人数：%s\t抢到：%s \t剩余金额：%s\t本次均值的二倍：%s\t金额随机范围：[%s, %s]\n&quot;</span>, person, currentAmount, money, doubleAvfAmount, min, max);<br>        &#125;<br>        amountArr[amountArr.length - <span class="hljs-number">1</span>] = money;<br>        <span class="hljs-keyword">return</span> amountArr;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandomBetween</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">double</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> newScope = Math.random() * (b - a);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (Math.floor(a + newScope));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/w1nd1/pic-go-pic/raw/master/blog/image-20220311155248809.png" alt="image-20220311155248809"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>场景算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蔚来一面面经</title>
    <link href="/2022/03/11/%E6%9D%82%E7%83%A9/%E8%94%9A%E6%9D%A5%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/03/11/%E6%9D%82%E7%83%A9/%E8%94%9A%E6%9D%A5%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>面试</p><ol><li>自我介绍</li><li>RPC（无语了= =，我更想面试官问第一个项目的）</li><li>http和tcp区别（？确定不是udp吗）</li><li>tcp三次握手，为什么不是两次四次</li><li>为什么要分OSI的7层，TCP的4层，有什么意义吗</li><li>为什么需要DNS？</li><li>设计模式（为什么要，熟悉哪些，设计模式有哪些原则，该原则保证了什么。。）</li><li>java springboot的作用？spring和springboot的区别？</li><li>spring如何加载配置文件的</li><li>spring bean的生命周期（还问了个为什么要了解这个？？？我内心：八股上说的）</li><li>线程，为什么要引入，有啥作用</li><li>mysql事务隔离级别，解决了什么问题</li></ol><p>笔试</p><ol><li>抢红包，要求均匀</li></ol><p>发问</p><ol><li>啥时候下一次通知</li><li>可以转正吗</li><li>对我有啥建议</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂烩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础数据类型</title>
    <link href="/2022/03/10/Redis/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/03/10/Redis/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-SDS"><a href="#1-SDS" class="headerlink" title="1 SDS"></a>1 SDS</h2><h3 id="1-1-结构体"><a href="#1-1-结构体" class="headerlink" title="1.1 结构体"></a>1.1 结构体</h3><p>​    以下结构体表示一个SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">// 记录buf数组中已使用的字节数量</span><br>    <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-comment">// 记录buf数组中未使用字节的数量</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;<br>    <span class="hljs-comment">// 字节数组，用于保存字符串</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-结构图"><a href="#1-2-结构图" class="headerlink" title="1.2 结构图"></a>1.2 结构图</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310144050789.png" alt="image-20220310144050789"></p><h3 id="1-3与c字符串的区别"><a href="#1-3与c字符串的区别" class="headerlink" title="1.3与c字符串的区别"></a>1.3与c字符串的区别</h3><ol><li><p><strong>可以常数复杂度获取字符串长度</strong></p><p> ​    c中获取字符串长度的方式是通过线性遍历，而SDS由于存储已使用的字节数量，可以通过常数复杂度获取</p></li><li><p><strong>杜绝缓冲区溢出</strong></p><p> ​    例如，c的字符串在使用<code>strcat</code>为原字符串添加字符串时，如果未分配有效空间，很可能造成缓冲区溢出。而SDS的API会检查空间是否满足修改所需的要求。</p></li><li><p><strong>减少修改字符串时带来的内存重分配次数</strong></p><p> ​    c中字符串在执行拼接操作时，如果空间不足，需要通过内存重分配来扩张空间大小，如果忘了则会发生<code>缓冲区溢出</code></p><p> ​    如果执行截断操作，程序就要释放不再使用的空间，如果忘了则会发生<code>内存泄漏</code></p><p> ​    以上两种操作，如果频繁地发生，是会对性能造成影响的。</p><p> ​    由此，SDS通过空间预分配和惰性空间释放两种策略来进行优化</p><ul><li><p><strong>空间预分配</strong></p><p>  ​    当SDS在分配空间时，如果SDS长度小于<code>1M</code>，则会分配原来长度len同样大小的未使用空间（还得+1，空字符）；如果SDS大于<code>1M</code>，则会分配1M未使用空间+1。这样使得内存分配次数从N次降低到最多N次</p></li><li><p><strong>惰性空间释放</strong></p><p>  ​    当SDS在释放空间时，不会进行空间回收，而是使用<code>free</code>属性将字节数量记录下来，方便将来使用</p></li></ul></li><li><p><strong>二进制安全</strong></p><p> ​    由于c中不能包含空字符（会被当成结尾），限制了不能保存像图片，音频，视频这样的二进制数据。但SDS由于通过len来判断字符串是否结束，从而不会发生这种问题。</p></li><li><p><strong>兼容部分C字符串函数</strong></p></li></ol><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2 链表"></a>2 链表</h2><h3 id="2-1-结构体"><a href="#2-1-结构体" class="headerlink" title="2.1 结构体"></a>2.1 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">// 后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">// 节点的值</span><br>    <span class="hljs-keyword">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">链表</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-comment">// 表头结点</span><br>    listNode *head;<br>    <span class="hljs-comment">// 表尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">// 链表所包含的节点数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;<br>    <span class="hljs-comment">// 节点值复制函数</span><br>    <span class="hljs-keyword">void</span> *(*dup) (<span class="hljs-keyword">void</span> *ptr);<br>    <span class="hljs-comment">// 节点值释放函数</span><br>    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">free</span>) (<span class="hljs-keyword">void</span> *ptr);<br>    <span class="hljs-comment">// 节点值对比函数</span><br>    <span class="hljs-keyword">int</span> (*match) (<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *key);<br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-结构图"><a href="#2-2-结构图" class="headerlink" title="2.2 结构图"></a>2.2 结构图</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310144008115.png" alt="image-20220310144008115"></p><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3 字典"></a>3 字典</h2><p>​    字典底层使用哈希表，<strong>一个哈希表可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对</strong></p><h3 id="3-1-结构体"><a href="#3-1-结构体" class="headerlink" title="3.1 结构体"></a>3.1 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">哈希表节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-keyword">void</span> *key; <span class="hljs-comment">// 键</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span> <span class="hljs-comment">// 值，可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数</span><br>        <span class="hljs-keyword">void</span> *val; <br>        uint64_tu64;<br>        int64_ts64;<br>    &#125; v;<br>    <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">哈希表</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">// 总是等于size-1</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;<br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">字典</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    <span class="hljs-comment">// 类型特定函数</span><br>    dictType *type;<br>    <span class="hljs-comment">// 私有数据</span><br>    <span class="hljs-keyword">void</span> *privdata;<br>    <span class="hljs-comment">// 哈希表</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// rehash索引</span><br>    <span class="hljs-comment">// 当rehash不在进行时，值为-1</span><br>    <span class="hljs-keyword">int</span> trehashidx;<br>&#125; dict;<br></code></pre></td></tr></table></figure><h3 id="3-2-结构图"><a href="#3-2-结构图" class="headerlink" title="3.2 结构图"></a>3.2 结构图</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310144937284.png" alt="image-20220310144937284"></p><h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4 跳跃表"></a>4 跳跃表</h2><p>​    一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>​    支持平均O（logN），最坏O（N）复杂度的节点查找</p><h3 id="4-1-结构体"><a href="#4-1-结构体" class="headerlink" title="4.1 结构体"></a>4.1 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> span;<br>    &#125; level[];<br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-keyword">double</span> score;<br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;<br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-keyword">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><h3 id="4-2-结构图"><a href="#4-2-结构图" class="headerlink" title="4.2 结构图"></a>4.2 结构图</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310153930856.png" alt="image-20220310153930856"></p><h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5 整数集合"></a>5 整数集合</h2><p>​    用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><h3 id="5-1-结构体"><a href="#5-1-结构体" class="headerlink" title="5.1 结构体"></a>5.1 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-keyword">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-keyword">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-keyword">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><h3 id="5-2-结构图"><a href="#5-2-结构图" class="headerlink" title="5.2 结构图"></a>5.2 结构图</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310154836193.png" alt="image-20220310154836193"></p><h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6 压缩列表"></a>6 压缩列表</h2><h3 id="6-1-构成"><a href="#6-1-构成" class="headerlink" title="6.1 构成"></a>6.1 构成</h3><ul><li>列表</li></ul><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310155600058.png" alt="image-20220310155600058"></p><ul><li><p>节点</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310155635947.png" alt="image-20220310155635947"></p><ol><li><p>previous_entry_length</p><p> ​    记录了压缩列表中前一个节点的长度。</p></li><li><p>encoding</p><p> ​    记录了节点的content属性所保存数据的类型以及长度</p></li><li><p>content</p><p> ​    保存节点的值，节点值可以是一个字节数组或者整数</p></li></ol></li></ul><h2 id="7-对象"><a href="#7-对象" class="headerlink" title="7 对象"></a>7 对象</h2><p>​    Redis并没有直接使用上述数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。</p><h3 id="7-1-结构体"><a href="#7-1-结构体" class="headerlink" title="7.1 结构体"></a>7.1 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码</span><br>    <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 指向底层实现数据结构的指针</span><br>    <span class="hljs-keyword">void</span> *ptr;<br>    <span class="hljs-comment">//</span><br>    ...<br>&#125; robj;<br></code></pre></td></tr></table></figure><h3 id="7-2-字符串对象"><a href="#7-2-字符串对象" class="headerlink" title="7.2 字符串对象"></a>7.2 字符串对象</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161453668.png" alt="image-20220310161453668"></p><h3 id="7-3-列表对象"><a href="#7-3-列表对象" class="headerlink" title="7.3 列表对象"></a>7.3 列表对象</h3><p>​    列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code>。</p><ol><li><p>ziplist</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161611368.png" alt="image-20220310161611368"></p></li><li><p>linkedlist</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161638333.png" alt="image-20220310161638333"></p></li></ol><h4 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h4><p>​    比如twitter的关注列表、粉丝列表等都可以用Redis的list结构来实现，再比如有的应用使用Redis的list类型实现一个简单的轻量级消息队列，生产者push，消费者pop/bpop。</p><h3 id="7-4-哈希对象"><a href="#7-4-哈希对象" class="headerlink" title="7.4 哈希对象"></a>7.4 哈希对象</h3><p>​    哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p><ol><li><p>ziplist</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161753805.png" alt="image-20220310161753805"></p></li><li><p>hashtable</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161821186.png" alt="image-20220310161821186"></p></li></ol><h4 id="运用场景-1"><a href="#运用场景-1" class="headerlink" title="运用场景"></a>运用场景</h4><p>​    假设有多个用户及对应的用户信息，可以用来存储以用户ID为key，将用户信息序列化为比如json格式做为value进行保存。</p><h3 id="7-5-集合对象"><a href="#7-5-集合对象" class="headerlink" title="7.5 集合对象"></a>7.5 集合对象</h3><p>​    集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。</p><ol><li><p>intest</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161919045.png" alt="image-20220310161919045"></p></li><li><p>hashtabl</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310161933608.png" alt="image-20220310161933608"></p></li></ol><h4 id="运用场景-2"><a href="#运用场景-2" class="headerlink" title="运用场景"></a>运用场景</h4><p>​    在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p><h3 id="7-6-有序集合对象"><a href="#7-6-有序集合对象" class="headerlink" title="7.6 有序集合对象"></a>7.6 有序集合对象</h3><p>​    有序集合的编码可以是ziplist或者skiplist。</p><ol><li><p>ziplist</p><p> <img src="C:/Users/86139/AppData/Roaming/Typora/typora-user-images/image-20220310162034753.png" alt="image-20220310162034753"></p></li><li><p>skiplist</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310162055879.png" alt="image-20220310162055879"></p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220310162109007.png" alt="image-20220310162109007"></p></li></ol><h4 id="运用场景-3"><a href="#运用场景-3" class="headerlink" title="运用场景"></a>运用场景</h4><p>​    比如用户的积分排行榜需求就可以通过有序集合实现。也可以通过Sorted Set实现有优先级或按权重的队列。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK8新特性</title>
    <link href="/2022/03/09/Java/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/03/09/Java/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1 Lambda表达式"></a>1 Lambda表达式</h2><p>​    Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>以下是lambda表达式的重要特征:</p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk8;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LambdaTest test = <span class="hljs-keyword">new</span> LambdaTest();<br><br>        <span class="hljs-comment">// 类型声明</span><br>        MathOperation addition = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt;  a + b;<br>        System.out.println(<span class="hljs-string">&quot;10 + 5 = &quot;</span> + test.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, addition));<br><br>        <span class="hljs-comment">// 不用类型声明</span><br>        MathOperation subtraction = (a, b) -&gt; a - b;<br>        System.out.println(<span class="hljs-string">&quot;10 - 5 = &quot;</span> + test.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, subtraction));<br><br>        <span class="hljs-comment">// 加大括号</span><br>        MathOperation multiplication = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123; <span class="hljs-keyword">return</span> a * b; &#125;;<br>        System.out.println(<span class="hljs-string">&quot;10 * 5 = &quot;</span> + test.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, multiplication));<br><br>        <span class="hljs-comment">// 没有大括号及返回语句</span><br>        MathOperation division = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a / b;<br>        System.out.println(<span class="hljs-string">&quot;10 / 5 = &quot;</span> + test.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, division));<br><br>        <span class="hljs-comment">// 不用括号</span><br>        GreetingService greetingService = message -&gt; System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + message);<br>        <span class="hljs-comment">// 用括号</span><br>        GreetingService greetingService1 = (message) -&gt; System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + message);<br><br>        greetingService.sayMessage(<span class="hljs-string">&quot;world&quot;</span>);<br>        greetingService1.sayMessage(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MathOperation</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, MathOperation mathOperation)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mathOperation.operation(a, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220309203447439.png" alt="image-20220309203447439"></p><h2 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2 方法引用"></a>2 方法引用</h2><p>​    方法引用通过方法的名字来指向一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk8;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 构造器引用</span><br>        <span class="hljs-keyword">final</span> Car car = Car.create( Car::<span class="hljs-keyword">new</span> );<br><br>        <span class="hljs-keyword">final</span> List&lt;Car&gt; cars = Arrays.asList(car);<br>        <span class="hljs-comment">// 静态方法引用</span><br>        cars.forEach(Car::collide);<br>        <span class="hljs-comment">// 特定类的任意对象的方法引用</span><br>        cars.forEach(Car::repair);<br>        <span class="hljs-comment">// 特定对象的方法引用</span><br>        <span class="hljs-keyword">final</span> Car police = Car.create(Car::<span class="hljs-keyword">new</span>);<br>        cars.forEach(police::follow);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello car&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Supplier&lt;Car&gt; supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collide</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car car)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Collied &quot;</span> + car.toString());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">follow</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car another)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Following the &quot;</span> + another.toString());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">repair</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Repaired &quot;</span> + <span class="hljs-keyword">this</span>.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220309204036736.png" alt="image-20220309204036736"></p><h2 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3 函数式接口"></a>3 函数式接口</h2><p>​    函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk8;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Source;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionInterfaceTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>        <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br>        System.out.println(<span class="hljs-string">&quot;输出所有数据：&quot;</span>);<br><br>        <span class="hljs-comment">// 传递参数</span><br>        eval(list, n-&gt;<span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate1 = n -&gt; n % 2 == 0</span><br>        <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的test方法</span><br>        <span class="hljs-comment">// 如果 n 大于 3 test方法返回true</span><br>        System.out.println(<span class="hljs-string">&quot;输出所有偶数：&quot;</span>);<br>        eval(list, n-&gt; n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3;</span><br>        <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的test方法</span><br>        <span class="hljs-comment">// 如果 n 大于 3 test 方法返回true</span><br>        System.out.println(<span class="hljs-string">&quot;输出大于3的所有数字：&quot;</span>);<br>        eval(list, n-&gt; n &gt; <span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Integer n : list) &#123;<br>            <span class="hljs-keyword">if</span> (predicate.test(n)) &#123;<br>                System.out.print(n + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220309204453398.png" alt="image-20220309204453398"></p><h2 id="4-默认方法"><a href="#4-默认方法" class="headerlink" title="4 默认方法"></a>4 默认方法</h2><p>​    默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk8;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Vehicle vehicle = <span class="hljs-keyword">new</span> Car();<br>        vehicle.print();<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是一辆车&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">blowHorn</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;按喇叭！！！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FourWheeler</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是一辆四轮车！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span>, <span class="hljs-title">FourWheeler</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            Vehicle.<span class="hljs-keyword">super</span>.print();<br>            FourWheeler.<span class="hljs-keyword">super</span>.print();<br>            Vehicle.blowHorn();<br>            System.out.println(<span class="hljs-string">&quot;我是一辆汽车！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220309204600796.png" alt="image-20220309204600796"></p><h2 id="5-Stream"><a href="#5-Stream" class="headerlink" title="5 Stream"></a>5 Stream</h2><p>​    Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk8;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.IntSummaryStatistics;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>        <span class="hljs-keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();<br>        System.out.println(<span class="hljs-string">&quot;空字符串数量为：&quot;</span> + count);<br><br>        count = strings.stream().filter(string -&gt; string.length() == <span class="hljs-number">3</span>).count();<br>        System.out.println(<span class="hljs-string">&quot;字符串长度为3的数量为：&quot;</span> + count);<br><br>        List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;筛选后的列表：&quot;</span> + filtered);<br><br>        String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;合并字符串：&quot;</span> + mergedString);<br><br>        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>        List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;Squares List：&quot;</span> + squaresList);<br><br>        List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>,<span class="hljs-number">17</span>,<span class="hljs-number">8</span>,<span class="hljs-number">19</span>);<br>        IntSummaryStatistics statistics = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();<br>        System.out.println(statistics);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220309204648855.png" alt="image-20220309204648855"></p><h2 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6 Optional"></a>6 Optional</h2><p>​    Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>​    Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>​    Optional 类的引入很好的解决空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk8;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        OptionalTest optionalTest = <span class="hljs-keyword">new</span> OptionalTest();<br>        Integer value1 = <span class="hljs-keyword">null</span>;<br>        Integer value2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// Optional.ofNullable - 允许传递为 null 参数</span><br>        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);<br>        <span class="hljs-comment">// Optional.of - 允许传递的参数是null，抛出异常NullPointerException</span><br>        Optional&lt;Integer&gt; b = Optional.of(value2);<br>        System.out.println(optionalTest.sum(a, b));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">sum</span><span class="hljs-params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span> </span>&#123;<br>        <span class="hljs-comment">// Optional.isPresent - 判断值是否存在</span><br>        System.out.println(<span class="hljs-string">&quot;第一个参数值存在：&quot;</span> + a.isPresent());<br>        System.out.println(<span class="hljs-string">&quot;第二个参数值存在：&quot;</span> + b.isPresent());<br><br>        <span class="hljs-comment">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br>        Integer value1 = a.orElse(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// Optional.get - 获取值，值需要存在</span><br>        Integer value2 = b.get();<br>        <span class="hljs-keyword">return</span> value1 + value2;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220309204752631.png" alt="image-20220309204752631"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/java/java8-new-features.html">Java 8 新特性 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty入门（一）</title>
    <link href="/2022/03/08/netty/netty%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/03/08/netty/netty%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Netty是什么"><a href="#1-Netty是什么" class="headerlink" title="1 Netty是什么"></a>1 Netty是什么</h2><p>​    Netty是一个<strong>异步</strong>的，<strong>基于事件驱动</strong>的网络应用框架，用于快速开发高性能，高可靠的网络I/O程序。并且Netty主要针对TCP协议下，面对Client端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。</p><p>​    Netty本质上是一个NIO框架，使用于服务器通讯相关的多种应用场景。</p><p><strong>思考，NIO是一个同步非阻塞模型，而又说Netty是异步的，这不是会矛盾吗</strong></p><p>​    首先，我们要知道，这两者是没有关系的，Netty所说的异步是指异步事件驱动，用户使用Channel进行IO操作，会立即返回。但是IO操作的任务是提交给Netty的NIO底层去进行处理的。打个比方，你给客服打电话请求注销手机卡，但客服可能不会马上帮你注销，会给你一个回复说注销后会发短信通知你（回调函数），接着，这个请求就交由底层相关注销手机卡的人员进行处理，处理完后再告诉客服，客服再发短信。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220308145826539.png" alt="image-20220308145826539"></p><h2 id="2-IO模型"><a href="#2-IO模型" class="headerlink" title="2 IO模型"></a>2 IO模型</h2><p>​    IO模型的简单理解：就是用什么样的通道进行数据的发送和接收</p><p>​    Java支持3种网络编程模型I/O模式：BIO，NIO，AIO</p><ol><li><p>BIO：<strong>同步阻塞</strong>，服务实现模式为一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成性能开销。</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220308150917448.png" alt="image-20220308150917448"></p></li><li><p>NIO：<strong>同步非阻塞</strong>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理。</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220308154606048.png" alt="image-20220308154606048"></p></li><li><p>AIO：<strong>异步非阻塞</strong>，AlO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p></li></ol><p><strong>BIO，NIO，AIO适用场景分析</strong></p><ol><li>BIO方式适用于连接数目比较小且固定的架构</li><li>NIO方式适用于连接数目多且连接比较短的架构，比如聊天服务器，弹幕系统，服务器间通信等</li><li>AIO方式适用于连接数目多且连接比较长的服务，比如相册服务器</li></ol><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p><strong>BIO编程简单流程</strong></p><ol><li><p>服务器端启动一个serverSocket</p></li><li><p>客户端启动socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</p></li><li><p>客户端发出请求后,先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</p></li><li><p>如果有响应,客户端线程会等待请求结束后，在继续执行</p></li></ol><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>​    NIO有三大核心部分:Channel(通道)，Buffer(缓冲区)，Selector(选择器)</p><p><strong>Channel，Buffer，Selector之间的关系</strong></p><ol><li>每个channel都会对应一个Bufer</li><li>Selectot 对对应一个线程，一个线程对应多个channel(连接)</li><li>该图反应了有三个channel注册到该selector l程序</li><li>程序切换到哪个channel是有事件决定的, Event 就是一个重要的概念5)</li><li>Selector会根据不同的事件,在各个通道上切换</li><li>Buffer就是一个内存块，底层是有一个数组</li><li>数据的读取写入是通过Buffer,这个和BiO, BIO中要么是输入流，或者是输出流,不能双向，但是NIO的Buffer是可以读也可以写,需要flip方法切换</li><li>channel是双向的,可以返回底层操作系统的情况,比如Linux，底层的操作系统通道就是双向的</li></ol><h3 id="BIO-VS-NIO"><a href="#BIO-VS-NIO" class="headerlink" title="BIO VS NIO"></a>BIO VS NIO</h3><ol><li>BIO以流的方式处理数据,而NIO以块的方式处理数据,块,I/o的效率比流I/o高很多</li></ol><ol start="2"><li><p>BIO是阻塞的，NIO则是非阻塞的</p></li><li><p>BlO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<br> Selector(选择器)用于监听多个通道的事件（比如:连接请求，数据到达等），因此使用<strong>单个线程就可以监听多个客户端</strong>通道    </p></li></ol><h2 id="3-NIO基本介绍"><a href="#3-NIO基本介绍" class="headerlink" title="3 NIO基本介绍"></a>3 NIO基本介绍</h2><h3 id="3-1-Buffer"><a href="#3-1-Buffer" class="headerlink" title="3.1 Buffer"></a>3.1 Buffer</h3><p>​    缓冲区本质是一个可以读写数据的内存块，可以理解是一个<strong>容器对象</strong>。</p><ol><li><p>在NIO中，Buffer是一个顶层父类，它是一个抽象类</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220311162653121.png" alt="image-20220311162653121"></p></li><li><p>Buffer类定义了所有的缓冲区都具有的四个属性提供关于其所包含的数据元素的信息</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220311162753122.png" alt="image-20220311162753122"></p></li></ol><h3 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h3><p><strong>基本介绍</strong></p><p>1）通道可以同时进行读写</p><p>2）通道可以实现异步读写数据</p><p>3）通道可以从缓冲中读数据，也可以写数据到缓冲</p><p><strong>关于Buffer和 Channel的注意事项和细节</strong></p><ol><li>ByteBuffer支持类型化的put和 get, put放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有<code>BufferUnderflowException</code>异常。</li><li>可以将一个普通<code>Buffer</code>转成只读<code>Buffer</code></li><li>NIO还提供了<code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存〉中进行修改，而如何同步到文件由NIO来完成</li><li>前面我们讲的读写操作，都是通过一个<code>Buffer</code>完成的，NIO还支持通过多个Buffer(即 Buffer数组)完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code></li></ol><h3 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h3><p><strong>基本介绍</strong></p><ol><li>Java的 NIO，用非阻塞的I0方式。可以用一个线程，处理多个的客户端连接，就会使用到<code>selector</code>(选择器)</li><li><code>Selector</code>能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个<code>Selector</code>)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在连接真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ol><h2 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4 零拷贝"></a>4 零拷贝</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><p>​    零拷贝是指没有CPU拷贝的技术。</p><h3 id="4-2-传统IO数据读写"><a href="#4-2-传统IO数据读写" class="headerlink" title="4.2 传统IO数据读写"></a>4.2 传统IO数据读写</h3><p>​    在没有DMA技术时，数据的传输过程需要CPU的全程参与，这是很消耗性能的</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220312202014206.png" alt="image-20220312202014206"></p><p>​    什么是DMA（直接内存访问）技术呢？<strong>在进⾏</strong> <strong>I/O</strong> <strong>设备和内存的数据传输的时候，数据搬运的⼯作全部交给DMA控制器，⽽CPU不再参与任何与数据搬运相关的事情，这样CPU就可以去处理别的事务</strong>。</p><p>​    加入该技术，就有了下图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220312202157914.png" alt="image-20220312202157914"></p><p>​        继续分析该读写方式有多糟糕</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220312202644179.png" alt="image-20220312202644179"></p><p>​    从上图可以看出，期间发生了<strong>4次用户态与内核态的上下文切换</strong>，以及<strong>4次数据拷贝</strong></p><p>​    由此<code>read</code>和<code>write</code>是系统调用，每次都会发生2次上下文切换</p><p>​    而4次数据拷贝是</p><ul><li>第⼀次拷⻉，把<strong>磁盘上的数据拷⻉到操作系统内核的缓冲区</strong>⾥，这个拷⻉的过程是通过 DMA 搬运的</li><li>第⼆次拷⻉，把<strong>内核缓冲区的数据拷⻉到⽤户的缓冲区</strong>⾥，于是我们应⽤程序就可以使⽤这部分数据了，这个拷⻉到过程是由 CPU 完成的。</li><li>第三次拷⻉，把刚才拷⻉到<strong>⽤户的缓冲区⾥的数据，再拷⻉到内核的 socket 的缓冲区</strong>⾥，这个过程依然还是由 CPU 搬运的。</li><li>第四次拷⻉，把<strong>内核的 socket 缓冲区⾥的数据，拷⻉到⽹卡的缓冲区</strong>⾥，这个过程⼜是由 DMA 搬运的。</li></ul><h3 id="4-3-mmap优化"><a href="#4-3-mmap优化" class="headerlink" title="4.3 mmap优化"></a>4.3 mmap优化</h3><p>​    mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据<strong>映射</strong>到⽤户空间，这样，操作系统内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220312204213881.png" alt="image-20220312204213881"></p><p>​    这里当用户态调用<code>write</code>时，操作系统会将内核缓冲区的数据拷贝到socket缓冲区中，这发生在内核态，从而减少一次数据拷贝的过程</p><p>​    但这仍然需要<strong>4次上下文切换</strong>，<strong>3次数据拷贝</strong></p><h3 id="4-4-sendFile优化"><a href="#4-4-sendFile优化" class="headerlink" title="4.4 sendFile优化"></a>4.4 sendFile优化</h3><p>​    在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 <code>sendfile() </code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数说明：</span><br><span class="hljs-comment">1. 目的端文件描述符</span><br><span class="hljs-comment">2. 源端文件描述符</span><br><span class="hljs-comment">3. 源端偏移量</span><br><span class="hljs-comment">4. 复制数据的长度</span><br><span class="hljs-comment">@return 实际复制数据的长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-keyword">int</span> out_fd, <span class="hljs-keyword">int</span> in_fd, <span class="hljs-keyword">off_t</span> *offset, <span class="hljs-keyword">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>​    该系统调用的好处有二：</p><ul><li>可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。</li><li>可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。</li></ul><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220312205127301.png" alt="image-20220312205127301"></p><p>​    但这还不是真正零拷贝，可以发现图中②还有个CPU拷贝</p><p>​    只有当网卡支持<strong>SG-DMA</strong>技术时，才可以实现真正的零拷贝</p><p>​    使用SG-DMA技术如下图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220312205336373.png" alt="image-20220312205336373"></p><ul><li>第⼀步，通过 DMA 将磁盘上的数据拷⻉到内核缓冲区⾥；</li><li>第⼆步，缓冲区描述符和数据⻓度传到 socket 缓冲区，这样⽹卡的 SG-DMA 控制器就可以<strong>直接将内核缓存中的数据拷⻉到⽹卡的缓冲区</strong>⾥，此过程不需要将数据从操作系统内核缓冲区拷⻉到 socket缓冲区中，这样就减少了⼀次数据拷⻉；</li></ul><h2 id="5-线程模型"><a href="#5-线程模型" class="headerlink" title="5 线程模型"></a>5 线程模型</h2><h3 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1 基本介绍"></a>5.1 基本介绍</h3><p>​    从不同角度来看，对操作系统来说，线程模型往往指的是用户线程和内核线程的对应关系。而在本文中，指的是线程/进程处理连接请求的一种模型。</p><p>​    前文我们知道，当一个线程要处理很多请求时，使用<code>read</code>不断轮询判断是否有数据是十分低效的，而由此衍生出的<code>IO多路复用</code>就是解决该问题的方案，它会用一个系统调用函数来监听所有关心的连接，也就是可以在一个监控线程里面监控很多连接。它的检测方法如下：</p><ul><li>如果没有事件发⽣，线程只需阻塞在这个系统调⽤，⽽⽆需像前⾯的线程池⽅案那样轮训调⽤<code>read</code>操作来判断是否有数据。</li><li>如果有事件发⽣，内核会返回产⽣了事件的连接，线程就会从阻塞状态返回，然后在⽤户态中再处理这些连接对应的业务即可。</li></ul><p>​    但由于传统的IO多路复用编写程序十分繁琐，开发效率不高，由此衍生除了<code>Reactor</code>模式。</p><h3 id="5-2-传统阻塞I-O服务模型"><a href="#5-2-传统阻塞I-O服务模型" class="headerlink" title="5.2 传统阻塞I/O服务模型"></a>5.2 传统阻塞I/O服务模型</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313094636075.png" alt="image-20220313094636075"></p><p>​    可以看出来，这就是种阻塞IO，每个连接都需要独立的线程去进行处理，当并发数很大时，就会创建大量线程，占用很大系统资源。而且当连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在<code>read</code>操作，造成线程资源浪费。</p><h3 id="5-3-Reactor模式"><a href="#5-3-Reactor模式" class="headerlink" title="5.3 Reactor模式"></a>5.3 Reactor模式</h3><p>​    <code>Reactor</code>模式指的是<strong>对事件反应</strong>，也就是<strong>来了一个事件，Reactor就有相应的反应/响应</strong>。即即 <strong>I/O</strong> <strong>多路复⽤监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程/线程</strong>。</p><p><code>Reactor</code>模式主要由<strong>Reactor</strong>和<strong>处理资源池</strong>这两个核⼼部分组成，它俩负责的事情如下：</p><ul><li><p><code>Reactor</code>负责监听和分发事件，事件类型包含连接事件、读写事件；</p></li><li><p>处理资源池负责处理事件，如<code>read</code>-&gt; 业务逻辑 -&gt;<code>send</code>；</p></li></ul><p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p><ul><li><p>Reactor的数量可以只有⼀个，也可以有多个；</p></li><li><p>处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程    </p></li></ul><p>由此，产生了四种方案：</p><ul><li><p>单<code>Reactor</code>单进程 / 线程；</p></li><li><p>单<code>Reactor</code>多进程 / 线程；</p></li><li><p>多<code>Reactor</code>单进程 / 线程；</p></li><li><p>多 <code>Reactor</code>多进程 / 线程</p></li></ul><p>​    由于，多<code>Reactor</code>单进程 / 线程实现⽅案相⽐单<code>Reactor</code>单进程 / 线程⽅案，不仅复杂⽽且也没有性能优势，因此实际中并没有应⽤。</p><h4 id="5-3-1-单Reactor单进程-线程"><a href="#5-3-1-单Reactor单进程-线程" class="headerlink" title="5.3.1 单Reactor单进程/线程"></a>5.3.1 单Reactor单进程/线程</h4><p>​    下面介绍单进程的情况，在c实现中，一般都是这种，因为 C 语编写完的程序，运⾏后就是⼀个独⽴的进程，不需要在进程中再创建线程。而Java 程序是跑在 Java 虚拟机这个进程上⾯的，虚拟机中有很多线程，我们写的 Java 程序只是其中的⼀个线程⽽已。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313100553600.png" alt="image-20220313100553600"></p><p>可以看到进程⾥有 <strong>Reactor</strong>、<strong>Acceptor</strong>、<strong>Handler</strong>这三个对象：</p><ul><li><p>Reactor 对象的作⽤是监听和分发事件；</p></li><li><p>Acceptor 对象的作⽤是获取连接；</p></li><li><p>Handler 对象的作⽤是处理业务；</p></li></ul><p>​    对象⾥的 <code>select</code>、<code>accept</code>、<code>read</code>、<code>send</code> 是系统调⽤函数，<code>dispatch </code>和 「业务处理」是需要完成的操作，其中 <code>dispatch</code>是分发事件操作。</p><p>流程</p><ul><li><code>Reactor</code> 对象通过 <code>select</code> （IO 多路复⽤接⼝） 监听事件，收到事件后通过 <code>dispatch</code>进⾏分发，具体分发给 <code>Acceptor </code>对象还是 <code>Handler</code>对象，还要看收到的事件类型；</li><li>如果是连接建⽴的事件，则交由 <code>Acceptor</code> 对象进⾏处理，<code>Acceptor </code>对象会通过 <code>accept </code>⽅法 获取连接，并创建⼀个<code>Handler</code>对象来处理后续的响应事件；</li><li>如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；</li><li><code>Handler</code>对象通过 <code>read</code>-&gt; 业务处理 -&gt; <code>send </code>的流程来完成完整的业务流程。</li></ul><p><strong>优缺点</strong></p><p>优点：全部⼯作都在同⼀个进程内完成，所以实现起来⽐较简单，不需要考虑进程间通信，也不⽤担⼼多进程竞争。</p><p>缺点：</p><ul><li>第⼀个缺点，因为只有⼀个进程，<strong>⽆法充分利⽤ 多核</strong> <strong>CPU</strong> <strong>的性能</strong>；</li><li>第⼆个缺点，Handler 对象在业务处理时，整个进程是⽆法处理其他连接的事件的，<strong>如果业务处理耗</strong></li></ul><p>​    所以单 Reactor 单进程的⽅案<strong>不适⽤计算机密集型的场景，只适⽤于业务处理⾮常快速的场景</strong></p><h4 id="5-3-2-单Reactor多线程-进程"><a href="#5-3-2-单Reactor多线程-进程" class="headerlink" title="5.3.2 单Reactor多线程/进程"></a>5.3.2 单Reactor多线程/进程</h4><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313101836852.png" alt="image-20220313101836852"></p><p>详细说⼀下这个⽅案：</p><ul><li><code>Reactor</code> 对象通过<code>select</code>（IO 多路复⽤接⼝） 监听事件，收到事件后通过<code>dispatch</code>进⾏分发，具体分发给<code>Acceptor</code>对象还是 <code>Handler </code>对象，还要看收到的事件类型；</li><li>如果是连接建⽴的事件，则交由 <code>Acceptor </code>对象进⾏处理，<code>Acceptor</code> 对象会通过 <code>accept</code> ⽅法 获取连接，并创建⼀个 <code>Handler</code> 对象来处理后续的响应事件；</li><li>如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；</li></ul><p>上⾯的三个步骤和单 <code>Reactor</code> 单线程⽅案是⼀样的，接下来的步骤就开始不⼀样了：</p><ul><li><p><code>Handler</code> 对象不再负责业务处理，<strong>只负责数据的接收和发送</strong>，Handler 对象通过 <code>read</code> 读取到数据后，会将数据发给<strong>⼦线程⾥的 Processor 对象</strong>进⾏业务处理；</p></li><li><p>⼦线程⾥的 <code>Processor</code> 对象就进⾏业务处理，处理完后，将结果发给主线程中的 <code>Handler</code> 对象，接着由 <code>Handler</code> 通过 <code>send</code> ⽅法将响应结果发送给 <code>client</code>； </p></li></ul><p><strong>优缺点</strong></p><p><strong>优点</strong></p><p>​    能够充分利用多核CPU的处理能力</p><p><strong>缺点</strong></p><ul><li>涉及共享数据的竞争</li><li>因为⼀个Reactor对象承担所有事件的监听和响应，⽽且只在主线程中运⾏，在⾯对瞬间⾼并发的场景时，容易成为性能的瓶颈的地⽅。 </li></ul><h4 id="5-3-3-多Reactor多进程-线程"><a href="#5-3-3-多Reactor多进程-线程" class="headerlink" title="5.3.3 多Reactor多进程/线程"></a>5.3.3 多Reactor多进程/线程</h4><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220313102730186.png" alt="image-20220313102730186"></p><p>⽅案详细说明如下：</p><ul><li><p>主线程中的 <code>MainReactor</code>对象通过 <code>select</code>监控连接建⽴事件，收到事件后通过 <code>Acceptor</code>对象中的<code>accept</code>获取连接，将新的连接分配给某个⼦线程；</p></li><li><p>⼦线程中的 <code>SubReactor</code>对象将 <code>MainReactor</code>对象分配的连接加⼊ <code>select</code>继续进⾏监听，并创建⼀个<code>Handler</code> ⽤于处理连接的响应事件。</p></li><li><p>如果有新的事件发⽣时，<code>SubReactor</code>对象会调⽤当前连接对应的 <code>Handler </code>对象来进⾏响应。</p></li><li><p><code>Handler </code>对象通过 <code>read </code>-&gt; 业务处理 -&gt;<code>send</code>的流程来完成完整的业务流程。</p></li></ul><p>多 <code>Reactor</code>多线程的⽅案虽然看起来复杂的，但是实际实现时⽐单<code>Reactor</code>多线程的⽅案要简单的多，原因如下：</p><ul><li><p>主线程和⼦线程分⼯明确，主线程只负责接收新连接，⼦线程负责完成后续的业务处理。</p></li><li><p>主线程和⼦线程的交互很简单，主线程只需要把新连接传给⼦线程，⼦线程⽆须返回数据，直接就可以在⼦线程将处理结果发送给客户端。</p></li></ul><p><code>Netty</code>和<code>Memcache</code>都采用了多Reactor多线程的方案</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>生活案例理解</p><blockquote><ol><li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</li><li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 Reactor 多线程，多个前台接待员，多个服务生</li></ol></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.nowcoder.net/n/47ea22f3650043f8ac3ce1e7fd3ad61f">【网络编程】Netty采用的NIO为什么是同步非阻塞的？_牛客博客 (nowcoder.net)</a></p><p>《图解系统》——小林coding</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络模型</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理在RPC中的运用</title>
    <link href="/2022/03/06/%E6%A1%86%E6%9E%B6/RPC/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <url>/2022/03/06/%E6%A1%86%E6%9E%B6/RPC/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>​    动态代理在 RPC 框架的实现中起到了至关重要的作用，它可以帮助用户屏蔽 RPC 调用时底层网络通信、服务发现、负载均衡等具体细节。</p><h2 id="1-动态代理基础"><a href="#1-动态代理基础" class="headerlink" title="1 动态代理基础"></a>1 动态代理基础</h2><p>​    代理模式的优势是可以很好地遵循设计模式中的<strong>开放封闭原则</strong>，对扩展开发，对修改关闭。</p><p>​    动态代理是一种代理模式，它提供了一种能够在<strong>运行时动态构建代理类以及动态调用目标方法</strong>的机制。代理类可以看作是对被代理对象的包装，对目标方法的调用是通过代理类来完成的。所以通过代理模式可以有效地将服务提供者和服务消费者进行解耦，隐藏了 RPC 调用的具体细节。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220306202205168.png" alt="image-20220306202205168"></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK 动态代理实现依赖 java.lang.reflect 包中的两个核心类：<strong>InvocationHandler 接口</strong>和<strong>Proxy 类</strong>。</p><ul><li><p><strong>InvocationHandler 接口</strong></p><p>  ​    JDK 动态代理所代理的对象必须实现一个或者多个接口，生成的代理类也是接口的实现类，然后通过 JDK 动态代理是通过反射调用的方式代理类中的方法，不能代理接口中不存在的方法。</p><p>  ​    每一个动态代理对象必须提供 InvocationHandler 接口的实现类，InvocationHandler 接口中只有一个 invoke() 方法。<strong>当我们使用代理对象调用某个方法的时候，最终都会被转发到 invoke() 方法执行具体的逻辑</strong>。</p></li><li><p><strong>Proxy 类</strong></p><p>  ​    Proxy 类可以理解为动态创建代理类的工厂类，它提供了一组静态方法和接口用于动态生成对象和代理类。</p></li></ul><h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><p>​    Cglib 动态代理是基于 <strong>ASM 字节码</strong>生成框架实现的第三方工具类库，相比于 JDK 动态代理，Cglib 动态代理更加灵活，它是通过字节码技术生成的代理类，所以代理类的类型是不受限制的。使用 Cglib 代理的目标类无须实现任何接口，可以做到对目标类零侵入。</p><p>​    Cglib 动态代理是对指定类以字节码的方式<strong>生成一个子类</strong>，并重写其中的方法，以此来实现动态代理。因为 Cglib 动态代理创建的是目标类的子类，所以目标类必须要有无参构造函数，而且目标类<strong>不要用 final 进行修饰</strong>。</p><p>Cglib 动态代理的实现需要依赖两个核心组件：<strong>MethodInterceptor</strong> 接口和 <strong>Enhancer</strong>类</p><ul><li><p><strong>MethodInterceptor 接口</strong></p><p>  ​    MethodInterceptor 接口只有 intercept() 一个方法，<strong>所有被代理类的方法执行最终都会转移到 intercept() 方法中进行行为增强</strong>，真实方法的执行逻辑则通过 Method 或者 MethodProxy 对象进行调用。</p></li><li><p><strong>Enhancer 类</strong></p><p>  ​    Enhancer 类是 Cglib 中的一个字节码增强器，它为我们对代理类进行扩展时提供了极大的便利。Enhancer 类的本质是在运行时动态为代理类生成一个子类，并且拦截代理类中的所有方法。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_39056197/article/details/102598674">(121条消息) jdk动态代理invoke方法自动运行原因_码到的博客-CSDN博客_动态代理invoke</a></p><p>[27 动态代理：为用户屏蔽 RPC 调用的底层细节.md (lianglianglee.com)](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty">https://learn.lianglianglee.com/专栏/Netty</a> 核心原理剖析与 RPC 实践-完/27  动态代理：为用户屏蔽 RPC 调用的底层细节.md)</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第283场周赛</title>
    <link href="/2022/03/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC283%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC283%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">6016. Excel 表中某个范围内的单元格 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">cellsInRange</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> s1 = s[<span class="hljs-number">0</span>], s2 = s[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">char</span> n1 = s[<span class="hljs-number">1</span>], n2 = s[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">int</span> n = s2 - s1, m = n2 - n1;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">char</span> t = n1;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++) &#123;<br>                string s = <span class="hljs-string">&quot;&quot;</span>;<br>                s.<span class="hljs-built_in">append</span>(<span class="hljs-number">1</span>, s1);<br>                s.<span class="hljs-built_in">append</span>(<span class="hljs-number">1</span>, t);<br>                t ++;<br>                res.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;        <br>            s1 ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/">6017. 向数组中追加 K 个整数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minimalKSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2e9</span>);<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">int</span> fill = nums[i] - nums[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>; <span class="hljs-comment">// 要填充的数</span><br>            <span class="hljs-keyword">if</span> (fill &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (fill &gt;= k) &#123;<br>                res += (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) (nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> + nums[i - <span class="hljs-number">1</span>] + k) * k / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            res += (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) (nums[i - <span class="hljs-number">1</span>] + nums[i]) * fill / <span class="hljs-number">2</span>;<br>            k -= fill;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/">6018. 根据描述创建二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">createBinaryTree</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; descriptions)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, TreeNode*&gt; map;<br>        set&lt;<span class="hljs-keyword">int</span>&gt; childs;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> vec: descriptions) &#123;<br>            <span class="hljs-keyword">int</span> pVal = vec[<span class="hljs-number">0</span>], cVal = vec[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">bool</span> juge = vec[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">auto</span> pNode = map[pVal];<br>            <span class="hljs-keyword">if</span> (pNode == <span class="hljs-literal">nullptr</span>) &#123;<br>                pNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pVal);<br>                map[pVal] = pNode;<br>            &#125;<br>            <br>            <span class="hljs-keyword">auto</span> cNode = map[cVal];<br>            <span class="hljs-keyword">if</span> (cNode == <span class="hljs-literal">nullptr</span>) &#123;<br>                cNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(cVal);<br>                map[cVal] = cNode;<br>            &#125;<br>            childs.<span class="hljs-built_in">insert</span>(cVal);<br><br>            <span class="hljs-keyword">if</span> (juge) &#123;<br>                pNode-&gt;left = cNode;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pNode-&gt;right = cNode;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// for (auto i: childs) cout &lt;&lt; i &lt;&lt; endl;</span><br>        TreeNode* root = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> vec: descriptions) &#123;<br>            <span class="hljs-keyword">if</span> (childs.<span class="hljs-built_in">count</span>(vec[<span class="hljs-number">0</span>])) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                root = map[vec[<span class="hljs-number">0</span>]];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/replace-non-coprime-numbers-in-array/">6019. 替换数组中的非互质数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">replaceNonCoprimes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vec&#123;nums[<span class="hljs-number">0</span>]&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-keyword">while</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">int</span> x = vec.<span class="hljs-built_in">back</span>(), y = vec[vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">gcd</span>(x, y);<br>                <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                vec.<span class="hljs-built_in">pop_back</span>();<br>                vec.<span class="hljs-built_in">back</span>() *= x / t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y, x % y);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里天猫国际一面凉经</title>
    <link href="/2022/03/05/%E6%9D%82%E7%83%A9/%E9%98%BF%E9%87%8C%E5%A4%A9%E7%8C%AB%E5%9B%BD%E9%99%85%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/"/>
    <url>/2022/03/05/%E6%9D%82%E7%83%A9/%E9%98%BF%E9%87%8C%E5%A4%A9%E7%8C%AB%E5%9B%BD%E9%99%85%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>笔试</p><ol><li><p>long 100/1000</p></li><li><p>手写单例</p></li></ol><p>面试</p><ol start="3"><li><p>自我介绍</p></li><li><p>基础知识和java的学习分配</p></li><li><p>c++和java区别</p></li><li><p>java为什么还搞自己的内存分配，有什么优势呢？</p></li><li><p>上下文切换是如何记住状态的？</p></li><li><p>java中是如何识别重载，重写方法的?</p></li><li><p>你平常咋学习的</p></li><li><p>说下熟悉的源码</p></li><li><p>https和http区别</p></li><li><p>介绍下项目</p></li><li><p>说一下熟悉模块的设计</p></li><li><p>如何防止超卖</p></li><li><p>mysql索引为什么快</p></li><li><p>索引走几次io</p></li><li><p>知道java多态吗？java底层是怎么找到重载方法的?</p><p><a href="https://cloud.tencent.com/developer/article/1925122">Java及JVM是如何识别重载、重写方法的? - 云+社区 - 腾讯云 (tencent.com)</a></p></li></ol><p>总结失败总结</p><ul><li>面试比较紧张，可能是第一次面试的缘故，但归根结底还是自己心里没底，很多知识掌握的不牢靠</li><li>不够重视基础，太过于依赖所谓的“八股文”了，以为网上面经+八股合集=基础，但其实基础更多体现在日积月累的代码编写当中，例如单例模式，如果光背光看别人代码，不自己去实现面试时也可能因为紧张写错</li><li>项目理解的不够，虽然项目是从网上找的，自己也跟着敲了一遍，但没有形成一个整体的思维架构</li><li>要多问为什么，面试被问到多态，只答了重载和重写，但被问到如何定位重载方法时，就不知道了，所以平时在学习时要多想，不要总是带有一种模糊的概念</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂烩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用JvisualVM排查OOM</title>
    <link href="/2022/02/28/JVM/%E4%BD%BF%E7%94%A8JvisualVM%E6%8E%92%E6%9F%A5OOM/"/>
    <url>/2022/02/28/JVM/%E4%BD%BF%E7%94%A8JvisualVM%E6%8E%92%E6%9F%A5OOM/</url>
    
    <content type="html"><![CDATA[<h2 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1 测试环境"></a>1 测试环境</h2><p>使用JDK1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jvm.oom;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestOOM</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String content;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OOMObject</span><span class="hljs-params">(String content)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.content = content;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> OOMObject(String.valueOf(a ++)));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>配置JVM参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xms2m<span class="hljs-comment">// JVM启动时堆内存的初始化大小</span><br>-Xmx4m<span class="hljs-comment">// 设置堆内存最大值</span><br>-XX:+HeapDumpOnOutOfMemoryError<span class="hljs-comment">// 表示出现OOM异常后，生成堆快照hprof文件</span><br>-XX:HeapDumpPath=d:\jvmtest<span class="hljs-comment">// 设置堆快照hprof文件存储的位置</span><br></code></pre></td></tr></table></figure><h2 id="2-运行"><a href="#2-运行" class="headerlink" title="2 运行"></a>2 运行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.OutOfMemoryError: Java heap space<br>Dumping heap to d:\jvmtest ...<br>Unable to create d:\jvmtest: File exists<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3210</span>)<br>at java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3181</span>)<br>at java.util.ArrayList.grow(ArrayList.java:<span class="hljs-number">261</span>)<br>at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="hljs-number">235</span>)<br>at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="hljs-number">227</span>)<br>at java.util.ArrayList.add(ArrayList.java:<span class="hljs-number">458</span>)<br>at jvm.oom.TestOOM.main(TestOOM.java:<span class="hljs-number">18</span>)<br><br>Process finished with exit code <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h2 id="3-使用jvisualVM排查"><a href="#3-使用jvisualVM排查" class="headerlink" title="3 使用jvisualVM排查"></a>3 使用jvisualVM排查</h2><ol><li><p>使用CMD启动</p><p> ​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228183830553.png" alt="image-20220228183830553"></p></li><li><p>装入生成的hprof文件</p><p> ​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228183924366.png" alt="image-20220228183924366"></p></li><li><p>发现已经提示我们出现了OOM异常</p><p> ​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228183958367.png" alt="image-20220228183958367"></p></li><li><p>发现是17行出现OOM</p><p> ​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228184054505.png" alt="image-20220228184054505"></p></li><li><p>查看ArrarList</p><p> ​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228184145955.png" alt="image-20220228184145955"></p></li><li><p>发现元素个数达到三万多，并且都是OOMObject对象</p><p> ​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228184145955.png" alt="image-20220228184145955"></p></li><li><p>打开类视图，发现OOMObject对象确实占用了大量堆内存</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220228184549443.png" alt="image-20220228184549443"></p></li></ol><p>通过以上分析，就可以大概知道是过多无法回收的OOMObject对象，导致了OOM</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ol><li>生成堆转储快照dump文件（或者称hprof文件）；</li><li>利用相关工具分析堆转储快照</li><li>在线程快照（堆转储上的线程）中定位到发生OOM的线程和代码位置</li><li>综合分析线程快照里提示的本地变量信息及类视图中的实例占比，找出导致OOM的实体类型</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O多路复用详解</title>
    <link href="/2022/02/21/Linux/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/02/21/Linux/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前要知识"><a href="#1-前要知识" class="headerlink" title="1 前要知识"></a>1 前要知识</h2><h3 id="1-1-文件I-O"><a href="#1-1-文件I-O" class="headerlink" title="1.1  文件I/O"></a>1.1  文件I/O</h3><p>​    文件I/O分类，常见的有</p><ul><li><p>缓冲与⾮缓冲 I/O</p></li><li><p>直接与⾮直接 I/O</p></li><li><p>阻塞与⾮阻塞 I/O VS 同步与异步 I/O</p></li></ul><p><strong>缓冲与⾮缓冲</strong> <strong>I/O</strong></p><p>​    ⽂件操作的标准库是可以实现数据的缓存，那么<strong>根据「是否利⽤标准库缓冲」，可以把⽂件</strong> <strong>I/O</strong> <strong>分为缓冲I/O</strong> <strong>和⾮缓冲</strong> <strong>I/O</strong>：</p><ul><li><p>缓冲 I/O，利⽤的是标准库的缓存实现⽂件的加速访问，⽽标准库再通过系统调⽤访问⽂件。</p></li><li><p>⾮缓冲 I/O，直接通过系统调⽤访问⽂件，不经过标准库缓存。</p></li></ul><p><strong>直接与⾮直接</strong> <strong>I/O</strong></p><p>​    <strong>根据是「否利⽤操作系统的缓存」，可以把⽂件</strong> <strong>I/O</strong> <strong>分为直接</strong> <strong>I/O</strong> <strong>与⾮直接</strong> <strong>I/O</strong>：</p><ul><li><p>直接 I/O，不会发⽣内核缓存和⽤户程序之间数据复制，⽽是直接经过⽂件系统访问磁盘。</p></li><li><p>⾮直接 I/O，读操作时，数据从内核缓存中拷⻉给⽤户程序，写操作时，数据从⽤户程序拷⻉给内核缓存，再由内核决定什么时候写⼊数据到磁盘。</p></li></ul><p><strong>阻塞与⾮阻塞</strong> <strong>I/O VS</strong> <strong>同步与异步</strong> <strong>I/O</strong></p><p>​    <strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷⻉到⽤户态」这两个过程</strong></p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220221155756278.png" alt="image-20220221155756278"></p><p>​    <strong>⾮阻塞</strong> <strong>I/O</strong>，⾮阻塞的 read 请求在数据未准备好的情况下⽴即返回，可以继续往下执⾏，此时应⽤程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应⽤程序缓冲区， read 调⽤才可以得到结果</p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220221155839816.png" alt="image-20220221155839816"></p><p>​    <strong>同步I/O</strong>就是指「内核数据准备好」和「数据从内核态拷⻉到⽤户态」这两个过程都需要等待。</p><p>​    <strong>异步I/O</strong> 是「内核数据准备好」和「数据从内核态拷⻉到⽤户态」这两个过程都不⽤等待。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220221160210793.png" alt="image-20220221160210793"></p><h3 id="1-2-I-O模型"><a href="#1-2-I-O模型" class="headerlink" title="1.2 I/O模型"></a>1.2 I/O模型</h3><p>​    来看看Linux中提供的5种I/O处理模型</p><ol><li><p>阻塞IO</p><p> ​    阻塞IO意味着<strong>当我们发起一次IO操作后应用程序一直等待成功或失败之后才返回，在这期间程序不能做其它的事情</strong>。阻塞IO操作只能对单个文件描述符进行操作，例如read和write。</p></li><li><p>非阻塞IO</p><p> ​    非阻塞IO是指每次应用程序<strong>询问内核</strong>是否有数据准备好。如果就绪，就进行<strong>拷贝</strong>操作；如果未就绪，就<strong>不阻塞程序</strong>，内核直接返回未就绪的返回值，等待用户程序下一个轮询。</p></li><li><p>I/O多路复用</p><p> ​    发送方向接收方请求后，不等待响应，可以继续其他工作。 接收方处理请求时进行IO操作<strong>如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作</strong>。 </p><p> ​    这里复用的是指复用一个或几个线程，用一个或一组线程处理多个IO操作，减少系统开销小，不必创建和维护过多的进程/线程。</p></li><li><p>信号驱动I/O</p><p> ​    信号驱动I/O是利用信号机制，让内核告知应用程序文件描述符的相关事件。</p></li><li><p>异步非阻塞I/O</p><p> ​    发送方向接收方请求后，不等待响应，可以继续其他工作。 接收方处理请求时进行IO操作<strong>如果不能马上得到结果，也不等待，而是马上返回去做其他事情</strong>。 当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。</p></li></ol><p>​    需要说明的是，⽆论是阻塞 I/O、⾮阻塞 I/O，还是基于⾮阻塞 I/O 的多路复⽤<strong>都是同步调⽤。因为它们在 read调⽤时，内核将数据从内核空间拷⻉到应⽤程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。</strong></p><h2 id="2-I-O多路复用：select-poll-epoll"><a href="#2-I-O多路复用：select-poll-epoll" class="headerlink" title="2 I/O多路复用：select/poll/epoll"></a>2 I/O多路复用：select/poll/epoll</h2><p>​        I/O多路复用其实就是使用一个进程来维护多个Socket。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220221162244422.png" alt="image-20220221162244422"></p><p>​    ⼀个进程虽然任⼀时刻只能处理⼀个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1秒内就可以处理上千个请求，把时间拉⻓来看，多个请求复⽤了⼀个进程，这就是多路复⽤，这种思想很类似⼀个 CPU 并发多个进程，所以也叫做时分多路复⽤。</p><p>​    select/poll/epoll 内核提供给⽤户态的多路复⽤系统调⽤，<strong>进程可以通过⼀个系统调⽤函数从内核中获取多个事件</strong>。</p><h3 id="2-1-select"><a href="#2-1-select" class="headerlink" title="2.1 select"></a>2.1 select</h3><p>​    select 实现多路复⽤的⽅式是，将已连接的 Socket 都放到⼀个<strong>⽂件描述符集合</strong>，然后调⽤ select 函数将⽂件描述符集合<strong>拷⻉</strong>到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过<strong>遍历</strong>⽂件描述符集合的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个⽂件描述符集合<strong>拷⻉</strong>回⽤户态⾥，然后⽤户态还需要再通过<strong>遍历</strong>的⽅法找到可读或可写的 Socket，然后再对其处理。</p><p>​    所以，对于 select 这种⽅式，需要进⾏ <strong>2</strong> <strong>次「遍历」⽂件描述符集合</strong>，⼀次是在内核态⾥，⼀个次是在⽤户态⾥ ，⽽且还会发⽣ <strong>2</strong> <strong>次「拷⻉」⽂件描述符集合</strong>，先从⽤户空间传⼊内核空间，由内核修改后，再传出到⽤户空间中。</p><p>​    select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。</p><h3 id="2-2-poll"><a href="#2-2-poll" class="headerlink" title="2.2 poll"></a>2.2 poll</h3><p>​    poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。但是 poll 和 select 并没有太⼤的本质区别，<strong>都是使⽤「线性结构」存储进程关注的</strong> <strong>Socket</strong> <strong>集合，因此都需要遍历⽂件描述符集合来找到可读或可写的Socket，时间复杂度为O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合</strong>，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p><h3 id="2-3-epoll"><a href="#2-3-epoll" class="headerlink" title="2.3 epoll"></a>2.3 epoll</h3><p>​    epoll 通过两个⽅⾯，很好解决了 select/poll 的问题。</p><p>​    第⼀点，epoll 在内核⾥使⽤<strong>红⿊树来跟踪进程所有待检测的⽂件描述字</strong>，把需要监控的 socket 通过<code>epoll_ctl() </code>函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，减少了内核和⽤户空间⼤量的数据拷⻉和内存分配。</p><p>​    第⼆点， epoll 使⽤事件驱动的机制，内核⾥<strong>维护了⼀个链表来记录就绪事件</strong>，当某个 socket 有事件发⽣时，通过回调函数内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤<code>epoll_wait()</code>函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</p><p>​    从下图你可以看到 epoll 相关的接⼝作⽤：</p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220221165456166.png" alt="image-20220221165456166"></p><p>​    epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，<strong>epoll</strong> <strong>被称为解决</strong> <strong>C10K问题</strong></p><p>​    要注意的是，epoll使⽤的并不是共享内存的⽅式，即⽤户态和内核态都指向了就绪链表，所以就避免了内存拷⻉消耗。</p><p>​    epoll ⽀持两种事件触发模式，分别是<strong>边缘触发</strong>（<strong>edge-triggered</strong>，<strong>ET</strong>）和<strong>⽔平触发</strong>（<strong>level-triggered</strong>，<strong>LT</strong>）。</p><ul><li><p>使⽤边缘触发模式时，当被监控的 Socket 描述符上有可读事件发⽣时，<strong>服务器端只会从</strong> <strong>epoll_wait中苏醒⼀次</strong>，即使进程没有调⽤ read 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保证⼀次性将内核缓冲区的数据读取完；</p></li><li><p>使⽤⽔平触发模式时，当被监控的 Socket 上有可读事件发⽣时，<strong>服务器端不断地从</strong> <strong>epoll_wait</strong> <strong>中苏</strong>醒，直到内核缓冲区数据被** <strong>read</strong> <strong>函数读完才结束</strong>，⽬的是告诉我们有数据需要读取；</p></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>​    select 和 poll 并没有本质区别，它们内部都是使⽤「线性结构」来存储进程关注的 Socket 集合。</p><p>​    在使⽤的时候，⾸先需要把关注的 Socket 集合通过 <code>select/poll </code>系统调⽤从⽤户态拷⻉到内核态，然后由内核检测事件，当有⽹络事件产⽣时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷⻉到⽤户态，⽤户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理。</p><p>​    很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越⼤，Socket 集合的遍历和拷⻉会带来很⼤的开销，因此也很难应对 C10K。</p><p>​    epoll 是解决 C10K 问题的利器，通过两个⽅⾯解决了 select/poll 的问题。</p><ul><li>epoll 在内核⾥使⽤「红⿊树」来关注进程所有待检测的 Socket，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是 O(logn)，通过对这棵⿊红树的管理，不需要像 select/poll 在每次操作时都传⼊整个 Socket 集合，减少了内核和⽤户空间⼤量的数据拷⻉和内存分配。</li><li>epoll 使⽤事件驱动的机制，内核⾥维护了⼀个「链表」来记录就绪事件，只将有事件发⽣的 Socket集合传递给应⽤程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和⽆事件的 Socket ），⼤⼤提⾼了检测的效率。</li></ul><p>​    ⽽且，epoll ⽀持边缘触发和⽔平触发的⽅式，⽽ <code>select/poll </code>只⽀持⽔平触发，⼀般⽽⾔，边缘触发的⽅式会⽐⽔平触发的效率⾼。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/115220699">一文看懂IO多路复用 - 知乎 (zhihu.com)</a></p><p>图解系统-亮白风格-小林coding-v1.0.pdf</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络模型</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK和Cglib动态代理的区别</title>
    <link href="/2022/02/20/%E6%A1%86%E6%9E%B6/Spring/JDK%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/02/20/%E6%A1%86%E6%9E%B6/Spring/JDK%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要代理？"><a href="#1-为什么需要代理？" class="headerlink" title="1 为什么需要代理？"></a>1 为什么需要代理？</h2><p>​    简单来说，就是为了保证<strong>单一性原则问题</strong>，也就是每个类的功能尽可能单一，这样才能是该类被改动的可能性最小。比如，如果当我们需要为类里加上权限，日志等功能时，如果每个类都需要这种功能，那就要修改每个类，这样工作量很大，所以我们需要一个<strong>代理</strong>，让我们可以在不改动原有代码的前提下，实现一些其他功能，即<strong>增强</strong>。我们在进入目标类之前，先进入代理类，在代理类中写我们需要的额外功能，这样原有类不动，不影响原有功能。</p><p>​    下面就是一个关于静态代理的实例，能帮助理解代理的意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 共同接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProgrammerInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goToWork</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goOffWork</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 程序员类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Programmer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProgrammerInterface</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goToWork</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;开始上班了\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goOffWork</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;终于下班了\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 程序员代理类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgrammerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProgrammerInterface</span> </span>&#123;<br>    <span class="hljs-comment">//目标类(程序员类)</span><br>    Programmer programmer;<br><br><br>    <span class="hljs-comment">//构造方法,初始化目标类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProgrammerProxy</span><span class="hljs-params">(Programmer programmer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.programmer = programmer;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goToWork</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;进入了上班代理\n&quot;</span>);<br>        programmer.goToWork();<br>        System.out.print(<span class="hljs-string">&quot;上班时间为:&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot;\n\n&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goOffWork</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;进入了下班代理\n&quot;</span>);<br>        programmer.goOffWork();<br>        System.out.print(<span class="hljs-string">&quot;下班时间为:&quot;</span> + <span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyDemoApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        Programmer programmer = new Programmer();</span><br><span class="hljs-comment">//        programmer.goToWork();</span><br><span class="hljs-comment">//        programmer.goOffWork();</span><br><br><br>        Programmer programmer = <span class="hljs-keyword">new</span> Programmer();<br>        ProgrammerProxy programmerProxy = <span class="hljs-keyword">new</span> ProgrammerProxy(programmer);<br>        programmerProxy.goToWork();<br>        programmerProxy.goOffWork();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">进入了上班代理<br>开始上班了<br>上班时间为：Sun Feb <span class="hljs-number">20 16:51:09</span> CST <span class="hljs-number">2022</span><br><br>进入了下班代理<br>终于下班了<br>下班时间为：Sun Feb <span class="hljs-number">20 16:51:09</span> CST <span class="hljs-number">2022</span><br></code></pre></td></tr></table></figure><p>​    但静态代理有两个问题</p><ul><li>如果其他类需要实现同样的功能，则需要在写一个代理类，这样会很麻烦。</li><li>当我们需要新增功能时，需要在接口，类，代理类上都要新增，项目规模较大时不好维护  </li></ul><p>​    所以，就出现了动态代理，下面来聊聊Java中动态代理的几种方式和区别。</p><h2 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2 JDK动态代理"></a>2 JDK动态代理</h2><p>​    JDK动态代理主要是通过，反射包中的<strong>Porxy类</strong>和<strong>InvokationHandler接口</strong>。它们结合在一起后可以创建动态代理类。<strong>Porxy类基于传递的参数创建动态代理类</strong>。<strong>InvokationHandler则用于激发动态代理类的方法</strong>。这个过程是在程序执行过程中动态生成与处理的，所以叫动态代理。</p><p>​    下面来看看使用示例</p><h3 id="实现InvokationHandler接口"><a href="#实现InvokationHandler接口" class="headerlink" title="实现InvokationHandler接口"></a>实现InvokationHandler接口</h3><p>​    JDK 动态代理类必须实现反射包中的 java.lang.reflect.InvocationHandler 接口，在此接口中只有一个 invoker 方法：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220220173542450.png" alt="image-20220220173542450"></p><p>​    在<code>InvocationHandler#invoker</code>中必须调用目标类被代理的方法，否则无法做到代理的实现。下面为实现 InvocationHandler 的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetInvoker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-comment">// 代理中持有的目标类</span><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TargetInvoker</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;jdk 代理执行前&quot;</span>);<br>        Object result = method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;jdk 代理执行后&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在实现<code>InvocationHandler#invoker</code>时，该方法里有三个参数：</p><ul><li>proxy 代理目标对象的代理对象，它是真实的代理对象。</li><li>method 执行目标类的方法</li><li>args 执行目标类的方法的参数</li></ul><h3 id="创建JDK动态代理类"><a href="#创建JDK动态代理类" class="headerlink" title="创建JDK动态代理类"></a>创建JDK动态代理类</h3><p>​    创建 JDK 动态代理类实例同样也是使用反射包中的 java.lang.reflect.Proxy 类进行创建。通过调用<code>Proxy#newProxyInstance</code>静态方法进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyAnimal</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Object proxy = Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(), <span class="hljs-comment">// 指定目标类的类加载</span><br>                target.getClass().getInterfaces(),  <span class="hljs-comment">// 代理需要实现的接口，可指定多个，这是一个数组</span><br>                <span class="hljs-keyword">new</span> TargetInvoker(target)   <span class="hljs-comment">// 代理对象处理器</span><br>        );<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <code>Proxy#newProxyInstance</code>中的三个参数（ClassLoader loader、Class&lt;?&gt;[] interfaces、InvocationHandler h）：</p><ul><li>loader 加载代理对象的类加载器</li><li>interfaces 代理对象实现的接口，与目标对象实现同样的接口</li><li>h 处理代理对象逻辑的处理器，即上面的 InvocationHandler 实现类。</li></ul><p>​    最后实现执行 DynamicProxyAnimal 动态代理：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220220173811698.png" alt="image-20220220173811698"></p><h2 id="3-Cglib动态代理"><a href="#3-Cglib动态代理" class="headerlink" title="3 Cglib动态代理"></a>3 Cglib动态代理</h2><p>​    CGLIB 动态代理的实现机制是<strong>生成目标类的子类</strong>，通过调用父类（目标类）的方法实现，在调用父类方法时再代理中进行增强。</p><h3 id="实现-MethodInterceptor-接口"><a href="#实现-MethodInterceptor-接口" class="headerlink" title="实现 MethodInterceptor 接口"></a>实现 MethodInterceptor 接口</h3><p>​    相比于 JDK 动态代理的实现，CGLIB 动态代理不需要实现与目标类一样的接口，而是通过方法拦截的方式实现代理，代码实现如下，首先方法拦截接口 <code>net.sf.cglib.proxy.MethodInterceptor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CGLIB 调用前&quot;</span>);<br>        Object result = proxy.invokeSuper(obj, args);<br>        System.out.println(<span class="hljs-string">&quot;CGLIB 调用后&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过方法拦截接口调用目标类的方法，然后在该被拦截的方法进行增强处理，实现方法拦截器接口的 intercept 方法里面有四个参数：</p><ul><li>obj 代理类对象</li><li>method 当前被代理拦截的方法</li><li>args 拦截方法的参数</li><li>proxy 代理类对应目标类的代理方法</li></ul><h3 id="创建Cglib动态代理类"><a href="#创建Cglib动态代理类" class="headerlink" title="创建Cglib动态代理类"></a>创建Cglib动态代理类</h3><p>​    创建 CGLIB 动态代理类使用 net.sf.cglib.proxy.Enhancer 类进行创建，它是 CGLIB 动态代理中的核心类，首先创建个简单的代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置类加载</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> TargetInterceptor());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    设置被代理类的信息和代理类拦截的方法的回调执行逻辑，就可以实现一个代理类。 实现 CGLIB 动态代理调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dynamicProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Animal cat = (Animal) CglibProxy.getProxy(Cat.class);<br>        cat.call();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220220175349478.png" alt="image-20220220175349478"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>​    两种机制的不同实现：</p><ul><li>JDK 动态代理是通过<strong>实现目标类的接口</strong>，然后<strong>将目标类在构造动态代理时作为参数传入</strong>，使代理对象持有目标对象，再<strong>通过代理对象的 InvocationHandler 实现动态代理</strong>的操作。 </li><li> CGLIB 动态代理是通过<strong>配置目标类信息</strong>，然后<strong>利用 ASM 字节码框架进行生成目标类的子类</strong>。当调用代理方法时，通过<strong>拦截方法的方式实现代理的操作</strong>。</li></ul><p>​    从而，我们知道：</p><ol><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</li></ol><p>​    后续再出一篇关于源码阅读的文章详解，这两种方式是如何实现代理的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6997416275492208648">JDK 动态代理与 CGLIB 有哪些区别? - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/126503023">你必须会的 JDK 动态代理和 CGLIB 动态代理 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第72场双周赛</title>
    <link href="/2022/02/20/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC72%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/20/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC72%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-equal-and-divisible-pairs-in-an-array/">5996. 统计数组中相等且可以被整除的数对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == nums[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (((i * j) % k) == <span class="hljs-number">0</span>) res ++;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/">5997. 找到和为给定整数的三个连续整数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">sumOfThree</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid = num / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">long</span> left = mid - <span class="hljs-number">1</span>, right = mid + <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (mid + left + right == num) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(left);<br>            res.<span class="hljs-built_in">push_back</span>(mid);<br>            res.<span class="hljs-built_in">push_back</span>(right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-split-of-positive-even-integers/">5998. 拆分成最多数目的偶整数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">maximumEvenSplit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> finalSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (finalSum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&#123;&#125;;<br><br>        vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; res;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (finalSum &gt;= i) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            finalSum -= i;<br>            i += <span class="hljs-number">2</span>;<br>        &#125;<br>        res[res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] += finalSum;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LC双周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树专题</title>
    <link href="/2022/02/18/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/2022/02/18/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/NaqhDT/">剑指 Offer II 043. 往完全二叉树添加节点 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBTInserter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    TreeNode *root;<br>    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>        size ++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-built_in">CBTInserter</span>(TreeNode *root) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;root = root;<br>        <span class="hljs-built_in">dfs</span>(root);    <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        size ++;<br>        TreeNode* fatherNode = <span class="hljs-built_in">getFatherNode</span>(size / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            fatherNode-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fatherNode-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fatherNode-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">getFatherNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* node = <span class="hljs-built_in">getFatherNode</span>(n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ? node-&gt;right : node-&gt;left;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CBTInserter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CBTInserter* obj = new CBTInserter(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;insert(v);</span><br><span class="hljs-comment"> * TreeNode* param_2 = obj-&gt;get_root();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>[剑指 Offer II 045. 二叉树最底层最左边的值 - 力扣（LeetCode） (leetcode-cn.com)](<a href="https://leetcode-cn.com/problems/LwUNpT/">https://leetcode-cn.com/problems/LwUNpT/</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">int</span> maxDepth = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span> (root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (depth &gt; maxDepth) &#123;<br>            res = root-&gt;val;<br>            maxDepth = depth;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/pOCWxh/">剑指 Offer II 047. 二叉树剪枝 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">pruneTree</span>(root-&gt;left);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">pruneTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (root-&gt;val == <span class="hljs-number">0</span> &amp;&amp; !left &amp;&amp; !right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        root-&gt;left = left;<br>        root-&gt;right = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3Etpl5/">剑指 Offer II 049. 从根节点到叶节点的路径数字之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">int</span> sum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> ;<br><br>        path = path * <span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;<br>            sum += path;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        dfs(root-&gt;left, path);<br>        dfs(root-&gt;right, path);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/6eUYwP/">剑指 Offer II 050. 向下的路径节点之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">int</span> res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dfs(root, targetSum);<br>        pathSum(root-&gt;left, targetSum);<br>        pathSum(root-&gt;right, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> ;<br>        sum -= root-&gt;val;<br>        <span class="hljs-keyword">if</span> (!sum) res ++;<br>        <span class="hljs-keyword">if</span> (root-&gt;left != nullptr) dfs(root-&gt;left, sum);<br>        <span class="hljs-keyword">if</span> (root-&gt;right != nullptr) dfs(root-&gt;right, sum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/P5rCT8/">剑指 Offer II 053. 二叉搜索树中的中序后继 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode *res;<br>    bool flag;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, TreeNode *p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == NULL) <span class="hljs-keyword">return</span> ;<br>        dfs(root-&gt;left, p);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; !flag) &#123;<br>            res = root;<br>            flag = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        dfs(root-&gt;right, p);<br>    &#125;<br><br>    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) &#123;<br>        <span class="hljs-keyword">if</span> (root == NULL) <span class="hljs-keyword">return</span> NULL;<br>        dfs(root, p);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/w6cpku/">剑指 Offer II 054. 所有大于等于节点的值之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        root-&gt;val = root-&gt;val + sum;<br>        sum = root-&gt;val;<br>        <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1. 1 定义"></a>1. 1 定义</h3><p>（1）结点是红色或黑色</p><p>（2）根节点是黑色</p><p>（3）所有叶子都是黑色（叶子是NULL结点）</p><p>（4）每个<strong>红色</strong>节点的两个子节点一定都是<strong>黑色</strong>。不能有两个红<strong>色节</strong>点相连。</p><p>（5）任意一节点到每个叶子节点的路径都包含<strong>数量相同</strong>的<strong>黑结点</strong>。俗称：<strong>黑高</strong>！</p><p><strong>红黑树实例图</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216193744878.png" alt="image-20220216193744878"></p><p>​    红黑树并不是一个完美平衡二叉查找树，从图上可以看到，根结点P的左子树显然比右子树高，</p><p>​    但左子树和右子树的黑结点的层数是相等的，也就是说，任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。</p><p>​    所以我们叫红黑树这种平衡为黑色完美平衡。</p><p>​    红黑树的性质讲完了，只要这棵树满足以上性质，这棵树就是趋近与平衡状态的。</p><h3 id="1-2-性质"><a href="#1-2-性质" class="headerlink" title="1.2 性质"></a>1.2 性质</h3><p>​    从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</p><h3 id="1-3-关于红黑树操作"><a href="#1-3-关于红黑树操作" class="headerlink" title="1.3 关于红黑树操作"></a>1.3 关于红黑树操作</h3><p>​    在了解这些操作前，先明确三个小操作</p><ol><li><p>变色：结点的颜色由红变黑或由黑变红。</p></li><li><p>左旋：以某个结点作为支点(旋转结点)，其<strong>右子结点</strong>变为旋转结点的父结点，<strong>右子结点的左子结点</strong>变为<strong>旋转结点的右子结点</strong>，左子结点保持不变。</p></li><li><p>右旋：以某个结点作为支点(旋转结点)，其<strong>左子结点</strong>变为旋转结点的父结点，<strong>左子结点的右子结点</strong>变为<strong>旋转结点的左子结点</strong>，右子结点保持不变</p></li></ol><p><strong>左旋图示</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216194036703.png" alt="image-20220216194036703"></p><p><strong>右旋图示</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216194055359.png" alt="image-20220216194055359"></p><p>另外，约定一些节点的称呼</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216194136511.png" alt="image-20220216194136511"></p><h4 id="1-3-1-插入"><a href="#1-3-1-插入" class="headerlink" title="1.3.1 插入"></a>1.3.1 插入</h4><p>插入操作包括两部分工作：</p><ol><li><p>查找插入的位置</p></li><li><p>插入后自平衡</p></li></ol><p>​    注意：插入节点，必须为红色<strong>，</strong>理由很简单，红色在父节点（如果存在）为黑色节点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。</p><p>​    但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><h5 id="红黑树插入节点情景分析"><a href="#红黑树插入节点情景分析" class="headerlink" title="红黑树插入节点情景分析"></a>红黑树插入节点情景分析</h5><h6 id="情景1：红黑树为空树"><a href="#情景1：红黑树为空树" class="headerlink" title="情景1：红黑树为空树"></a>情景1：红黑树为空树</h6><p>​    最简单的一种情景，直接把插入结点作为根结点就行</p><p>​    注意：根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><h6 id="情景2：插入结点的Key已存在"><a href="#情景2：插入结点的Key已存在" class="headerlink" title="情景2：插入结点的Key已存在"></a>情景2：插入结点的Key已存在</h6><p>​    处理：更新当前节点的值，为插入节点的值</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216194420333.png" alt="image-20220216194420333"></p><h6 id="情景3：插入结点的父结点为黑结点"><a href="#情景3：插入结点的父结点为黑结点" class="headerlink" title="情景3：插入结点的父结点为黑结点"></a>情景3：插入结点的父结点为黑结点</h6><p>​    由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216194453784.png" alt="image-20220216194453784"></p><h6 id="情景4：插入节点的父节点为红色"><a href="#情景4：插入节点的父节点为红色" class="headerlink" title="情景4：插入节点的父节点为红色"></a>情景4：插入节点的父节点为红色</h6><p>​    再次回想下红黑树的<strong>性质2：根结点是黑色</strong>。如果插入节点的父结点为<strong>红结点</strong>，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。</p><p>​    这一点很关键，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195316156.png" alt="image-20220216195316156"></p><p><strong>插入情景4.1：叔叔结点存在并且为红结点</strong></p><p>依据红黑树性质4可知，红色节点不能相连 ==&gt; 祖父结点肯定为黑结点；</p><p>因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红</p><p>处理：</p><ol><li><p>将P和U节点改为黑色</p></li><li><p>将PP改为红色</p></li><li><p>将PP设置为当前节点，进行后续处理</p></li></ol><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195400126.png" alt="image-20220216195400126"></p><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；</p><p>但如果PP的父结点是红色，则违反红黑树性质了。所以需要将PP设置为当前节点，继续做插入操作自平衡处理，直到平衡为止。</p><p><strong>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</strong></p><p><strong>注意：单纯从插入前来看，叔叔节点非红即空（NIL节点），否则的话破坏了红黑树性质5，此路径会比其它路径多一个黑色节点。</strong></p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195532430.png" alt="image-20220216195532430"></p><p><strong>插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况）</strong></p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195549365.png" alt="image-20220216195549365"></p><p>处理：</p><ol><li><p>变颜色：将P设置为黑色，将PP设置为红色</p></li><li><p>对PP节点进行<strong>右旋</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195625507.png" alt="image-20220216195625507"></p><p><strong>插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况）</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195709340.png" alt="image-20220216195709340"></p><p>处理：</p><ol><li><p>对P进行左旋</p></li><li><p>将P设置为当前节点，得到LL红色情况</p></li><li><p>按照LL红色情况处理（1.变颜色 2.右旋PP）</p></li></ol><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195741517.png" alt="image-20220216195741517"></p><p><strong>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</strong></p><p>该情景对应情景4.2，只是方向反转，直接看图。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195827043.png" alt="image-20220216195827043"></p><p><strong>插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况）</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195842349.png" alt="image-20220216195842349"></p><p>处理：</p><ol><li><p>变颜色：将P设置为黑色，将PP设置为红色</p></li><li><p>对PP节点进行<strong>左旋</strong></p></li></ol><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195907708.png" alt="image-20220216195907708"></p><p><strong>插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况）</strong></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195936107.png" alt="image-20220216195936107"></p><p>处理：</p><ol><li><p>对P进行右旋</p></li><li><p>将P设置为当前节点，得到RR红色情况</p></li><li><p>按照RR红色情况处理（1.变颜色 2.左旋PP）</p></li></ol><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216195959993.png" alt="image-20220216195959993"></p><h4 id="1-3-2-删除"><a href="#1-3-2-删除" class="headerlink" title="1.3.2 删除"></a>1.3.2 删除</h4><p>​    删除操作整体要比插入难一些。插入操作主要容易违背红黑树的<strong>定义4</strong>（红黑树中不存在两个相邻的红色结点）。而删除操作主要容易违背<strong>定义5</strong>（删除黑色结点可能导致根结点到叶结点黑色结点的数目减少，即黑高降低）。</p><p>​    在介绍具体的操作之前，先了解些概念</p><blockquote><p>当删除结点 v 是黑色结点，且其被其黑色子节点替换时，其子结点就被标记为 <strong>双黑</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216215037480.png" alt="image-20220216215037480"></p><p>​    删除操作最主要的任务就可以转化为将双黑结点转化为我们普通黑色结点。</p><h5 id="红黑树的删除分析"><a href="#红黑树的删除分析" class="headerlink" title="红黑树的删除分析"></a>红黑树的删除分析</h5><p>​    首先我们假定要删除的结点为 v ，u 是用来替换 v 的孩子结点（注意，当 v 是叶结点时， u 是 NULL结点，且NULL结点我们还是当做黑色结点处理）。</p><p>​    删除操作总纲：</p><ol><li>执行标准的 BST 的删除操作</li><li>简单情况：u 或者 v 是红色</li><li>复杂情况：u 和 v 都是黑色结点。</li></ol><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216215208854.png" alt="image-20220216215208854"></p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216215224309.png" alt="image-20220216215224309"></p><h6 id="简单情况：u或v是红色节点"><a href="#简单情况：u或v是红色节点" class="headerlink" title="简单情况：u或v是红色节点"></a>简单情况：u或v是红色节点</h6><p>​    如果 u 或者 v 是红色，我们将替换结点 v 的结点 u 标记为黑色结点（这样黑高就不会变化）。注意这里是 u 或者 v 是红色结点，因为在一棵红黑树中，是不允许有两个相邻的红色结点的，而结点 v 是结点 u 的父结点，因此只能是 u 或者 v 是红色结点。</p><p>​    删除结点 <strong>v</strong> 为黑色结点 <strong>10</strong> ，替换结点 <strong>v</strong> 的结点 <strong>u</strong> 为红色结点 <strong>9</strong> 的情况：</p><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216215416038.png" alt="image-20220216215416038"></p><p>​    删除结点 <strong>v</strong> 为红色结点 <strong>20</strong> ，替换结点 <strong>v</strong> 的结点 <strong>u</strong> 为黑色NULL结点 <strong>h</strong> 的情况：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220216215446143.png" alt="image-20220216215446143"></p><h6 id="复杂情况：u和v都是黑色节点"><a href="#复杂情况：u和v都是黑色节点" class="headerlink" title="复杂情况：u和v都是黑色节点"></a>复杂情况：u和v都是黑色节点</h6><p>​    下面不想写了= =，具体参考这篇博文把，感觉写的不错</p><p><a href="https://zhuanlan.zhihu.com/p/145006031">图解：红黑树删除篇（一文读懂） - 知乎 (zhihu.com)</a></p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h2><h4 id="2-1-RBTree-java"><a href="#2-1-RBTree-java" class="headerlink" title="2.1 RBTree.java"></a>2.1 RBTree.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DataStructure.rbtree;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ②创建RBNode</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ③辅助方法定义：parentOf(node)，isRed(node)，setRed(node)，setBlack(node)，inOrderPrint()</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ④左旋方法定义：leftRotate(node)</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ⑤右旋方法定义：rightRotate(node)</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ⑥公开插入接口方法定义：insert(K key, V value);</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ⑦内部插入接口方法定义：insert(RBNode node);</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ⑧修正插入导致红黑树失衡的方法定义：insertFIxUp(RBNode node);</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * ⑨测试红黑树正确性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBTree</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> RED = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 红</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> BLACK = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 黑</span><br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-meta">@AllArgsConstructor</span><br>    <span class="hljs-meta">@NoArgsConstructor</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBNode</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;, <span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> RBNode parent; <span class="hljs-comment">//父结点</span><br>        <span class="hljs-keyword">private</span> RBNode left; <span class="hljs-comment">// 左子树</span><br>        <span class="hljs-keyword">private</span> RBNode right; <span class="hljs-comment">// 右子树</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> color; <span class="hljs-comment">// 颜色</span><br>        <span class="hljs-keyword">private</span> K key; <span class="hljs-comment">//键</span><br>        <span class="hljs-keyword">private</span> V value; <span class="hljs-comment">// 值</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 树根的引用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> RBNode root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RBNode <span class="hljs-title">getRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> RBNode <span class="hljs-title">parentOf</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> node.parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前结点是否为红色</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRed</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.color == RED;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前结点是否为黑色</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBlack</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.color == BLACK;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置节点为红色</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRed</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            node.color = RED;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置节点为黑色</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBlack</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            node.color = BLACK;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 中序打印二叉树</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        inOrderPrint(root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderPrint</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            inOrderPrint(node.left);<br>            System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + node.key + <span class="hljs-string">&quot;.value:&quot;</span> + node.value);<br>            inOrderPrint(node.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 左旋方法</span><br><span class="hljs-comment">     * 左旋示意图：左旋x节点</span><br><span class="hljs-comment">     *   p                   p</span><br><span class="hljs-comment">     *   |                   |</span><br><span class="hljs-comment">     *   x                   y</span><br><span class="hljs-comment">     *  / \      ----&gt;      / \</span><br><span class="hljs-comment">     * lx  y               x   ry</span><br><span class="hljs-comment">     *    / \             / \</span><br><span class="hljs-comment">     *   ly  ry          lx  ly</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 左旋做了几件事？</span><br><span class="hljs-comment">     * 1.将x的右子节点指向y的左子节点(ly)，并且把y的左子节点更新为x</span><br><span class="hljs-comment">     * 2.当x的父节点(不为空时)，更新y的父节点为x的父节点，并将x的父节点 指定 子树(当前x的子树位置) 指定为y</span><br><span class="hljs-comment">     * 3.将x的父节点更新为y，将y的左子节点更新为x</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">(RBNode x)</span> </span>&#123;<br>        RBNode y = x.right;<br>        x.right = y.left;<br>        <span class="hljs-comment">// 1.将x的右子节点指向y的左子节点(ly)，并且把y的左子节点更新为x</span><br>        <span class="hljs-keyword">if</span> (y.left != <span class="hljs-keyword">null</span>) &#123;<br>            y.left.parent = x;<br>        &#125;<br><br>        <span class="hljs-comment">// 2.当x的父节点(不为空时)，更新y的父节点为x的父节点，并将x的父节点 指定 子树(当前x的子树位置) 指定为y</span><br>        <span class="hljs-keyword">if</span> (x.parent != <span class="hljs-keyword">null</span>) &#123;<br>            y.parent = x.parent;<br>            <span class="hljs-keyword">if</span> (x == x.parent.left) &#123; <span class="hljs-comment">// 如果x是其父节点的左子节点，则将y放在x父节点的左边</span><br>                x.parent.left = y;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                x.parent.right = y; <span class="hljs-comment">// 如果x是其父节点的右子节点，则将y放在x父节点的右边</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 说明x为根节点，此时需要更新y为根节点 的引用</span><br>            <span class="hljs-keyword">this</span>.root = y;<br>            <span class="hljs-keyword">this</span>.root.parent = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 根节点无父节点</span><br>        &#125;<br>        <span class="hljs-comment">// 3.将x的父节点更新为y，将y的左子节点更新为x</span><br>        x.parent = y;<br>        y.left = x;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 右旋方法</span><br><span class="hljs-comment">     * 右旋示意图：右旋y节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *     p                       p</span><br><span class="hljs-comment">     *     |                       |</span><br><span class="hljs-comment">     *     y                       x</span><br><span class="hljs-comment">     *    / \          ----&gt;      / \</span><br><span class="hljs-comment">     *   x   ry                  lx  y</span><br><span class="hljs-comment">     *  / \                         / \</span><br><span class="hljs-comment">     * lx  ly                      ly  ry</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 右旋都做了几件事？</span><br><span class="hljs-comment">     * 1.将y的左子节点指向x的右子节点，并且更新x的右子节点的父节点为y</span><br><span class="hljs-comment">     * 2.当y的父节点不为空时，更新x的父节点为y的父节点，更新y的父节点的指定子节点（y当前位置） 为x</span><br><span class="hljs-comment">     * 3.更新y 的父节点为x ,更新x 的右子节点为y</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">(RBNode y)</span> </span>&#123;<br>        RBNode x = y.left;<br>        y.left = x.right;<br>        <span class="hljs-comment">// 1.将x的右子节点 赋值 给了 y 的左子节点，并且更新x的右子节点的父节点为 y</span><br>        <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;<br>            x.right.parent = y;<br>        &#125;<br><br>        <span class="hljs-comment">// 2.将y的父节点p（非空时）赋值给x的父节点，同时更新p的子节点为x（左或右）</span><br>        <span class="hljs-keyword">if</span> (y.parent != <span class="hljs-keyword">null</span>) &#123;<br>            x.parent = y.parent;<br>            <span class="hljs-keyword">if</span> (y == y.parent.left) &#123;  <span class="hljs-comment">// 如果y是其父节点的左子节点，则将x放在y父节点的左边</span><br>                y.parent.left = x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果y是其父节点的右子节点，则将x放在y父节点的右边</span><br>                y.parent.right = x;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 说明y为根节点，此时需要更新x为根节点 的引用</span><br>            <span class="hljs-keyword">this</span>.root = x;<br>            x.parent = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.将x的右子节点赋值为y，将y的父节点设置为x</span><br>        x.right = y;<br>        y.parent = x;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * public插入方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>        RBNode node = <span class="hljs-keyword">new</span> RBNode&lt;&gt;();<br>        node.setKey(key);<br>        node.setValue(value);<br>        <span class="hljs-comment">// 新结点一定是红色</span><br>        node.setColor(RED);<br><br>        insert(node);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入节点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        <span class="hljs-comment">// 第一步：查找当前要插入节点node的父节点</span><br>        RBNode parent = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 声明要插入节点node的父节点</span><br>        RBNode x = <span class="hljs-keyword">this</span>.root;<br><br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-keyword">null</span>) &#123;<br>            parent = x;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * cmp &gt; 0 说明node.key 大于 x.key 需要到x 的右子树查找</span><br><span class="hljs-comment">             * cmp == 0 说明node.key 等于 x.key 需要进行替换操作</span><br><span class="hljs-comment">             * cmp &lt; 0 说明node.key 小于 x.key 需要到x 的左子树查找</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">int</span> cmp = node.key.compareTo(x.key);<br>            <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;<br>                x = x.right;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp == <span class="hljs-number">0</span>) &#123;<br>                x.setValue(node.getValue());<br>                <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 修改完后 就不再继续往下面的代码执行了</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                x = x.left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 退出上面的while循环后，到这里，说明树中没有相同key 的元素</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 需要添加新元素node到 x(parent) 目前位置的左子树/右子树</span><br><span class="hljs-comment">         */</span><br>        node.parent = parent;<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 判断node与parent的key谁大</span><br>            <span class="hljs-keyword">int</span> cmp = node.key.compareTo(parent.key);<br>            <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当前node的key比parent 的key大，需要把node放入parent 的右子节点</span><br>                parent.right = node;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当前node的key比parent 的key大，需要把node放入parent 的右子节点</span><br>                parent.left = node;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// parent == null; 说明为空树</span><br>            <span class="hljs-keyword">this</span>.root = node; <span class="hljs-comment">// 直接给树根赋值为node</span><br>        &#125;<br>        <span class="hljs-comment">// 新元素node 加入树中之后，要调用修复红黑树平衡的方法</span><br>        insertFixUp(node);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入后修复红黑树平衡的方法</span><br><span class="hljs-comment">     * |---情景1：如果红黑树为空树,需要将根节点染为黑色</span><br><span class="hljs-comment">     * |---情景2：如果插入节点的key已经存在,(这种情况不需要处理,因为修改树中的值不会触发红黑树修复平衡方法)</span><br><span class="hljs-comment">     * |---情景3：如果插入节点的父节点为黑色,这种情况不需要处理,(参考红黑树的性质4和性指5去理解)</span><br><span class="hljs-comment">     * (因为所插入的路径中,黑色节点数没发生变化,所以红黑树依然平衡)</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 情景4 需要去处理的情景</span><br><span class="hljs-comment">     * |---情景4：插入节点的父节点为红色,(违反红黑树性质4,不能有两个红色节点相连)</span><br><span class="hljs-comment">     *  |---情景4.1：叔叔节点存在，并且为红色（父-叔 双红）</span><br><span class="hljs-comment">     *  处理：将爸爸和叔叔染成黑色，将爷爷染成红色，并且再以爷爷节点为当前节点，进行下一轮处理</span><br><span class="hljs-comment">     *  |---情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树</span><br><span class="hljs-comment">     * 处理：</span><br><span class="hljs-comment">     *  |---情景4.2.1：插入节点为其父节点的左子节点（LL情况）</span><br><span class="hljs-comment">     *  处理：将父节点染为黑色，将爷爷染为红色，然后以爷爷节点右旋即可</span><br><span class="hljs-comment">     *  |---情景4.2.2：插入节点为其父节点的右子节点（LR情况）</span><br><span class="hljs-comment">     *  处理：将父节点进行一次左旋，得到LL双红情景(4.2.1),然后指定父节点为当前节点进行下一轮处理</span><br><span class="hljs-comment">     *  |---情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树</span><br><span class="hljs-comment">     *  |---情景4.3.1：插入节点为其父节点的右子节点（RR情况）</span><br><span class="hljs-comment">     *  处理：将父节点染为黑色，将爷爷节点染为红色，然后以爷爷节点左旋即可</span><br><span class="hljs-comment">     *  |---情景4.3.2：插入节点为其父节点的左子节点（RL情况）</span><br><span class="hljs-comment">     *  处理：以父节点进行一次右旋，得到RR双红情景(4.3.1),然后指定父节点为当前节点进行下一轮处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFixUp</span><span class="hljs-params">(RBNode node)</span> </span>&#123;<br>        RBNode parent = parentOf(node); <span class="hljs-comment">// 当前节点的父节点</span><br>        RBNode gparent = parentOf(parent); <span class="hljs-comment">// 当前节点的爷爷节点</span><br>        <span class="hljs-comment">// 存在父节点且父节点为红色</span><br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; isRed(parent)) &#123;<br>            <span class="hljs-comment">// 父节点是红色的，那么一定存在爷爷节点(性质2：根节点只能是黑色)</span><br><br>            <span class="hljs-comment">// 父节点为爷爷节点的左子树</span><br>            <span class="hljs-keyword">if</span> (parent == gparent.left) &#123;<br>                RBNode uncle = gparent.right;<br>                <span class="hljs-comment">// 情景4.1：叔叔节点存在，并且为红色（父-叔 双红）</span><br>                <span class="hljs-comment">// 将父和叔染色为黑色，再将爷爷染红，并将爷爷设置为当前节点，进入下一次循环判断</span><br>                <span class="hljs-keyword">if</span> (uncle != <span class="hljs-keyword">null</span> &amp;&amp; isRed(uncle)) &#123;<br>                    setBlack(parent);<br>                    setBlack(uncle);<br>                    setRed(gparent);<br>                    insertFixUp(gparent);<br>                    <span class="hljs-keyword">return</span> ;<br>                &#125;<br><br>                <span class="hljs-comment">// 情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树</span><br>                <span class="hljs-keyword">if</span> (uncle == <span class="hljs-keyword">null</span> || isBlack(uncle)) &#123;<br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 情景4.2.1：插入节点为其父节点的左子节点（LL情况）</span><br><span class="hljs-comment">                     * 处理：将父节点染为黑色，将爷爷染为红色，然后以爷爷节点右旋即可</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 插入节点为其父节点的左子节点（LL情况）=&gt;</span><br>                    <span class="hljs-comment">// 变色（父节点变黑，爷爷节点变红），右旋爷爷节点</span><br>                    <span class="hljs-keyword">if</span> (node == parent.left) &#123;<br>                        setBlack(parent);<br>                        setRed(gparent);<br>                        rightRotate(gparent); <span class="hljs-comment">// 以gparent右旋</span><br>                    &#125;<br><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 情景4.2.2：插入节点为其父节点的右子节点（LR情况）</span><br><span class="hljs-comment">                     * 处理：将父节点进行一次左旋，得到LL双红情景(4.2.1),然后指定父节点为当前节点进行下一轮处理</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 插入节点为其父节点的右子节点（LR情况）=&gt;</span><br>                    <span class="hljs-comment">// 左旋（父节点），当前节点设置为父节点，进入下一次循环</span><br>                    <span class="hljs-keyword">if</span> (node == parent.right) &#123;<br>                        leftRotate(parent); <span class="hljs-comment">// parent左旋</span><br>                        insertFixUp(parent); <span class="hljs-comment">// 进行下一轮处理</span><br>                        <span class="hljs-keyword">return</span> ;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父节点为爷爷节点的右子树</span><br>                RBNode uncle = gparent.left;<br>                <span class="hljs-comment">// 情景4.1：叔叔节点存在，并且为红色（父-叔 双红）</span><br>                <span class="hljs-comment">// 将父和叔染色为黑色，再将爷爷染红，并将爷爷设置为当前节点，进入下一次循环判断</span><br>                <span class="hljs-keyword">if</span> (uncle != <span class="hljs-keyword">null</span> &amp;&amp; isRed(uncle)) &#123;<br>                    setBlack(parent);<br>                    setBlack(uncle);<br>                    setRed(gparent);<br>                    insertFixUp(gparent);<br>                    <span class="hljs-keyword">return</span> ;<br>                &#125;<br><br>                <span class="hljs-comment">// 情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树</span><br>                <span class="hljs-keyword">if</span> (uncle == <span class="hljs-keyword">null</span> || isBlack(uncle)) &#123;<br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 情景4.3.1：插入节点为其父节点的右子节点（RR情况）</span><br><span class="hljs-comment">                     * 处理：将父节点染为黑色，将爷爷节点染为红色，然后以爷爷节点左旋即可</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 插入节点为其父节点的右子节点（RR情况）=&gt;</span><br>                    <span class="hljs-comment">// 变色（父节点变黑，爷爷节点变红），右旋爷爷节点</span><br>                    <span class="hljs-keyword">if</span> (node == parent.right) &#123;<br>                        setBlack(parent);<br>                        setRed(gparent);<br>                        leftRotate(gparent);<br>                    &#125;<br><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 情景4.3.2：插入节点为其父节点的左子节点（RL情况）</span><br><span class="hljs-comment">                     * 处理：以父节点进行一次右旋，得到RR双红情景(4.3.1),然后指定父节点为当前节点进行下一轮处理</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-comment">// 插入节点为其父节点的左子节点（RL情况）</span><br>                    <span class="hljs-comment">// 右旋（父节点）得到RR情况，当前节点设置为父节点，进入下一次循环</span><br>                    <span class="hljs-keyword">if</span> (node == parent.left) &#123;<br>                        rightRotate(parent);<br>                        insertFixUp(parent);<br>                        <span class="hljs-keyword">return</span> ;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        setBlack(<span class="hljs-keyword">this</span>.root);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-TreeOperation-java"><a href="#2-2-TreeOperation-java" class="headerlink" title="2.2 TreeOperation.java"></a>2.2 TreeOperation.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DataStructure.rbtree;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeOperation</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">           树的结构示例：</span><br><span class="hljs-comment">              1</span><br><span class="hljs-comment">            /   \</span><br><span class="hljs-comment">          2       3</span><br><span class="hljs-comment">         / \     / \</span><br><span class="hljs-comment">        4   5   6   7</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于获得树的层数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTreeDepth</span><span class="hljs-params">(RBTree.RBNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : (<span class="hljs-number">1</span> + Math.max(getTreeDepth(root.getLeft()), getTreeDepth(root.getRight())));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将树的值写入数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> currNode</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rowIndex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> columnIndex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> res</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> treeDepth</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeArray</span><span class="hljs-params">(RBTree.RBNode currNode, <span class="hljs-keyword">int</span> rowIndex, <span class="hljs-keyword">int</span> columnIndex, String[][] res, <span class="hljs-keyword">int</span> treeDepth)</span> </span>&#123;<br>        <span class="hljs-comment">// 保证输入的树不为空</span><br>        <span class="hljs-keyword">if</span> (currNode == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">// 先将当前节点保存到二维数组中</span><br>        res[rowIndex][columnIndex] = String.valueOf(currNode.getKey() + <span class="hljs-string">&quot;-&quot;</span> + (currNode.isColor() ? <span class="hljs-string">&quot;R&quot;</span> : <span class="hljs-string">&quot;B&quot;</span>) + <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">// 计算当前位于树的第几层</span><br>        <span class="hljs-keyword">int</span> currLevel = ((rowIndex + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 若到了最后一层，则返回</span><br>        <span class="hljs-keyword">if</span> (currLevel == treeDepth) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">// 计算当前行到下一行，每个元素之间的间隔（下一行的列索引与当前元素的列缩影之间的间隔）</span><br>        <span class="hljs-keyword">int</span> gap = treeDepth - currLevel - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 对左儿子进行判断，若有左儿子，则记录相应的&quot;/&quot;与左儿子的值</span><br>        <span class="hljs-keyword">if</span> (currNode.getLeft() != <span class="hljs-keyword">null</span>) &#123;<br>            res[rowIndex + <span class="hljs-number">1</span>][columnIndex - gap] = <span class="hljs-string">&quot;/&quot;</span>;<br>            writeArray(currNode.getLeft(), rowIndex + <span class="hljs-number">2</span>, columnIndex - gap * <span class="hljs-number">2</span>, res, treeDepth);<br>        &#125;<br><br>        <span class="hljs-comment">// 对右儿子进行判断，若有右儿子，则记录相应的&quot;\&quot;与右儿子的值</span><br>        <span class="hljs-keyword">if</span> (currNode.getRight() != <span class="hljs-keyword">null</span>) &#123;<br>            res[rowIndex + <span class="hljs-number">1</span>][columnIndex + gap] = <span class="hljs-string">&quot;\\&quot;</span>;<br>            writeArray(currNode.getRight(), rowIndex + <span class="hljs-number">2</span>, columnIndex + gap * <span class="hljs-number">2</span>, res, treeDepth);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 展示</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(RBTree.RBNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) System.out.println(<span class="hljs-string">&quot;EMPTY!&quot;</span>);<br>        <span class="hljs-comment">// 得到树的深度</span><br>        <span class="hljs-keyword">int</span> treeDepth = getTreeDepth(root);<br><br>        <span class="hljs-comment">// 最后一行的宽度为2的（n - 1）次方乘3，再加1</span><br>        <span class="hljs-comment">// 作为整个二维数组的宽度</span><br>        <span class="hljs-keyword">int</span> arrayHeight = treeDepth * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> arrayWidth = (<span class="hljs-number">2</span> &lt;&lt; (treeDepth - <span class="hljs-number">2</span>)) * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 用一个字符串数组来存储每个位置应显示的元素</span><br>        String[][] res = <span class="hljs-keyword">new</span> String[arrayHeight][arrayWidth];<br>        <span class="hljs-comment">// 对数组进行初始化，默认为一个空格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayHeight; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arrayWidth; j++) &#123;<br>                res[i][j] = <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 从根节点开始，递归处理整个树</span><br>        <span class="hljs-comment">// res[0][(arrayWidth + 1)/ 2] = (char)(root.val + &#x27;0&#x27;);</span><br>        writeArray(root, <span class="hljs-number">0</span>, arrayWidth / <span class="hljs-number">2</span>, res, treeDepth);<br><br>        <span class="hljs-comment">// 此时，已经将所有需要显示的元素储存到了二维数组中，将其拼接并打印即可</span><br>        <span class="hljs-keyword">for</span> (String[] line : res) &#123;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; line.length; i++) &#123;<br>                sb.append(line[i]);<br>                <span class="hljs-keyword">if</span> (line[i].length() &gt; <span class="hljs-number">1</span> &amp;&amp; i &lt;= line.length - <span class="hljs-number">1</span>) &#123;<br>                    i += line[i].length() &gt; <span class="hljs-number">4</span> ? <span class="hljs-number">2</span> : line[i].length() - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            System.out.println(sb.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-RBTreeTest-java"><a href="#2-3-RBTreeTest-java" class="headerlink" title="2.3 RBTreeTest.java"></a>2.3 RBTreeTest.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DataStructure.rbtree;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBTreeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        RBTree&lt;String, Object&gt; rbtree = <span class="hljs-keyword">new</span> RBTree();<br>        <span class="hljs-comment">//测试输入：ijkgefhdabc</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请输入key:&quot;</span>);<br>            String key = sc.next();<br><br>            rbtree.insert(key, <span class="hljs-keyword">null</span>);<br>            TreeOperation.show(rbtree.getRoot());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-HashMap底层红黑树分析"><a href="#3-HashMap底层红黑树分析" class="headerlink" title="3 HashMap底层红黑树分析"></a>3 HashMap底层红黑树分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        TreeNode&lt;K,V&gt; parent;<span class="hljs-comment">// 父节点</span><br>        TreeNode&lt;K,V&gt; left;<span class="hljs-comment">// 左子树</span><br>        TreeNode&lt;K,V&gt; right;<span class="hljs-comment">// 右子树</span><br>        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        <span class="hljs-keyword">boolean</span> red;<span class="hljs-comment">// 颜色</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 有参构造函数</span><br><span class="hljs-comment">     */</span><br>        TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, val, next);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取红黑树的根节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">root</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 确保给定的根root是树的第一个节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveRootToFront</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;<br>           ...<br>        &#125;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 调用find方法查找.</span><br><span class="hljs-comment">        */</span>        <br>       <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K, V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;<br>            <span class="hljs-comment">// 从树的根节点开始查找</span><br>            <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 从根节点出发查找具有给定哈希值和键的节点.从根节点出发</span><br><span class="hljs-comment">         * 查找当前要插入节点node的父节点</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 经典二叉查找树的查找过程，先根据hash值比较，再根据key值比较决定是查左子树还是右子树。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K, V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;<br>            TreeNode&lt;K, V&gt; p = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">int</span> ph, dir;<br>                K pk;<br>                TreeNode&lt;K, V&gt; pl = p.left, pr = p.right, q;<br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                    <span class="hljs-comment">// 左子树</span><br>                    p = pl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    <span class="hljs-comment">// 右子树</span><br>                    p = pr;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))<br>                    <span class="hljs-comment">// 找到了直接返回</span><br>                    <span class="hljs-keyword">return</span> p;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">// hash相同但key不同，左子树为空查右子树</span><br>                    p = pr;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">// 右子树为空查左子树</span><br>                    p = pl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc != <span class="hljs-keyword">null</span> ||<br>                        (kc = comparableClassFor(k)) != <span class="hljs-keyword">null</span>) &amp;&amp;<br>                        (dir = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">// 通过compare方法比较key值的大小决定使用左子树还是右子树</span><br>                    p = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">// 如果以上条件都不通过，则尝试在右子树查找</span><br>                    <span class="hljs-keyword">return</span> q;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 都没找到就在左子树查找</span><br>                    p = pl;<br>            &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用于在a 和 b 的hash值相等且不可比较时对插入进行排序</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tieBreakOrder</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br>           ...<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 对链表进行树化的方法</span><br><span class="hljs-comment">         *（1）从链表的第一个元素开始遍历；</span><br><span class="hljs-comment">*（2）将第一个元素作为根节点；</span><br><span class="hljs-comment">*（3）其它元素依次插入到红黑树中，再做平衡；</span><br><span class="hljs-comment">*（4）将根节点移到链表第一元素的位置（因为平衡的时候根节点会改变）；</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K, V&gt;[] tab)</span> </span>&#123;<br>            TreeNode&lt;K, V&gt; root = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K, V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;<br>                next = (TreeNode&lt;K, V&gt;) x.next;<br>                x.left = x.right = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 第一个元素作为根节点且为黑节点，其它元素依次插入到树中再做平衡</span><br>                <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>                    x.parent = <span class="hljs-keyword">null</span>;<br>                    x.red = <span class="hljs-keyword">false</span>;<br>                    root = x;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    K k = x.key;<br>                    <span class="hljs-keyword">int</span> h = x.hash;<br>                    Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-comment">// 从根节点查找元素插入的位置</span><br>                    <span class="hljs-keyword">for</span> (TreeNode&lt;K, V&gt; p = root; ; ) &#123;<br>                        <span class="hljs-keyword">int</span> dir, ph;<br>                        K pk = p.key;<br>                        <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                            dir = -<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                            dir = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                                (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>                            dir = tieBreakOrder(k, pk);<br><br>                        <span class="hljs-comment">// 如果最后没找到元素，则插入</span><br>                        TreeNode&lt;K, V&gt; xp = p;<br>                        <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>                            x.parent = xp;<br>                            <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                                xp.left = x;<br>                            <span class="hljs-keyword">else</span><br>                                xp.right = x;<br>                            <span class="hljs-comment">// 插入后平衡，默认插入的是红节点，在balanceInsertion()方法里</span><br>                            root = balanceInsertion(root, x);<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 把根节点移动到链表的头节点，因为经过平衡之后原来的第一个元素不一定是根节点了</span><br>            moveRootToFront(tab, root);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 对红黑树进行反树化的方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">untreeify</span><span class="hljs-params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;<br>            Node&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; q = <span class="hljs-keyword">this</span>; q != <span class="hljs-keyword">null</span>; q = q.next) &#123;<br>                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                    hd = p;<br>                <span class="hljs-keyword">else</span><br>                    tl.next = p;<br>                tl = p;<br>            &#125;<br>            <span class="hljs-keyword">return</span> hd;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 向树种插入数据的方法</span><br><span class="hljs-comment">         *（1）寻找根节点；</span><br><span class="hljs-comment">         *（2）从根节点开始查找；</span><br><span class="hljs-comment">         *（3）比较hash值及key值，如果都相同，直接返回，在putVal()方法中决定是否要替换value值；</span><br><span class="hljs-comment">         *（4）根据hash值及key值确定在树的左子树还是右子树查找，找到了直接返回；</span><br><span class="hljs-comment">         *（5）如果最后没有找到则在树的相应位置插入元素，并做平衡；</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K, V&gt; <span class="hljs-title">putTreeVal</span><span class="hljs-params">(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> h, K k, V v)</span> </span>&#123;<br>            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 标记是否找到这个key的节点</span><br>            <span class="hljs-keyword">boolean</span> searched = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 找到树的根节点</span><br>            TreeNode&lt;K, V&gt; root = (parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>;<br>            <span class="hljs-comment">// 从树的根节点开始遍历</span><br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K, V&gt; p = root; ; ) &#123;<br>                <span class="hljs-comment">// dir=direction，标记是在左边还是右边</span><br>                <span class="hljs-comment">// ph=p.hash，当前节点的hash值</span><br>                <span class="hljs-keyword">int</span> dir, ph;<br>                <span class="hljs-comment">// pk=p.key，当前节点的key值</span><br>                K pk;<br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h) &#123;<br>                    <span class="hljs-comment">// 当前hash比目标hash大，说明在左边</span><br>                    dir = -<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    <span class="hljs-comment">// 当前hash比目标hash小，说明在右边</span><br>                    dir = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))<br>                    <span class="hljs-comment">// 两者hash相同且key相等，说明找到了节点，直接返回该节点</span><br>                    <span class="hljs-comment">// 回到putVal()中判断是否需要修改其value值</span><br>                    <span class="hljs-keyword">return</span> p;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;<br>                        <span class="hljs-comment">// 如果k是Comparable的子类则返回其真实的类，否则返回null</span><br>                        (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                        <span class="hljs-comment">// 如果k和pk不是同样的类型则返回0，否则返回两者比较的结果</span><br>                        (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 这个条件表示两者hash相同但是其中一个不是Comparable类型或者两者类型不同</span><br>                    <span class="hljs-comment">// 比如key是Object类型，这时可以传String也可以传Integer，两者hash值可能相同</span><br>                    <span class="hljs-comment">// 在红黑树中把同样hash值的元素存储在同一颗子树，这里相当于找到了这颗子树的顶点</span><br>                    <span class="hljs-comment">// 从这个顶点分别遍历其左右子树去寻找有没有跟待插入的key相同的元素</span><br>                    <span class="hljs-keyword">if</span> (!searched) &#123;<br>                        TreeNode&lt;K, V&gt; q, ch;<br>                        searched = <span class="hljs-keyword">true</span>;<br>                        <span class="hljs-comment">// 遍历左右子树找到了直接返回</span><br>                        <span class="hljs-keyword">if</span> (((ch = p.left) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (q = ch.find(h, k, kc)) != <span class="hljs-keyword">null</span>) ||<br>                                ((ch = p.right) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                        (q = ch.find(h, k, kc)) != <span class="hljs-keyword">null</span>))<br>                            <span class="hljs-keyword">return</span> q;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果两者类型相同，再根据它们的内存地址计算hash值进行比较</span><br>                    dir = tieBreakOrder(k, pk);<br>                &#125;<br><br>                TreeNode&lt;K, V&gt; xp = p;<br>                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果最后确实没找到对应key的元素，则新建一个节点</span><br>                    Node&lt;K, V&gt; xpn = xp.next;<br>                    TreeNode&lt;K, V&gt; x = map.newTreeNode(h, k, v, xpn);<br>                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                        xp.left = x;<br>                    <span class="hljs-keyword">else</span><br>                        xp.right = x;<br>                    xp.next = x;<br>                    x.parent = x.prev = xp;<br>                    <span class="hljs-keyword">if</span> (xpn != <span class="hljs-keyword">null</span>)<br>                        ((TreeNode&lt;K, V&gt;) xpn).prev = x;<br>                    <span class="hljs-comment">// 插入树节点后平衡</span><br>                    <span class="hljs-comment">// 把root节点移动到链表的第一个节点</span><br>                    moveRootToFront(tab, balanceInsertion(root, x));<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// remove 调用 removeNode</span><br>        <span class="hljs-comment">//public V remove(Object key) &#123;</span><br>        <span class="hljs-comment">//    Node&lt;K, V&gt; e;</span><br>        <span class="hljs-comment">//    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br>        <span class="hljs-comment">//            null : e.value;</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        <br>        <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K, V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>            Node&lt;K, V&gt;[] tab;<br>            Node&lt;K, V&gt; p;<br>            <span class="hljs-keyword">int</span> n, index;<br>            <span class="hljs-comment">// 如果桶的数量大于0且待删除的元素所在的桶的第一个元素不为空</span><br>            <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                    (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>                Node&lt;K, V&gt; node = <span class="hljs-keyword">null</span>, e;<br>                K k;<br>                V v;<br>                <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                        ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 如果第一个元素正好就是要找的元素，赋值给node变量后续删除使用</span><br>                    node = p;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        <span class="hljs-comment">// 如果第一个元素是树节点，则以树的方式查找节点</span><br>                        node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 否则遍历整个链表查找元素</span><br>                        <span class="hljs-keyword">do</span> &#123;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                    ((k = e.key) == key ||<br>                                            (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                                node = e;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            p = e;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果找到了元素，则看参数是否需要匹配value值，如果不需要匹配直接删除，</span><br>                <span class="hljs-comment">// 如果需要匹配则看value值是否与传入的value相等</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                        (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>                    <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        <span class="hljs-comment">// 如果是树节点，调用树的删除方法（以node调用的，是删除自己）</span><br>                        ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                        <span class="hljs-comment">// 如果待删除的元素是第一个元素，则把第二个元素移到第一的位置</span><br>                        tab[index] = node.next;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-comment">// 否则删除node节点</span><br>                        p.next = node.next;<br>                    ++modCount;<br>                    --size;<br>                    <span class="hljs-comment">// 删除节点后置处理</span><br>                    afterNodeRemoval(node);<br>                    <span class="hljs-keyword">return</span> node;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">*（1）先查找元素所在的节点；</span><br><span class="hljs-comment">*（2）如果找到的节点是树节点，则按树的移除节点处理；</span><br><span class="hljs-comment">     *（3）如果找到的节点是桶中的第一个节点，则把第二个节点移到第一的位置；</span><br><span class="hljs-comment">     *（4）否则按链表删除节点处理；</span><br><span class="hljs-comment">     *（5）修改size，调用移除节点后置处理等；</span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> n;<br>            <span class="hljs-comment">// 如果桶的数量为0直接返回</span><br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-comment">// 节点在桶中的索引</span><br>            <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; hash;<br>            <span class="hljs-comment">// 第一个节点，根节点，根左子节点</span><br>            TreeNode&lt;K, V&gt; first = (TreeNode&lt;K, V&gt;) tab[index], root = first, rl;<br>            <span class="hljs-comment">// 后继节点，前置节点</span><br>            TreeNode&lt;K, V&gt; succ = (TreeNode&lt;K, V&gt;) next, pred = prev;<br><br>            <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">// 如果前置节点为空，说明当前节点是根节点，则把后继节点赋值到第一个节点的位置，相当于删除了当前节点</span><br>                tab[index] = first = succ;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 否则把前置节点的下个节点设置为当前节点的后继节点，相当于删除了当前节点</span><br>                pred.next = succ;<br><br>            <span class="hljs-comment">// 如果后继节点不为空，则让后继节点的前置节点指向当前节点的前置节点，相当于删除了当前节点</span><br>            <span class="hljs-keyword">if</span> (succ != <span class="hljs-keyword">null</span>)<br>                succ.prev = pred;<br><br>            <span class="hljs-comment">// 如果第一个节点为空，说明没有后继节点了，直接返回</span><br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// 如果根节点的父节点不为空，则重新查找父节点</span><br>            <span class="hljs-keyword">if</span> (root.parent != <span class="hljs-keyword">null</span>)<br>                root = root.root();<br><br>            <span class="hljs-comment">// 如果根节点为空，则需要反树化（将树转化为链表）</span><br>            <span class="hljs-comment">// 如果需要移动节点且树的高度比较小，则需要反树化</span><br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span><br>                    || (movable<br>                    &amp;&amp; (root.right == <span class="hljs-keyword">null</span><br>                    || (rl = root.left) == <span class="hljs-keyword">null</span><br>                    || rl.left == <span class="hljs-keyword">null</span>))) &#123;<br>                tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 分割线，以上都是删除链表中的节点，下面才是直接删除红黑树的节点（因为TreeNode本身即是链表节点又是树节点）</span><br><br>            <span class="hljs-comment">// 删除红黑树节点的大致过程是寻找右子树中最小的节点放到删除节点的位置，然后做平衡，此处不过多注释</span><br>            TreeNode&lt;K, V&gt; p = <span class="hljs-keyword">this</span>, pl = left, pr = right, replacement;<br>            <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span> &amp;&amp; pr != <span class="hljs-keyword">null</span>) &#123;<br>                TreeNode&lt;K, V&gt; s = pr, sl;<br>                <span class="hljs-keyword">while</span> ((sl = s.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// find successor</span><br>                    s = sl;<br>                <span class="hljs-keyword">boolean</span> c = s.red;<br>                s.red = p.red;<br>                p.red = c; <span class="hljs-comment">// swap colors</span><br>                TreeNode&lt;K, V&gt; sr = s.right;<br>                TreeNode&lt;K, V&gt; pp = p.parent;<br>                <span class="hljs-keyword">if</span> (s == pr) &#123; <span class="hljs-comment">// p was s&#x27;s direct parent</span><br>                    p.parent = s;<br>                    s.right = p;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    TreeNode&lt;K, V&gt; sp = s.parent;<br>                    <span class="hljs-keyword">if</span> ((p.parent = sp) != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (s == sp.left)<br>                            sp.left = p;<br>                        <span class="hljs-keyword">else</span><br>                            sp.right = p;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> ((s.right = pr) != <span class="hljs-keyword">null</span>)<br>                        pr.parent = s;<br>                &#125;<br>                p.left = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> ((p.right = sr) != <span class="hljs-keyword">null</span>)<br>                    sr.parent = p;<br>                <span class="hljs-keyword">if</span> ((s.left = pl) != <span class="hljs-keyword">null</span>)<br>                    pl.parent = s;<br>                <span class="hljs-keyword">if</span> ((s.parent = pp) == <span class="hljs-keyword">null</span>)<br>                    root = s;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>                    pp.left = s;<br>                <span class="hljs-keyword">else</span><br>                    pp.right = s;<br>                <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>                    replacement = sr;<br>                <span class="hljs-keyword">else</span><br>                    replacement = p;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span>)<br>                replacement = pl;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr != <span class="hljs-keyword">null</span>)<br>                replacement = pr;<br>            <span class="hljs-keyword">else</span><br>                replacement = p;<br>            <span class="hljs-keyword">if</span> (replacement != p) &#123;<br>                TreeNode&lt;K, V&gt; pp = replacement.parent = p.parent;<br>                <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>)<br>                    root = replacement;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>                    pp.left = replacement;<br>                <span class="hljs-keyword">else</span><br>                    pp.right = replacement;<br>                p.left = p.right = p.parent = <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            TreeNode&lt;K, V&gt; r = p.red ? root : balanceDeletion(root, replacement);<br><br>            <span class="hljs-keyword">if</span> (replacement == p) &#123;  <span class="hljs-comment">// detach</span><br>                TreeNode&lt;K, V&gt; pp = p.parent;<br>                p.parent = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (pp != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (p == pp.left)<br>                        pp.left = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.right)<br>                        pp.right = <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (movable)<br>                moveRootToFront(tab, r);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;<br>           ...<br>        &#125;<br><br>        <span class="hljs-comment">// 左旋</span><br>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">rotateLeft</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;<br>            TreeNode&lt;K,V&gt; r, pp, rl;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; (r = p.right) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((rl = p.right = r.left) != <span class="hljs-keyword">null</span>)<br>                    rl.parent = p;<br>                <span class="hljs-keyword">if</span> ((pp = r.parent = p.parent) == <span class="hljs-keyword">null</span>)<br>                    (root = r).red = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p)<br>                    pp.left = r;<br>                <span class="hljs-keyword">else</span><br>                    pp.right = r;<br>                r.left = p;<br>                p.parent = r;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">// 右旋</span><br>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">rotateRight</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;<br>            TreeNode&lt;K,V&gt; l, pp, lr;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; (l = p.left) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((lr = p.left = l.right) != <span class="hljs-keyword">null</span>)<br>                    lr.parent = p;<br>                <span class="hljs-keyword">if</span> ((pp = l.parent = p.parent) == <span class="hljs-keyword">null</span>)<br>                    (root = l).red = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.right == p)<br>                    pp.right = l;<br>                <span class="hljs-keyword">else</span><br>                    pp.left = l;<br>                l.right = p;<br>                p.parent = l;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">// 修复红黑树平衡的方法</span><br>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>            x.red = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;<br>                <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>                    x.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> x;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> root;<br>                <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;<br>                    <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;<br>                        xppr.red = <span class="hljs-keyword">false</span>;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        x = xpp;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (x == xp.right) &#123;<br>                            root = rotateLeft(root, x = xp);<br>                            xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                            xp.red = <span class="hljs-keyword">false</span>;<br>                            <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                                xpp.red = <span class="hljs-keyword">true</span>;<br>                                root = rotateRight(root, xpp);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;<br>                        xppl.red = <span class="hljs-keyword">false</span>;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        x = xpp;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (x == xp.left) &#123;<br>                            root = rotateRight(root, x = xp);<br>                            xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                            xp.red = <span class="hljs-keyword">false</span>;<br>                            <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                                xpp.red = <span class="hljs-keyword">true</span>;<br>                                root = rotateLeft(root, xpp);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceDeletion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;<br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span> || x == root)<br>                    <span class="hljs-keyword">return</span> root;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>                    x.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> x;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.red) &#123;<br>                    x.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> root;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xpl = xp.left) == x) &#123;<br>                    <span class="hljs-keyword">if</span> ((xpr = xp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xpr.red) &#123;<br>                        xpr.red = <span class="hljs-keyword">false</span>;<br>                        xp.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateLeft(root, xp);<br>                        xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.right;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xpr == <span class="hljs-keyword">null</span>)<br>                        x = xp;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;<br>                        <span class="hljs-keyword">if</span> ((sr == <span class="hljs-keyword">null</span> || !sr.red) &amp;&amp;<br>                            (sl == <span class="hljs-keyword">null</span> || !sl.red)) &#123;<br>                            xpr.red = <span class="hljs-keyword">true</span>;<br>                            x = xp;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (sr == <span class="hljs-keyword">null</span> || !sr.red) &#123;<br>                                <span class="hljs-keyword">if</span> (sl != <span class="hljs-keyword">null</span>)<br>                                    sl.red = <span class="hljs-keyword">false</span>;<br>                                xpr.red = <span class="hljs-keyword">true</span>;<br>                                root = rotateRight(root, xpr);<br>                                xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                                    <span class="hljs-keyword">null</span> : xp.right;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (xpr != <span class="hljs-keyword">null</span>) &#123;<br>                                xpr.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                                <span class="hljs-keyword">if</span> ((sr = xpr.right) != <span class="hljs-keyword">null</span>)<br>                                    sr.red = <span class="hljs-keyword">false</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                                xp.red = <span class="hljs-keyword">false</span>;<br>                                root = rotateLeft(root, xp);<br>                            &#125;<br>                            x = root;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// symmetric</span><br>                    <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span> &amp;&amp; xpl.red) &#123;<br>                        xpl.red = <span class="hljs-keyword">false</span>;<br>                        xp.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateRight(root, xp);<br>                        xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.left;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xpl == <span class="hljs-keyword">null</span>)<br>                        x = xp;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;<br>                        <span class="hljs-keyword">if</span> ((sl == <span class="hljs-keyword">null</span> || !sl.red) &amp;&amp;<br>                            (sr == <span class="hljs-keyword">null</span> || !sr.red)) &#123;<br>                            xpl.red = <span class="hljs-keyword">true</span>;<br>                            x = xp;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (sl == <span class="hljs-keyword">null</span> || !sl.red) &#123;<br>                                <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>                                    sr.red = <span class="hljs-keyword">false</span>;<br>                                xpl.red = <span class="hljs-keyword">true</span>;<br>                                root = rotateLeft(root, xpl);<br>                                xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                                    <span class="hljs-keyword">null</span> : xp.left;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span>) &#123;<br>                                xpl.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                                <span class="hljs-keyword">if</span> ((sl = xpl.left) != <span class="hljs-keyword">null</span>)<br>                                    sl.red = <span class="hljs-keyword">false</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                                xp.red = <span class="hljs-keyword">false</span>;<br>                                root = rotateRight(root, xp);<br>                            &#125;<br>                            x = root;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Recursive invariant check</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInvariants</span><span class="hljs-params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;<br>            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,<br>                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;<br>            <span class="hljs-keyword">if</span> (tb != <span class="hljs-keyword">null</span> &amp;&amp; tb.next != t)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (tn != <span class="hljs-keyword">null</span> &amp;&amp; tn.prev != t)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (tp != <span class="hljs-keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (tl != <span class="hljs-keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (tr != <span class="hljs-keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (t.red &amp;&amp; tl != <span class="hljs-keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="hljs-keyword">null</span> &amp;&amp; tr.red)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (tl != <span class="hljs-keyword">null</span> &amp;&amp; !checkInvariants(tl))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (tr != <span class="hljs-keyword">null</span> &amp;&amp; !checkInvariants(tr))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="将链表转换为红黑树-treeifyBin"><a href="#将链表转换为红黑树-treeifyBin" class="headerlink" title="将链表转换为红黑树 treeifyBin()"></a>将链表转换为红黑树 treeifyBin()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。</span><br><span class="hljs-comment">Node&lt;K,V&gt;[] tab = tab 数组名</span><br><span class="hljs-comment">int hash = hash表示哈希值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，</span><br><span class="hljs-comment">    就去扩容。而不是将结点变为红黑树。</span><br><span class="hljs-comment">    目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，</span><br><span class="hljs-comment">    那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">//扩容方法</span><br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化</span><br><span class="hljs-comment">        2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e，</span><br><span class="hljs-comment">        e是哈希表中指定位置桶里的链表结点，从第一个开始</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// hd：红黑树的头结点   tl：红黑树的尾结点</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 新创建一个树的结点，内容和当前链表结点e一致</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                hd = p; <span class="hljs-comment">// 将新创键的p结点赋值给红黑树的头结点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl; <span class="hljs-comment">// 将上一个结点p赋值给现在的p的前一个结点</span><br>                tl.next = p; <span class="hljs-comment">// 将现在结点p作为树的尾结点的下一个结点</span><br>            &#125;<br>            tl = p;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null</span><br><span class="hljs-comment">            则回到上面继续取出链表中结点转换为红黑树</span><br><span class="hljs-comment">            */</span><br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树</span><br><span class="hljs-comment">        而不是链表数据结构了</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_43591980/article/details/109580974?ops_request_misc=%7B%22request_id%22:%22164498014916781685356713%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=164498014916781685356713&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-109580974.nonecase&utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1018.2226.3001.4450">(110条消息) HashMap底层红黑树实现(自己实现一个简单的红黑树)</a></p><p><a href="https://www.jianshu.com/p/9df4d2ff6807">JDK源码阅读之Entry - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="/2022/02/10/%E6%A1%86%E6%9E%B6/Spring/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/02/10/%E6%A1%86%E6%9E%B6/Spring/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    Bean是由Spring IoC容器实例化，组装和管理的对象，并且Spring Bean的生命周期完全由容器控制。这里所说的生命周期主要是指<code>singleton bean</code>，对于<code>prototype</code>的<code>bean</code>，Spring在创建好交给使用者后将不会管理后续的生命周期。</p><p>​    对于Spring Bean的生命周期，本文将会从以下两部分将：</p><ul><li>生命周期的概要流程</li><li>扩展点的作用</li></ul><h2 id="2-Bean生命周期概述"><a href="#2-Bean生命周期概述" class="headerlink" title="2 Bean生命周期概述"></a>2 Bean生命周期概述</h2><p>​    我们知道对于普通的Java对象来说，它们的生命周期是：</p><ul><li>创建阶段(Created)</li><li>应用阶段(In Use)</li><li>不可见阶段(Invisible)</li><li>不可达阶段(Unreachable)</li><li>收集阶段(Collected)</li><li>终结阶段(Finalized)</li><li>对象空间重分配阶段(De-allocated)</li></ul><p>​    而对于Spring Bean来说，可以概述为4个阶段：</p><ol><li>实例化（Instantiation）</li><li>属性赋值（Populate）</li><li>初始化（Initialization）</li><li>销毁（Destruction）</li></ol><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220210215127504.png" alt="Bean生命周期"></p><p>从图中分析</p><ol><li>实例化：第1步，实例化一个bean对象</li><li>属性赋值：第2步，为bean对象设置相关属性和依赖</li><li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</li><li>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</li></ol><p>​    下面结合代码来直观的看下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;<br><br>    <span class="hljs-comment">// 1. 实例化</span><br>    BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;<br>        instanceWrapper = createBeanInstance(beanName, mbd, args);<br>    &#125;<br>    <br>    Object exposedObject = bean;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2. 属性赋值</span><br>        populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 3. 初始化</span><br>        exposedObject = initializeBean(beanName, exposedObject, mbd);<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 销毁-注册回调接口</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    由于初始化较复杂，包含了第3~7步，所以我们进到 initializeBean() 方法里具体看下其过程（注释的序号对应图中序号）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;<br>    <span class="hljs-comment">// 3. 检查 Aware 相关接口并设置相关依赖</span><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;, getAccessControlContext());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br><br>    <span class="hljs-comment">// 4. BeanPostProcessor 前置处理</span><br>    Object wrappedBean = bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br>    <span class="hljs-comment">// 6. 若配置自定义的 init-method方法，则执行</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>            (mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>),<br>            beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-comment">// 7. BeanPostProceesor 后置处理</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在 invokInitMethods() 方法中会检查 InitializingBean 接口和 init-method 方法</p><p>​    销毁的过程也与其类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DisposableBeanAdapter.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 9. 若实现 DisposableBean 接口，则执行 destory()方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.invokeDisposableBean) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br>                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;<br>                    ((DisposableBean) <span class="hljs-keyword">this</span>.bean).destroy();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;, <span class="hljs-keyword">this</span>.acc);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ((DisposableBean) <span class="hljs-keyword">this</span>.bean).destroy();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// 10. 若配置自定义的 detory-method 方法，则执行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethod != <span class="hljs-keyword">null</span>) &#123;<br>        invokeCustomDestroyMethod(<span class="hljs-keyword">this</span>.destroyMethod);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethodName != <span class="hljs-keyword">null</span>) &#123;<br>        Method methodToInvoke = determineDestroyMethod(<span class="hljs-keyword">this</span>.destroyMethodName);<br>        <span class="hljs-keyword">if</span> (methodToInvoke != <span class="hljs-keyword">null</span>) &#123;<br>            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>​    这里额外说一下为什么JVM类加载是初始化再实例化，而Spring Bean是先实例化再初始化，有什么不同？（刚开始困扰了一会儿QAQ）</p><p>​    首先，要明确。类加载是JVM的基本过程，而Spring是在其上层的实现，这两个不在同个层次</p><p>​    在JVM中，初始化是在类级别的，主要功能是为静态成员赋值，执行静态代码块，执行&lt;clinit&gt;方法。实例化是指在堆区分配空间，执行<code>实例对象初始化</code>，设置引用变量指向刚分配的内存地址（注意实例化也有一个初始化，这次初始化就会调用构造函数了，这是实例对象级别的）</p><p>​    在Spring中，实例化就是创造出一个bean对象了，包含了JVM的初始化和实例化；初始化就是给对象中的属性赋值，相当于人为操作。</p></blockquote><h2 id="3-扩展点的作用"><a href="#3-扩展点的作用" class="headerlink" title="3 扩展点的作用"></a>3 扩展点的作用</h2><h3 id="3-1-Aware接口"><a href="#3-1-Aware接口" class="headerlink" title="3.1 Aware接口"></a>3.1 Aware接口</h3><p>​    若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以<strong>通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源</strong>。</p><p>Spring 中提供的 Aware 接口有：</p><ol><li>BeanNameAware：注入当前 bean 对应 beanName；</li><li>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；</li><li>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</li></ol><p>其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutowireCapableBeanFactory.java</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>            ((BeanNameAware) bean).setBeanName(beanName);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br>            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。</p><ol><li>EnvironmentAware：注入 Enviroment，一般用于获取配置属性；</li><li>EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析；</li><li>ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ApplicationContextAwareProcessor.java</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware) &#123;<br>        ((EnvironmentAware)bean).setEnvironment(<span class="hljs-keyword">this</span>.applicationContext.getEnvironment());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware) &#123;<br>        ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(<span class="hljs-keyword">this</span>.embeddedValueResolver);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware) &#123;<br>        ((ResourceLoaderAware)bean).setResourceLoader(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware) &#123;<br>        ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> MessageSourceAware) &#123;<br>        ((MessageSourceAware)bean).setMessageSource(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware) &#123;<br>        ((ApplicationContextAware)bean).setApplicationContext(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-容器级的方法（BeanPostProcessor-一系列接口）"><a href="#3-2-容器级的方法（BeanPostProcessor-一系列接口）" class="headerlink" title="3.2 容器级的方法（BeanPostProcessor 一系列接口）"></a>3.2 容器级的方法（BeanPostProcessor 一系列接口）</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220211071606228.png" alt="image-20220211071606228"></p><h4 id="3-2-1-InstantiationAwareBeanPostProcessor-源码分析"><a href="#3-2-1-InstantiationAwareBeanPostProcessor-源码分析" class="headerlink" title="3.2.1 InstantiationAwareBeanPostProcessor 源码分析"></a>3.2.1 InstantiationAwareBeanPostProcessor 源码分析</h4><p>​    从源码中发现<code>InstantiationAwareBeanPostProcessor </code>是继承了 <code>BeanPostProcessor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config;<br><br><span class="hljs-keyword">import</span> java.beans.PropertyDescriptor;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.PropertyValues;<br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> PropertyValues <span class="hljs-title">postProcessPropertyValues</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br><span class="hljs-keyword">return</span> pvs;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 调用点</p><blockquote><p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：<br>InstantiationAwareBeanPostProcessor接口中的postProcessBeforeInstantiation，在实例化之前调用。<br>BeanPostProcessor接口中的postProcessAfterInitialization，在实例化之后调用。</p></blockquote><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220211072240463.png" alt="image-20220211072240463"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">org.spring framework.beans . factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation</span><br><span class="hljs-comment">作用：在实例化之前解析是否有快捷创建的Bean，既是通过postProcessBeforeInstantiation返回的Bean</span><br><span class="hljs-comment">内部调用两个重要的方法:</span><br><span class="hljs-comment">1. applyBeanPostProcessorsBeforeInstantiation:</span><br><span class="hljs-comment">内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用J</span><br><span class="hljs-comment">2. applyBeanPostProcessorsAfterInitialization:</span><br><span class="hljs-comment">如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;<br>    Object bean = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br>        <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span><br>        <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);<br>            <span class="hljs-keyword">if</span> (targetType != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 调用方法，内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】</span><br>                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<br>                <span class="hljs-comment">// 如果返回了快捷的Bean</span><br>                <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//如果postProcessBeforeInstantiation方法返回了快捷的Bean，</span><br>                    <span class="hljs-comment">// 内部遍历调用 postProcessBeforeInstantiation方法【在初始化之后调用】</span><br>                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>        mbd.beforeInstantiationResolved = (bean != <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>applyBeanPostProcessorsBeforeInstantiation</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">将 InstantiationAwareBeanPostProcessors 应用于指定的 bean 定义（按类和名称），</span><br><span class="hljs-comment">调用它们的 postProcessBeforeInstantiation 方法。任何返回的对象都将用作 bean，</span><br><span class="hljs-comment">而不是实际实例化目标 bean。来自后处理器的空返回值将导致目标 bean 被实例化。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// getBeanPostProcessorCache返回预过滤后处理器的内部缓存，如有必要，重新（重新）构建它。</span><br>    <span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>        Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>applyBeanPostProcessorsAfterInitialization</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">作用:遍历调用postProcessAfterInitialization</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    Object result = existingBean;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        Object current = processor.postProcessAfterInitialization(result, beanName);<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code> 调用点</p><blockquote><p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>正常情况下在实例化之后在执行populateBean之前调用<br>返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的postProcessPropertyValues将不会执行,但是初始化和BeanPostProcessor的仍然会执行。</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bw == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Skip property population phase for null instance.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span><br>    <span class="hljs-comment">// state of the bean before properties are set. This can be used, for example,</span><br>    <span class="hljs-comment">// to support styles of field injection.</span><br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br><span class="hljs-comment">// 执行postProcessAfterInstantiation方法</span><br>            <span class="hljs-keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>                <span class="hljs-comment">// 返回结果为false，那么赋值continuewithPropertyPopulation=false，表示不继续执行属性填充</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-2-2-BeanPostProcessor-源码分析"><a href="#3-2-2-BeanPostProcessor-源码分析" class="headerlink" title="3.2.2 BeanPostProcessor 源码分析"></a>3.2.2 BeanPostProcessor 源码分析</h4><p>​    initializeBean是该接口源码的入口</p><p>​    进入初始化接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            invokeAwareMethods(beanName, bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;, getAccessControlContext());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br><br>    Object wrappedBean = bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<br>        <span class="hljs-comment">// 初始化前执行的方法</span><br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>            (mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>),<br>            beanName, <span class="hljs-string">&quot;Invocation of init method failed&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<br>        <span class="hljs-comment">// 初始化后执行的方法</span><br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    Object result = existingBean;<br>    <span class="hljs-comment">// 1. 获取到所有的后置处理器 getBeanPostProcessors()</span><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 2. 调用后置处理器的方法</span><br>        Object current = processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>  ​    进入postProcessBeforeInitialization方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> EnvironmentAware || bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware ||<br>          bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware || bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware ||<br>          bean <span class="hljs-keyword">instanceof</span> MessageSourceAware || bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware ||<br>          bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    AccessControlContext acc = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br>        acc = <span class="hljs-keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (acc != <span class="hljs-keyword">null</span>) &#123;<br>        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>            invokeAwareInterfaces(bean);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;, acc);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        invokeAwareInterfaces(bean);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware) &#123;<br>        ((EnvironmentAware) bean).setEnvironment(<span class="hljs-keyword">this</span>.applicationContext.getEnvironment());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware) &#123;<br>        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="hljs-keyword">this</span>.embeddedValueResolver);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware) &#123;<br>        ((ResourceLoaderAware) bean).setResourceLoader(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware) &#123;<br>        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> MessageSourceAware) &#123;<br>        ((MessageSourceAware) bean).setMessageSource(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware) &#123;<br>        ((ApplicationStartupAware) bean).setApplicationStartup(<span class="hljs-keyword">this</span>.applicationContext.getApplicationStartup());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware) &#123;<br>        ((ApplicationContextAware) bean).setApplicationContext(<span class="hljs-keyword">this</span>.applicationContext);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  ​    <code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code> 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 <code>invokeAwareInterfaces(bean)</code>，向容器中添加相关接口的上下文环境。</p></li></ul><h3 id="3-3-InitializingBean-和-init-method"><a href="#3-3-InitializingBean-和-init-method" class="headerlink" title="3.3 InitializingBean 和 init-method"></a>3.3 InitializingBean 和 init-method</h3><p>InitializingBean 和 init-method 是 Spring 为 <strong>bean 初始化</strong>提供的扩展点。</p><p>InitializingBean接口 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InitializingBean</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 afterPropertiesSet() 方法写初始化逻辑。</p><p>指定 init-method 方法，指定初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;demo&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.w1nd.Demo&quot;</span> init-method=<span class="hljs-string">&quot;init()&quot;</span>/&gt;<br>    <br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>DisposableBean 和 destory-method 与上述类似，就不描述了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>​    最后总结下如何记忆 Spring Bean 的生命周期：</p><ul><li>首先是实例化、属性赋值、初始化、销毁这 4 个大阶段；</li><li>再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；</li><li>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</li></ul><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/2131.png" alt="Bean生命周期"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904065457979405">如何记忆 Spring Bean 的生命周期 - 掘金 (juejin.cn)</a></p><p><a href="https://segmentfault.com/a/1190000040365130">一文读懂 Spring Bean 的生命周期 - SegmentFault 思否</a></p><p><a href="https://blog.csdn.net/qq_34869990/article/details/108554013">(104条消息) JVM类 和 spring Bean 的实例化 和 初始化区别以及顺序_秋楓的博客-CSDN博客_spring实例化和初始化的区别</a></p><p><a href="https://www.cnblogs.com/pu20065226/p/12206463.html">java类的初始化和实例化区别 - pu20065226 - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/6844903682673229831">聊聊spring的那些扩展机制 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring源码阅读（一）</title>
    <link href="/2022/02/08/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/02/08/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>​    阅读源码可以帮助提高debug能力以及更加熟悉该框架的原理与构建方式，学习大师的思维。本系列文章将会通过阅读Spring源码，尽力分析各个函数，类，接口等的实现方式与原理，来让自己更加深刻理解这一框架。</p><p>​    首先，我们要知道，Spring是一个生态体系，其中包含了Spring Framework, Spring Boot, Spring Cloud等，一般说的Spring源码是指Spring Framework中的。</p><p>​    而在Spring Framework中，又会有许多模块所组成</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220208151428460.png" alt="Spring架构图"></p><p>一共有以下20多个不同的模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">spring-aop      spring-context-indexer  spring-instrument  spring-orm    spring-web<br>spring-aspects  spring-context-support  spring-jcl         spring-oxm    spring-webflux<br>spring-beans    spring-core             spring-jdbc        spring-r2dbc  spring-webmvc<br>spring-context  spring-expression       spring-jms         spring-test   spring-websocket<br>spring-messaging   spring-tx  <br></code></pre></td></tr></table></figure><p>​    而我们知道，Spring最核心的功能就是IOC和AOP，也是本次源码分析的重点</p><p>​    在图中，也就是Core Container中的模块和AOP、Aspects。接下来，说说大致作用：</p><ul><li>Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。</li><li>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li><li>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li><li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li><li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li></ul><p>大致了解了以后，将进入源码分析了</p><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2 环境搭建"></a>2 环境搭建</h2><p>新建一个maven项目以后，导入以下pom文件</p><p><code>pom.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring_core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.w1nd.spring.dao.Person&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;23&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Bruis&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.spring.dao;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-IoC过程"><a href="#3-IoC过程" class="headerlink" title="3 IoC过程"></a>3 IoC过程</h2><p>​    IoC（控制反转）简单来说就是将创建Bean和注入Bean的权利赋予给了Spring容器，不用程序员自己去管理，在bean生成或初始化的时候，Spring容器就会将数据注入到bean中，又或者通过将对象的引用注入到对象数据域中的方式来注入对方法调用的依赖。</p><p>​    在Spring容器的设计中，有两个主要的容器机制：</p><ul><li><p>实现BeanFactory接口的简单容器系列</p><p>  ​    实现了容器最基本的功能</p></li><li><p>ApplicationContext应用上下文</p><p>  ​    除了拥有BeanFactory的所有功能外，还支持特殊类型bean如上一节中的BeanFactoryPostProcessor和BeanPostProcessor的自动识别、资源加载、容器事件和监听器、国际化支持、单例bean自动初始化等。</p></li></ul><p>对于这两个容器，DefaultListableBeanFactory是是Spring注册及加载bean的默认实现，我们可以直接使用该类来加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.spring;<br><br><span class="hljs-keyword">import</span> com.w1nd.spring.dao.Person;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br>        XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<br>        reader.loadBeanDefinitions(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>        Person person1 = (Person) beanFactory.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(person1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但在下面演示中，为了更好的了解spring一系列衍生方案，使用ClassPathXmlApplicationContext来加载xml文件，演示程序如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.spring;<br><br><span class="hljs-keyword">import</span> com.w1nd.spring.dao.Person;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//使用spring容器</span><br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        Person person = (Person)context.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    另外，我们来看DefaultListableBeanFactory和ClassPathXmlApplicationContext两个类的继承链图，这对于接下来的debug会更有帮助</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220208155138114.png" alt="image-20220208155138114"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220208155337861.png" alt="image-20220208155337861"></p><p>​    建议将该图画下来，debug时对着用箭头标明，这样不会混乱</p><p>​    下面对上述演示程序debug</p><h3 id="3-1-初始"><a href="#3-1-初始" class="headerlink" title="3.1 初始"></a>3.1 初始</h3><ol><li><p>加载ContextClosedEvent，以免后续出现问题</p></li><li><p>ClassPathXmlApplicationContext构造函数（<code>ClassPathXmlApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> String[] &#123;configLocation&#125;, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用给定的父类容器创建新的ClassPathXmlApplicationContext，然后从给定的XML文件加载定义，</span><br><span class="hljs-comment">    加载所有bean定义并且创建所有的单例，在进一步配置上下文后调用refresh。换句话说xml文件的读取，</span><br><span class="hljs-comment">    bean的创建和实例化都是在refresh()方法中进行的，refresh()函数中包含了几乎所有的</span><br><span class="hljs-comment">    ApplicationContext中提供的全部功能。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathXmlApplicationContext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    String[] configLocations, <span class="hljs-keyword">boolean</span> refresh, <span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    <span class="hljs-keyword">super</span>(parent);<br>    <span class="hljs-comment">//设置配置路径</span><br>    setConfigLocations(configLocations);<br>    <span class="hljs-keyword">if</span> (refresh) &#123;<br>        <span class="hljs-comment">//refresh Spring容器 很重要，这个方法</span><br>        refresh();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置配置路径（<code>AbstractRefreshableConfigApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给configLocations字符串数组设置值，支持多个配置文件已数组方式同时传入。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigLocations</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... locations)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (locations != <span class="hljs-keyword">null</span>) &#123;<br>        Assert.noNullElements(locations, <span class="hljs-string">&quot;Config locations must not be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.configLocations = <span class="hljs-keyword">new</span> String[locations.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; locations.length; i++) &#123;<br>            <span class="hljs-keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.configLocations = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-refresh"><a href="#3-2-refresh" class="headerlink" title="3.2 refresh"></a>3.2 refresh</h3><ol><li><p>refresh函数（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    简单来说，Spring容器的初始化是在refresh()方法来启动的，这个方法标志着IOC容器的正式启动。</span><br><span class="hljs-comment">    具体来说，这里的启动包括了BeanDefinition和Resource的定位、载入和注册三个基本过程。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        StartupStep contextRefresh = <span class="hljs-keyword">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br><br>        <span class="hljs-comment">// 准备刷新容器（上下文环境）</span><br>        prepareRefresh();<br><br>        <span class="hljs-comment">// 通知子类刷新内部bean工厂，初始化BeanFactory并进行XML的解析读取</span><br>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// 准备 bean 工厂以在此上下文中使用。</span><br>        prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 允许在上下文子类中对 bean 工厂进行后处理。</span><br>            postProcessBeanFactory(beanFactory);<br><br>            StartupStep beanPostProcess = <span class="hljs-keyword">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.beans.post-process&quot;</span>);<br>            <span class="hljs-comment">// 调用在上下文中注册为 bean 的工厂处理器。</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 注册拦截 bean 创建的 bean 处理器。</span><br>            registerBeanPostProcessors(beanFactory);<br>            beanPostProcess.end();<br><br>            <span class="hljs-comment">// 为此上下文初始化消息源。</span><br>            initMessageSource();<br><br>            <span class="hljs-comment">// 为此上下文初始化事件多播器。</span><br>            initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// 初始化特定上下文子类中的其他特殊 bean。</span><br>            onRefresh();<br><br>            <span class="hljs-comment">// 检查侦听器 bean 并注册它们。</span><br>            registerListeners();<br><br>            <span class="hljs-comment">// 实例化所有剩余的（非惰性初始化）单例。</span><br>            finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// 最后一步：发布相应的事件。</span><br>            finishRefresh();<br>        &#125;<br><br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                            <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            destroyBeans();<br><br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            cancelRefresh(ex);<br><br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br><br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            resetCommonCaches();<br>            contextRefresh.end();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> ​    鉴于该方法的重要性，下面对其函数名分目录分别讲解，每个函数会逐渐深入其子函数去分序号，部分不会讲的可能不太重要或仅知道该函数作用即可。往后，每个函数名后面会写明所在类，部分辅助函数和其他函数放在同个代码块说明，代码块的函数通常在同个类，如果不在，会在注释标明</p></li></ol><h3 id="3-3-prepareRefresh"><a href="#3-3-prepareRefresh" class="headerlink" title="3.3 prepareRefresh"></a>3.3 prepareRefresh</h3><ol><li><p>prepareRefresh（）（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">准备此上下文以进行刷新、设置其启动日期和活动标志以及执行任何属性源的初始化。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 切换到活动状态</span><br>    <span class="hljs-keyword">this</span>.startupDate = System.currentTimeMillis();<br>    <span class="hljs-keyword">this</span>.closed.set(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">this</span>.active.set(<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Refreshing &quot;</span> + <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            logger.debug(<span class="hljs-string">&quot;Refreshing &quot;</span> + getDisplayName());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化上下文环境中的任何占位符属性源。这里对于子类啥都不会干</span><br>    initPropertySources();<br><br>    <span class="hljs-comment">// 验证所有标记为必需的属性都是可解析的：</span><br>    <span class="hljs-comment">// 请参阅 ConfigurablePropertyResolvesetRequiredProperties</span><br>    getEnvironment().validateRequiredProperties();<br><br>    <span class="hljs-comment">// 存储预刷新 ApplicationListeners...</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyApplicationListeners == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.earlyApplicationListeners = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-keyword">this</span>.applicationListeners);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将本地应用程序侦听器重置为预刷新状态。</span><br>        <span class="hljs-keyword">this</span>.applicationListeners.clear();<br>        <span class="hljs-keyword">this</span>.applicationListeners.addAll(<span class="hljs-keyword">this</span>.earlyApplicationListeners);<br>    &#125;<br><br><span class="hljs-comment">// 允许收集早期应用程序事件，一旦多播器可用就发布...</span><br>    <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-obtainFreshBeanFactory"><a href="#3-4-obtainFreshBeanFactory" class="headerlink" title="3.4 obtainFreshBeanFactory"></a>3.4 obtainFreshBeanFactory</h3><p>该方法的时序图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220210135522201.png" alt="image-20220210135522201"></p><ol><li><p>obtainFreshBeanFactory （<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">告诉子类刷新内部 bean 工厂。会返回新的BeanFactory实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    refreshBeanFactory();<br>    <span class="hljs-keyword">return</span> getBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>refreshBeanFactory（<code>AbstractRefreshableApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">此实现执行此上下文的底层 bean 工厂的实际刷新，关闭先前的 bean 工厂（如果有）并为上下文生命周期的下一阶段初始化一个新的 bean 工厂。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// 如果有 Bean工厂，则关闭该工厂</span><br>    <span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>        destroyBeans();<br>        closeBeanFactory();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建一个新bean工厂，这里的DefaultListableBeanFactory就是前面的Spring核心类，这个类真的很重要！</span><br>        DefaultListableBeanFactory beanFactory = createBeanFactory();<br>        <span class="hljs-comment">// 序列化指定ID，如果需要的话，让这个BeanFactory从ID反序列化掉BeanFactory对象</span><br>        beanFactory.setSerializationId(getId());<br>    <span class="hljs-comment">// 自定义此上下文使用的内部 bean 工厂。为每次 refresh() 尝试调用。默认实现应用此上下文</span><br>        <span class="hljs-comment">// 的“allowBeanDefinitionOverriding”和“allowCircularReferences”设置（如果指定）。</span><br>        <span class="hljs-comment">// 可以在子类中重写以自定义任何DefaultListableBeanFactory 的设置。</span><br>        customizeBeanFactory(beanFactory);<br>        <span class="hljs-comment">// 加载bean定义信息，这一步实际上就从XML配置文件里的bean信息给读取到了Factory里了。</span><br>        loadBeanDefinitions(beanFactory);<br>        <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">确定此上下文当前是否包含 bean 工厂，即至少已刷新一次且尚未关闭。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">关闭BeanFactory实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.beanFactory;<br>    <span class="hljs-keyword">if</span> (beanFactory != <span class="hljs-keyword">null</span>) &#123;<br>        beanFactory.setSerializationId(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220209162635420.png" alt="image-20220209162635420"></p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220209162728047.png" alt="image-20220209162728047"></p><p> ​    上面图片，是loadBeanDefinitions（）方法运行完之后，eanFactory变量里面存放着一个ConcurrentHashMap变量，用于存放着person这个KV键值对，Key为person，Value为一个ArrayList的变量，里面存放着person的两个属性：age、name。下面接着深入该方法分析</p><ol><li>loadBeanDefinitions（<code>AbstractXmlApplicationContext.class</code>）</li></ol><p> ​    BeanDefinition，顾名思义，用于<strong>定义bean信息的类</strong>，包含bean的class类型、构造参数、属性值等信息，每个bean对应一个BeanDefinition的实例。简化BeanDefinition仅包含bean的class类型。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">通过 XmlBeanDefinitionReader 加载 bean 定义。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    <span class="hljs-comment">// 为给定的 BeanFactory 创建一个新的 XmlBeanDefinitionReader。</span><br>    XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<br><br>   <span class="hljs-comment">// 使用此上下文的资源加载环境配置 bean 定义阅读器。</span><br>    beanDefinitionReader.setEnvironment(<span class="hljs-keyword">this</span>.getEnvironment());<br>    <span class="hljs-comment">// 设置 ResourceLoader 以用于资源定位。</span><br>    beanDefinitionReader.setResourceLoader(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 设置要用于解析的 SAX 实体解析器。默认情况下，将使用 ResourceEntityResolver。</span><br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> ResourceEntityResolver(<span class="hljs-keyword">this</span>));<br><br><span class="hljs-comment">// 允许子类提供阅读器的自定义初始化</span><br>    initBeanDefinitionReader(beanDefinitionReader);<br>    <span class="hljs-comment">// 实际加载 bean 定义。</span><br>    loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">AbstractApplicationContext.class</span><br><span class="hljs-comment">以可配置的形式返回此应用程序上下文的环境，允许进一步定制。</span><br><span class="hljs-comment">如果未指定，则将通过 createEnvironment() 初始化默认环境。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableEnvironment <span class="hljs-title">getEnvironment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.environment = createEnvironment();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.environment;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">XmlBeanDefinitionReader.class</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEntityResolver</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> EntityResolver entityResolver)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.entityResolver = entityResolver;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">初始化用于加载此上下文的 bean 定义的 bean 定义阅读器。默认实现为空。</span><br><span class="hljs-comment">可以在子类中被覆盖，例如用于关闭 XML 验证或使用不同的 XmlBeanDefinitionParser 实现。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBeanDefinitionReader</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> </span>&#123;<br>    reader.setValidating(<span class="hljs-keyword">this</span>.validating);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>loadBeanDefinitions（<code>AbstractXmlApplicationContext.class</code>）</p><p> ​    注意这个和上个不一样，是重载</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用给定的 XmlBeanDefinitionReader 加载 bean 定义。 </span><br><span class="hljs-comment">bean 工厂的生命周期由 refreshBeanFactory 方法处理；因此这个方法只是应该加载和或注册 bean 定义。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    Resource[] configResources = getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-keyword">null</span>) &#123;<br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br>    String[] configLocations = getConfigLocations();<br>    <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-keyword">null</span>) &#123;<br>        reader.loadBeanDefinitions(configLocations);  <span class="hljs-comment">// &lt;-------是string路径会执行这个</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>loadBeanDefinitions（<code>AbstractBeanDefinationReader.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    Assert.notNull(locations, <span class="hljs-string">&quot;Location array must not be null&quot;</span>);<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (String location : locations) &#123;<br>        count += loadBeanDefinitions(location);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">从指定的资源位置加载 bean 定义。位置也可以是位置模式，</span><br><span class="hljs-comment">前提是此 bean 定义读取器的 ResourceLoader 是 ResourcePatternResolver。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location, <span class="hljs-meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    ResourceLoader resourceLoader = getResourceLoader();<br>    <span class="hljs-keyword">if</span> (resourceLoader == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<br>            <span class="hljs-string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="hljs-string">&quot;]: no ResourceLoader available&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (resourceLoader <span class="hljs-keyword">instanceof</span> ResourcePatternResolver) &#123;<br>        <span class="hljs-comment">// 资源模式匹配可用。</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>            <span class="hljs-comment">// 从指定的 XML 文件加载 bean 定义。这里debug会进去XmlBeanDefinitionReader，</span><br>            <span class="hljs-keyword">int</span> count = loadBeanDefinitions(resources);<br>            <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-keyword">null</span>) &#123;<br>                Collections.addAll(actualResources, resources);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Loaded &quot;</span> + count + <span class="hljs-string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<br>                <span class="hljs-string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 只能通过绝对 URL 加载单个资源。</span><br>        Resource resource = resourceLoader.getResource(location);<br>        <span class="hljs-keyword">int</span> count = loadBeanDefinitions(resource);<br>        <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-keyword">null</span>) &#123;<br>            actualResources.add(resource);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Loaded &quot;</span> + count + <span class="hljs-string">&quot; bean definitions from location [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;   <br></code></pre></td></tr></table></figure></li><li><p>getResources（<code>PathMatchingResourcePatternResolver.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>Assert.notNull(locationPattern, <span class="hljs-string">&quot;Location pattern must not be null&quot;</span>);<br><span class="hljs-keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;<br><span class="hljs-comment">// 类路径资源（可能有多个同名资源）</span><br><span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;<br><span class="hljs-comment">// 类路径资源模式</span><br><span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 具有给定名称的所有类路径资源</span><br><span class="hljs-keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 通常只在前缀后面查找一个模式，并且在Tomcat之后只有“* /”分隔符之后的“war：”协议。</span><br><span class="hljs-keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="hljs-string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="hljs-string">&quot;*/&quot;</span>) + <span class="hljs-number">1</span> :<br>locationPattern.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;<br><span class="hljs-comment">// 文件模式</span><br><span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 具有给定名称的单个资源</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>loadBeanDefinitions（<code>XmlBeanDefinitionReader.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    从XML配置文件中获取bean定义信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>Assert.notNull(encodedResource, <span class="hljs-string">&quot;EncodedResource must not be null&quot;</span>);<br>    ...<br>Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();<br><span class="hljs-keyword">if</span> (currentResources == <span class="hljs-keyword">null</span>) &#123;<br>currentResources = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);<br>&#125;<br>...<br><span class="hljs-keyword">try</span> &#123;<br>InputStream inputStream = encodedResource.getResource().getInputStream();<br><span class="hljs-keyword">try</span> &#123;<br>InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);<br><span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;<br>inputSource.setEncoding(encodedResource.getEncoding());<br>&#125;<br><span class="hljs-comment">//获取到读取xml配置文件的InputStream流后，进行BeanDefinitions的加载</span><br><span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>inputStream.close();<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>currentResources.remove(encodedResource);<br><span class="hljs-keyword">if</span> (currentResources.isEmpty()) &#123;<br><span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    真正从xml配置文件中加载Bean定义信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//获取xml的配置信息并封装为Document对象</span><br>Document doc = doLoadDocument(inputSource, resource);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.registerBeanDefinitions(doc, resource);<br>&#125;<br><span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>    ...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 以上的流程是在读取BeanDefinition信息，下面看如何将其注册</p></li></ol><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220210174705211.png" alt="image-20220210174705211"></p><ol><li><p>registerBeanDefinitions（<code>XmlBeanDefinitionReader.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">注册包含在给定 DOM 文档中的 bean 定义</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    <span class="hljs-comment">// 创建 BeanDefinitionDocumentReader 以用于从 XML 文档中实际读取 bean 定义</span><br>    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br>    <span class="hljs-comment">// 注册表中定义的 bean 数量</span><br>    <span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();<br>    <span class="hljs-comment">// 打开一个 DOM 文档；然后初始化在 &lt;beans&gt; 级别指定的默认设置；然后解析包含的 bean 定义。</span><br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));  <span class="hljs-comment">// &lt;-----------</span><br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>registerBeanDefinitions（<code>DefaultBeanDefinitionDocumentReader.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">注册并解析包含的 bean 定义。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.readerContext = readerContext;<br>    doRegisterBeanDefinitions(doc.getDocumentElement());<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在给定的根 &lt;beans&gt; 元素中注册每个 bean 定义。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;<br>    BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;<br>    <span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;<br>        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;<br>            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(<br>                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>            <span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +<br>                                 <span class="hljs-string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    preProcessXml(root);<br>    <span class="hljs-comment">// 解析beanDefinitions信息，经过这个方法，beanFactory中就会保存从xml配置文件中解析而来的信息</span><br>    parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);<br>    postProcessXml(root);<br><br>    <span class="hljs-keyword">this</span>.delegate = parent;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析文档中根级别的元素：“import”、“alias”、“bean”</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        NodeList nl = root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            Node node = nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                Element ele = (Element) node;<br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    <span class="hljs-comment">// 解析默认元素</span><br>                    parseDefaultElement(ele, delegate);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析默认元素</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        <span class="hljs-comment">// 读取到xml配置文件的&lt;bean&gt;节点</span><br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// 递归</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">处理给定的 bean 元素，解析 bean 定义并将其注册到注册表。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<br>    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); <span class="hljs-comment">// 解析提供的 &lt;bean&gt; 元素</span><br>    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;<br>        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);  <span class="hljs-comment">// 如果适用，通过命名空间处理程序装饰给定的 bean 定义。</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 注册最终的装饰实例。</span><br>            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +<br>                                     bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);<br>        &#125;<br>        <span class="hljs-comment">// 发送注册事件。</span><br>        getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>parseBeanDefinitionElement（<code>BeanDefinitionParserDelegate.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> parseBeanDefinitionElement(ele, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析提供的 &lt;bean&gt; 元素。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;<br>    String id = ele.getAttribute(ID_ATTRIBUTE);<br>    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);<br><br>    List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>        aliases.addAll(Arrays.asList(nameArr));<br>    &#125;<br><br>    String beanName = id;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;<br>        beanName = aliases.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +<br>                         <span class="hljs-string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="hljs-string">&quot; as aliases&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (containingBean == <span class="hljs-keyword">null</span>) &#123;<br>        checkNameUniqueness(beanName, aliases, ele);<br>    &#125;<br>    <br> <span class="hljs-comment">//终于，这里要解析beanDefinition了</span><br>    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);<br>    <span class="hljs-keyword">if</span> (beanDefinition != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-keyword">null</span>) &#123;<br>                    beanName = BeanDefinitionReaderUtils.generateBeanName(<br>                        beanDefinition, <span class="hljs-keyword">this</span>.readerContext.getRegistry(), <span class="hljs-keyword">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    beanName = <span class="hljs-keyword">this</span>.readerContext.generateBeanName(beanDefinition);<br>                    <span class="hljs-comment">// Register an alias for the plain bean class name, if still possible,</span><br>                    <span class="hljs-comment">// if the generator returned the class name plus a suffix.</span><br>                    <span class="hljs-comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span><br>                    String beanClassName = beanDefinition.getBeanClassName();<br>                    <span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-keyword">null</span> &amp;&amp;<br>                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>                        !<span class="hljs-keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;<br>                        aliases.add(beanClassName);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                    logger.trace(<span class="hljs-string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +<br>                                 <span class="hljs-string">&quot;using generated bean name [&quot;</span> + beanName + <span class="hljs-string">&quot;]&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                error(ex.getMessage(), ele);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        String[] aliasesArray = StringUtils.toStringArray(aliases);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">解析 bean 定义本身，而不考虑名称或别名。如果在解析 bean 定义期间出现问题，则可能返回 null。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    Element ele, String beanName, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;<br><br>    <span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> BeanEntry(beanName));<br><br>    String className = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;<br>        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>    &#125;<br>    String parent = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;<br>        parent = ele.getAttribute(PARENT_ATTRIBUTE);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建BeanDefinition</span><br>        AbstractBeanDefinition bd = createBeanDefinition(className, parent);<br><br>        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br><br>        parseMetaElements(ele, bd);<br>        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br>        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br><span class="hljs-comment">// 通过构造器解析参数值</span><br>        parseConstructorArgElements(ele, bd);<br>         <span class="hljs-comment">// 通过property的value解析值吗，本文的程序xml就是通过property属性设置bean的值的，最终被这一方法所解析出来。</span><br>        parsePropertyElements(ele, bd);<br>        parseQualifierElements(ele, bd);<br><br>        bd.setResource(<span class="hljs-keyword">this</span>.readerContext.getResource());<br>        bd.setSource(extractSource(ele));<br><br>        <span class="hljs-keyword">return</span> bd;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>        error(<span class="hljs-string">&quot;Bean class [&quot;</span> + className + <span class="hljs-string">&quot;] not found&quot;</span>, ele, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoClassDefFoundError err) &#123;<br>        error(<span class="hljs-string">&quot;Class that bean class [&quot;</span> + className + <span class="hljs-string">&quot;] depends on not found&quot;</span>, ele, err);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        error(<span class="hljs-string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">this</span>.parseState.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 解析给定 bean 元素的属性子元素。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parsePropertyElements</span><span class="hljs-params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;<br>    NodeList nl = beanEle.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        Node node = nl.item(i);<br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;<br>            <span class="hljs-comment">// 解析出参数值来，这里就真正的讲age的23，和name的bruis值解析出来并防止在一个组装的类里面存放着。</span><br>            <span class="hljs-comment">// 因为这里有两个bean，所以要循环调用两次parsePropertyElement()方法</span><br>            parsePropertyElement((Element) node, bd);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 解析属性元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parsePropertyElement</span><span class="hljs-params">(Element ele, BeanDefinition bd)</span> </span>&#123;<br>    String propertyName = ele.getAttribute(NAME_ATTRIBUTE);<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;<br>        error(<span class="hljs-string">&quot;Tag &#x27;property&#x27; must have a &#x27;name&#x27; attribute&quot;</span>, ele);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> PropertyEntry(propertyName));<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;<br>            error(<span class="hljs-string">&quot;Multiple &#x27;property&#x27; definitions for property &#x27;&quot;</span> + propertyName + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Object val = parsePropertyValue(ele, bd, propertyName);<br>        PropertyValue pv = <span class="hljs-keyword">new</span> PropertyValue(propertyName, val);<br>        parseMetaElements(ele, pv);<br>        pv.setSource(extractSource(ele));<br>        <span class="hljs-comment">// 就是这一步，将K为age、name，值分别为23、bruis的KV对存放在了Spring容器里。</span><br>        bd.getPropertyValues().addPropertyValue(pv);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">this</span>.parseState.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>总结：该方法实际上实现了<strong>容器的初始化</strong>以及<strong>BeanDefinition的注册与加载</strong>，方便后续Bean的创建和加载</p><p>容器的初始化过程如下：</p><ul><li>第一个过程是<strong>Resource定位过程</strong>。这个Resource定位过程指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一接口。这个定位过程类似于容器寻找数据的过程，就像使用水桶装水先要把水找到一样。</li><li>第二个过程是<strong>BeanDefinition的载入</strong>。这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。下面介绍这个数据结构的详细定义。具体来说，这个BeanDefinition实际上就是POJO对象在IOC容器的抽象，通过这个BeanDefinition定义的数据结构，使IOC能够方便地对POJO对象进行管理。</li><li>第三个过程是<strong>向IOC容器注册这些BeanDefinition</strong>的过程，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的。这个注册过程把载入过程中解析到的BeanDefinition向IOC容器进行注册。通过上面的分析，我们知道IOC内部将BeanDefinition注册到了ConcurrentHashMap中。</li></ul><h3 id="3-5-prepareBeanFactory"><a href="#3-5-prepareBeanFactory" class="headerlink" title="3.5 prepareBeanFactory"></a>3.5 prepareBeanFactory</h3><ol><li><p>prepareBeanFactory（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">配置工厂的标准上下文特征，例如上下文的 ClassLoader 和后处理器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 告诉内部 bean 工厂使用上下文的类加载器等。</span><br>    beanFactory.setBeanClassLoader(getClassLoader());<br>    <span class="hljs-keyword">if</span> (!shouldIgnoreSpel) &#123;<br>        beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));<br>    &#125;<br>    beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> ResourceEditorRegistrar(<span class="hljs-keyword">this</span>, getEnvironment()));<br><br>    <span class="hljs-comment">// 使用上下文回调配置 bean 工厂。</span><br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationContextAwareProcessor(<span class="hljs-keyword">this</span>));<br>    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);<br>    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);<br>    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);<br>    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);<br>    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);<br>    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);<br>    beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);<br><br>    <span class="hljs-comment">// BeanFactory 接口未在普通工厂中注册为可解析类型。</span><br>    <span class="hljs-comment">// MessageSource 作为 bean 注册（并为自动装配找到）。</span><br>    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);<br>    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-keyword">this</span>);<br>    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-keyword">this</span>);<br>    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// 将用于检测内部 bean 的早期后处理器注册为 ApplicationListener。</span><br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(<span class="hljs-keyword">this</span>));<br><br>    <span class="hljs-comment">// 检测 LoadTimeWeaver 并准备编织（如果找到）。</span><br>    <span class="hljs-keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>        beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));<br>        <span class="hljs-comment">// 为类型匹配设置一个临时 ClassLoader。</span><br>        beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));<br>    &#125;<br><br>    <span class="hljs-comment">// 注册默认环境 bean。</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;<br>        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;<br>        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;<br>        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;<br>        beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-6-postProcessBeanFactory"><a href="#3-6-postProcessBeanFactory" class="headerlink" title="3.6  postProcessBeanFactory"></a>3.6  postProcessBeanFactory</h3><ol><li><p>postProcessBeanFactory（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">在标准初始化之后修改应用程序上下文的内部 bean 工厂。所有 bean 定义都将被加载，</span><br><span class="hljs-comment">但还没有 bean 被实例化。这允许在某些 ApplicationContext 实现中注册特殊的 BeanPostProcessors 等。</span><br><span class="hljs-comment">简单来说，就是允许我们在bean实例化之前修改bean的定义信息即BeanDefinition的信息</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-7-invokeBeanFactoryPostProcessors"><a href="#3-7-invokeBeanFactoryPostProcessors" class="headerlink" title="3.7  invokeBeanFactoryPostProcessors"></a>3.7  invokeBeanFactoryPostProcessors</h3><ol><li><p>invokeBeanFactoryPostProcessors （<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化并调用所有已注册的 BeanFactoryPostProcessor bean，如果给定，则尊重显式顺序。必须在单例实例化之前调用。</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());<br><br>    <span class="hljs-comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br>    <span class="hljs-comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br>    <span class="hljs-keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == <span class="hljs-keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>        beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));<br>        beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-8-registerBeanPostProcessors"><a href="#3-8-registerBeanPostProcessors" class="headerlink" title="3.8 registerBeanPostProcessors"></a>3.8 registerBeanPostProcessors</h3><ol><li><p>registerBeanPostProcessors （<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">实例化并注册所有 BeanPostProcessor bean，如果给定，则尊重显式顺序。必须在应用程序 bean 的任何实例化之前调用。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-9-initMessageSource"><a href="#3-9-initMessageSource" class="headerlink" title="3.9 initMessageSource"></a>3.9 initMessageSource</h3><ol><li><p>initMessageSource（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">初始化消息源。如果没有在此上下文中定义，则使用父级。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMessageSource</span><span class="hljs-params">()</span> </span>&#123;<br>    ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;<br>        <span class="hljs-keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);<br>        <span class="hljs-comment">// 使 MessageSource 感知父 MessageSource。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.messageSource <span class="hljs-keyword">instanceof</span> HierarchicalMessageSource) &#123;<br>            HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="hljs-keyword">this</span>.messageSource;<br>            <span class="hljs-keyword">if</span> (hms.getParentMessageSource() == <span class="hljs-keyword">null</span>) &#123;<br>   <span class="hljs-comment">// 如果尚未注册父消息源，则仅将父上下文设置为父消息源。</span><br>                hms.setParentMessageSource(getInternalParentMessageSource());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Using MessageSource [&quot;</span> + <span class="hljs-keyword">this</span>.messageSource + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 使用空 MessageSource 能够接受 getMessage 调用。</span><br>        DelegatingMessageSource dms = <span class="hljs-keyword">new</span> DelegatingMessageSource();<br>        dms.setParentMessageSource(getInternalParentMessageSource());<br>        <span class="hljs-keyword">this</span>.messageSource = dms;<br>        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="hljs-keyword">this</span>.messageSource);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="hljs-string">&quot;&#x27; bean, using [&quot;</span> + <span class="hljs-keyword">this</span>.messageSource + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-10-initApplicationEventMulticaster"><a href="#3-10-initApplicationEventMulticaster" class="headerlink" title="3.10 initApplicationEventMulticaster"></a>3.10 initApplicationEventMulticaster</h3><ol><li><p>initApplicationEventMulticaster（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">初始化 ApplicationEventMulticaster。如果上下文中没有定义，则使用 SimpleApplicationEventMulticaster。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationEventMulticaster</span><span class="hljs-params">()</span> </span>&#123;<br>    ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;<br>        <span class="hljs-keyword">this</span>.applicationEventMulticaster =<br>            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.applicationEventMulticaster = <span class="hljs-keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);<br>        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="hljs-keyword">this</span>.applicationEventMulticaster);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="hljs-string">&quot;&#x27; bean, using &quot;</span> +<br>                         <span class="hljs-string">&quot;[&quot;</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-11-onRefresh"><a href="#3-11-onRefresh" class="headerlink" title="3.11 onRefresh"></a>3.11 onRefresh</h3><ol><li><p>onRefresh（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">可以重写以添加特定于上下文的刷新工作的模板方法。在单例实例化之前调用特殊 bean 的初始化。这个实现是空的。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// 对于子类：默认情况下什么都不做。</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-12-registerListeners"><a href="#3-12-registerListeners" class="headerlink" title="3.12 registerListeners"></a>3.12 registerListeners</h3><ol><li><p>registerListeners（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListeners</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先注册静态指定的监听器。</span><br>    <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;<br>        getApplicationEventMulticaster().addApplicationListener(listener);<br>    &#125;<br><br><span class="hljs-comment">// 不要在这里初始化 FactoryBeans：我们需要让所有常规 bean 保持未初始化状态，以让后处理器应用于它们！</span><br>    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;<br>        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br>    &#125;<br><br>    <span class="hljs-comment">// 发布早期应用程序事件，因为我们终于有了一个多播器......</span><br>    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="hljs-keyword">this</span>.earlyApplicationEvents;<br>    <span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;<br>        <span class="hljs-keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;<br>            getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-12-finishBeanFactoryInitialization"><a href="#3-12-finishBeanFactoryInitialization" class="headerlink" title="3.12 finishBeanFactoryInitialization"></a>3.12 finishBeanFactoryInitialization</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220210173837998.png" alt="image-20220210173837998"></p><ol><li><p>finishBeanFactoryInitialization（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">完成此上下文的 bean 工厂的初始化，初始化所有剩余的单例 bean。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 为此上下文初始化转换服务。</span><br>    <span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;<br>        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;<br>        beanFactory.setConversionService(<br>            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));<br>    &#125;<br><br><span class="hljs-comment">// 如果之前没有注册过任何 BeanFactoryPostProcessor（例如 PropertySourcesPlaceholderConfigurer bean），</span><br>    <span class="hljs-comment">// 则注册一个默认的嵌入值解析器：此时，主要用于解析注释属性值。</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;<br>        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));<br>    &#125;<br><br>    <span class="hljs-comment">// 尽早初始化 LoadTimeWeaverAware bean，以便尽早注册它们的转换器。</span><br>    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;<br>        getBean(weaverAwareName);<br>    &#125;<br><br>    <span class="hljs-comment">// 停止使用临时 ClassLoader 进行类型匹配。</span><br>    beanFactory.setTempClassLoader(<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">// 允许缓存所有 bean 定义元数据，而不是期望进一步的更改。</span><br>    beanFactory.freezeConfiguration();<br><br>    <span class="hljs-comment">// 实例化所有剩余的（非惰性初始化）单例。</span><br>    beanFactory.preInstantiateSingletons();<br>&#125;<br></code></pre></td></tr></table></figure><p> ​    这里的懒加载的意思，指的是bean单例不是在Spring容器初始化的时候就创建的，而是在要使用该bean的时候，才会创建该bean。</p></li><li><p>preInstantiateSingletons（<code>DefaultListableBeanFactory.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代一个副本以允许 init 方法依次注册新的 bean 定义。</span><br>    <span class="hljs-comment">// 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。</span><br>    <span class="hljs-comment">// 获取所有的bean定义的名字，并保存在集合List里面。</span><br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// 触发所有非延迟单例bean的初始化...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>         <span class="hljs-comment">// 触发所有适用bean的后初始化回调</span><br>        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);<br>                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br>                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br>                    <span class="hljs-keyword">boolean</span> isEagerInit;<br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>                        isEagerInit = AccessController.doPrivileged(<br>                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>                            getAccessControlContext());<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>                        getBean(beanName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 为所有适用的 bean 触发初始化后回调...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        Object singletonInstance = getSingleton(beanName);<br>        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<br>            StartupStep smartInitialize = <span class="hljs-keyword">this</span>.getApplicationStartup().start(<span class="hljs-string">&quot;spring.beans.smart-initialize&quot;</span>)<br>                .tag(<span class="hljs-string">&quot;beanName&quot;</span>, beanName);<br>            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;<br>            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br>                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>                    smartSingleton.afterSingletonsInstantiated();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;, getAccessControlContext());<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                smartSingleton.afterSingletonsInstantiated();<br>            &#125;<br>            smartInitialize.end();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getBean（<code>AbstractBeanFactory.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回指定 bean 的一个实例，该实例可以是共享的，也可以是独立的。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-comment">// 去除name上存在的工厂bean的前缀</span><br>    String beanName = transformedBeanName(name);<br>    Object beanInstance;<br><br>    <span class="hljs-comment">// 快速判断单例缓存中是否存在该bean，如果存在则返回单例bean；否则返回null</span><br>    Object sharedInstance = getSingleton(beanName);<span class="hljs-comment">// &lt;--------------</span><br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>                logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +<br>                             <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 从单例缓存中获取单例bean</span><br>        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果我们已经在创建这个 bean 实例，则失败：我们可能在循环引用中。</span><br>        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查此工厂中是否存在 bean 定义。</span><br>        BeanFactory parentBeanFactory = getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// 未找到 -&gt; 检查父级。</span><br>            String nameToLookup = originalBeanName(name);<br>            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                    nameToLookup, requiredType, args, typeCheckOnly);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 使用显式参数委托给父级。</span><br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 没有 args -&gt; 委托给标准 getBean 方法。</span><br>                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName); <span class="hljs-comment">// 将指定的 bean 标记为已创建（或即将创建）。这允许 bean 工厂优化其缓存以重复创建指定的 bean</span><br>        &#125;<br><br>        StartupStep beanCreation = <span class="hljs-keyword">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.beans.instantiate&quot;</span>)<br>            .tag(<span class="hljs-string">&quot;beanName&quot;</span>, name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;<br>                beanCreation.tag(<span class="hljs-string">&quot;beanType&quot;</span>, requiredType::toString);<br>            &#125;<br>            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);<br>            checkMergedBeanDefinition(mbd, beanName, args);<br><br>            <span class="hljs-comment">// 保证当前 bean 所依赖的 bean 的初始化。</span><br>            String[] dependsOn = mbd.getDependsOn();<br>            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                    registerDependentBean(dep, beanName);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        getBean(dep);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 创建 bean 实例。</span><br>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<span class="hljs-comment">// &lt; -----------------</span><br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>  <span class="hljs-comment">// 从单例缓存中显式删除实例：它可能已被创建过程急切地放在那里，以允许循环引用解析。</span><br>                        <span class="hljs-comment">// 还要删除任何接收到对 bean 的临时引用的 bean。</span><br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;);<br>                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>                <span class="hljs-comment">// 这是一个原型 -&gt; 创建一个新实例。</span><br>                Object prototypeInstance = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforePrototypeCreation(beanName);<br>                    prototypeInstance = createBean(beanName, mbd, args);<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    afterPrototypeCreation(beanName);<br>                &#125;<br>                beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                String scopeName = mbd.getScope();<br>                <span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;No scope name defined for bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                Scope scope = <span class="hljs-keyword">this</span>.scopes.get(scopeName);<br>                <span class="hljs-keyword">if</span> (scope == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;<br>                        beforePrototypeCreation(beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                        &#125;<br>                        <span class="hljs-keyword">finally</span> &#123;<br>                            afterPrototypeCreation(beanName);<br>                        &#125;<br>                    &#125;);<br>                    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            beanCreation.tag(<span class="hljs-string">&quot;exception&quot;</span>, ex.getClass().toString());<br>            beanCreation.tag(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));<br>            cleanupAfterBeanCreationFailure(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            beanCreation.end();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getSingleton（<code>DefaultSingletonBeanRegistry.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回在给定名称下注册的（原始）单例对象。</span><br><span class="hljs-comment">检查已经实例化的单例，还允许对当前创建的单例进行早期引用（解决循环引用）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速检查没有完整单例锁的现有实例</span><br>    Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);<br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>                <span class="hljs-comment">// 在完整的单例锁中一致地创建早期引用</span><br>                singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<br>                    singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);<br>                    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<br>                        ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);<br>                        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;<br>                            singletonObject = singletonFactory.getObject();<br>                            <span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                            <span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>createBean（<code>AbstractAutowireCapableBeanFactory.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>    RootBeanDefinition mbdToUse = mbd;<br><br><span class="hljs-comment">// 确保此时实际解析了 bean 类，并克隆 bean 定义以防动态解析的 Class 无法存储在共享的合并 bean 定义中。</span><br>    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-keyword">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> RootBeanDefinition(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-comment">// 准备方法覆盖</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        mbdToUse.prepareMethodOverrides();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),<br>                                               beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 调用实例化前的后置处理器，在这个后置处理器中可以对bean进行处理，可以返回由后置处理器处理的bean而不是被实例化的bean。</span><br><span class="hljs-comment">// 换句话说就是这里可以拦截住bean的实例化</span><br><span class="hljs-comment">// Spring的后置处理器后面有机会再专门写一篇博文来总结学习一下</span><br>        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,<br>                                        <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Object beanInstance = doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;<br>    <span class="hljs-comment">// 先前检测到的异常已经具有正确的 bean 创建上下文，或者要与 DefaultSingletonBeanRegistry 通信的非法单例状态。</span><br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>            mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, ex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    正在的创建一个bean，并且按照配置文件的配置来实例化该bean。如果没有初始化前的后置处理器的调用，则调用该方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;<br><br>   <span class="hljs-comment">// 创建一个包装类，用于包装真正要创建的bean。</span><br>    BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-comment">// 使用适当的实例化策略例如：工厂方法、构造函数自动装配或者简单实例化 来为指定bean创建新的实例。</span><br>        <span class="hljs-comment">// 这里仅仅是简单的实例化，为bean设置默认初始值</span><br>    <span class="hljs-comment">// 也就是name为null，age为0。此时instanceWrapper任然还只是一个包装bean，并不是一个真正意义上的person类bean。</span><br>        <span class="hljs-comment">// 1. 实例化</span><br>        instanceWrapper = createBeanInstance(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-comment">// 终于，我们千辛万苦打断点调试来到了这一步，就是这一步， 获得了我们想要的person类bean。</span><br>    <span class="hljs-comment">// 只需要在BeanWrapper里取出WrapperInstance即可。</span><br>    <span class="hljs-comment">// 接下来就是要拿这个创建好的bean和BeanDefinition进行实例化了。</span><br>    Object bean = instanceWrapper.getWrappedInstance();<br>    <span class="hljs-comment">// 获取bean的类型</span><br>    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br>    <span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>        mbd.resolvedTargetType = beanType;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用后置处理器去修改bean的定义信息。</span><br>    <span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br>        <span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<br>                                                <span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);<br>            &#125;<br>            mbd.postProcessed = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 即使被 BeanFactoryAware 等生命周期接口触发，也急切地缓存单例以解析循环引用。</span><br>    <span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;<br>                                      isSingletonCurrentlyInCreation(beanName));<br>    <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br>                         <span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>        &#125;<br>        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>    &#125;<br><br>    <span class="hljs-comment">// 实例化一个真正使用的bean。</span><br>    Object exposedObject = bean;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 2. 属性赋值</span><br>        populateBean(beanName, mbd, instanceWrapper);<span class="hljs-comment">// &lt;--------------------</span><br>        <span class="hljs-comment">// 3. 初始化</span><br>        exposedObject = initializeBean(beanName, exposedObject, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<br>            <span class="hljs-keyword">throw</span> (BeanCreationException) ex;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Initialization of bean failed&quot;</span>, ex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>        Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>                exposedObject = earlySingletonReference;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>                String[] dependentBeans = getDependentBeans(beanName);<br>                Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);<br>                <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                    <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                        actualDependentBeans.add(dependentBean);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,<br>                                                               <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>                                                               <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>                                                               <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>                                                               <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>                                                               <span class="hljs-string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 销毁注册回调接口</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用 bean 定义中的属性值填充给定 BeanWrapper 中的 bean 实例。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bw == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Skip property population phase for null instance.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 让任何 InstantiationAwareBeanPostProcessors 有机会在设置属性之前修改 bean 的状态。</span><br>    <span class="hljs-comment">// 例如，这可以用于支持字段注入的样式。</span><br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>            <span class="hljs-keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 取出BeanDefinition里的属性值</span><br>    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();<br>    <span class="hljs-comment">// 如果设置的是自动装配模式，则由自动装配来进行赋值</span><br>    <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;<br>        MutablePropertyValues newPvs = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);<br>        <span class="hljs-comment">// 通过bean名自动装配</span><br>        <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;<br>            autowireByName(beanName, mbd, bw, newPvs);<br>        &#125;<br>        <span class="hljs-comment">// 通过bean类型自动装配</span><br>        <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;<br>            autowireByType(beanName, mbd, bw, newPvs);<br>        &#125;<br>        pvs = newPvs;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();<br>    <span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);<br><br>    PropertyDescriptor[] filteredPds = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br>        <span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;<br>            pvs = mbd.getPropertyValues();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;<br>            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br>            <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;<br>                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>                &#125;<br>                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>                <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            pvs = pvsToUse;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (needsDepCheck) &#123;<br>        <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;<br>            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>        &#125;<br>        checkDependencies(beanName, mbd, filteredPds, pvs);<br>    &#125;<br><span class="hljs-comment">// 这里的PropertyValues已经包含了bean字段属性的设置值了</span><br>    <span class="hljs-keyword">if</span> (pvs != <span class="hljs-keyword">null</span>) &#123;<br>        applyPropertyValues(beanName, mbd, bw, pvs);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">应用给定的属性值，解析对此 bean 工厂中其他 bean 的任何运行时引用。必须使用深拷贝，所以我们不会永久修改这个属性。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyPropertyValues</span><span class="hljs-params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pvs.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; bw <span class="hljs-keyword">instanceof</span> BeanWrapperImpl) &#123;<br>        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());<br>    &#125;<br><br>    MutablePropertyValues mpvs = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 源属性值</span><br>    List&lt;PropertyValue&gt; original;<br><br>    <span class="hljs-keyword">if</span> (pvs <span class="hljs-keyword">instanceof</span> MutablePropertyValues) &#123;<br>        mpvs = (MutablePropertyValues) pvs;<br>        <span class="hljs-keyword">if</span> (mpvs.isConverted()) &#123;<br>            <span class="hljs-comment">// Shortcut: use the pre-converted values as-is.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                bw.setPropertyValues(mpvs);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>                    mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Error setting property values&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>        original = mpvs.getPropertyValueList();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        original = Arrays.asList(pvs.getPropertyValues());<br>    &#125;<br><br>    TypeConverter converter = getCustomTypeConverter();<br>    <span class="hljs-keyword">if</span> (converter == <span class="hljs-keyword">null</span>) &#123;<br>        converter = bw;<br>    &#125;<br>    BeanDefinitionValueResolver valueResolver = <span class="hljs-keyword">new</span> BeanDefinitionValueResolver(<span class="hljs-keyword">this</span>, beanName, mbd, converter);<br><br>    <span class="hljs-comment">// 拷贝值；创建一个深拷贝副本，应用于任何bean引用此bean的情况。</span><br>    List&lt;PropertyValue&gt; deepCopy = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(original.size());<br>    <span class="hljs-keyword">boolean</span> resolveNecessary = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (PropertyValue pv : original) &#123;<br>        <span class="hljs-keyword">if</span> (pv.isConverted()) &#123;<br>            deepCopy.add(pv);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            String propertyName = pv.getName();<br>            Object originalValue = pv.getValue();<br>            <span class="hljs-keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;<br>                Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();<br>                <span class="hljs-keyword">if</span> (writeMethod == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Autowire marker for property without write method: &quot;</span> + pv);<br>                &#125;<br>                originalValue = <span class="hljs-keyword">new</span> DependencyDescriptor(<span class="hljs-keyword">new</span> MethodParameter(writeMethod, <span class="hljs-number">0</span>), <span class="hljs-keyword">true</span>);<br>            &#125;<br>            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);<br>            Object convertedValue = resolvedValue;<br>            <span class="hljs-keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;<br>                !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);<br>            <span class="hljs-keyword">if</span> (convertible) &#123;<br>                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);<br>            &#125;<br><span class="hljs-comment">// 可能在合并的bean定义中存储转换后的值，以避免为每个创建的bean实例重新转换。</span><br>            <span class="hljs-keyword">if</span> (resolvedValue == originalValue) &#123;<br>                <span class="hljs-keyword">if</span> (convertible) &#123;<br>                    pv.setConvertedValue(convertedValue);<br>                &#125;<br>                deepCopy.add(pv);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (convertible &amp;&amp; originalValue <span class="hljs-keyword">instanceof</span> TypedStringValue &amp;&amp;<br>                     !((TypedStringValue) originalValue).isDynamic() &amp;&amp;<br>                     !(convertedValue <span class="hljs-keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;<br>                pv.setConvertedValue(convertedValue);<br>                deepCopy.add(pv);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                resolveNecessary = <span class="hljs-keyword">true</span>;<br>                deepCopy.add(<span class="hljs-keyword">new</span> PropertyValue(pv, convertedValue));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mpvs != <span class="hljs-keyword">null</span> &amp;&amp; !resolveNecessary) &#123;<br>        mpvs.setConverted();<br>    &#125;<br><br>    <span class="hljs-comment">// 将深拷贝属性数组填充到beanWrapper中。这里就真正的将属性值填充到了bean上，实现了</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        bw.setPropertyValues(<span class="hljs-keyword">new</span> MutablePropertyValues(deepCopy));<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>            mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Error setting property values&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-13-finishRefresh"><a href="#3-13-finishRefresh" class="headerlink" title="3.13  finishRefresh"></a>3.13  finishRefresh</h3><ol><li><p>finishRefresh（<code>AbstractApplicationContext.class</code>）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">完成此上下文的刷新，调用 LifecycleProcessor 的 onRefresh() 方法并发布 ContextRefreshedEvent。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 清除上下文级别的资源缓存（例如扫描中的 ASM 元数据）。</span><br>    clearResourceCaches();<br><br>    <span class="hljs-comment">//为此上下文初始化生命周期处理器。</span><br>    initLifecycleProcessor();<br><br>    <span class="hljs-comment">// 首先将刷新传播到生命周期处理器。</span><br>    getLifecycleProcessor().onRefresh();<br><br>    <span class="hljs-comment">// 发布最终事件。</span><br>    publishEvent(<span class="hljs-keyword">new</span> ContextRefreshedEvent(<span class="hljs-keyword">this</span>));<br><br>    <span class="hljs-comment">// 参与 LiveBeansView MBean（如果处于活动状态）。</span><br>    <span class="hljs-keyword">if</span> (!NativeDetector.inNativeImage()) &#123;<br>        LiveBeansView.registerApplicationContext(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>​    经过上面的分析，就知道真正的对bean赋值填充是在AbstractAutowireCapableBeanFactory.class类里的applyPropertyValues方法里的，并且是通过对原属性值进行了一次深拷贝，然后将深拷贝后的属性值填充到bean里的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>​    本次源码分析，主要还是对容器的创建与初始化进行分析，也就是<code>obtainFreshBeanFactory </code>和<code>finishBeanFactoryInitialization</code>这两个函数，其他函数是对其的加工或者预处理，留到后面再详细展开。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_45397953/article/details/106877426">(99条消息) Spring和Spring Framework的理解_海TAO的博客-CSDN博客_springframework和spring</a></p><p><a href="https://github.com/coderbruis/JavaSourceCodeLearning/blob/master/note/Spring/%E6%B7%B1%E5%85%A5Spring%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5Spring%E5%AE%B9%E5%99%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE%E6%9D%A5%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Spring%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%8A%EF%BC%89.md">JavaSourceCodeLearning/深入Spring源码系列（二）——深入Spring容器，通过源码阅读和时序图来彻底弄懂Spring容器（上）</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java类的加载机制</title>
    <link href="/2022/02/07/Java/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/02/07/Java/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>​    首先，先看如下的Java代码执行流程图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220207164904659.png" alt="image-20220207164904659"></p><p>​    类的加载是指图中：字节码进入Java虚拟机后的一系列过程。具体是：虚拟机把描述类的数据<strong>从Class文件加载到内存</strong>，并对<strong>数据进行校验</strong>，<strong>转换解析</strong>和<strong>初始化</strong>，最终<strong>形成可以被虚拟机直接使用的Java类型</strong>。</p><p>​    简单来说，类的加载过程（从加载到虚拟机内存到卸出）：包括了<strong>加载</strong>，<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>，<strong>初始化</strong>，<strong>使用</strong>，<strong>卸载</strong>。</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220207210522062.png" alt="类的加载过程"></p><p>​    其他的过程顺序都是确定的，除了<strong>解析</strong>，它在某些情况下可以在初始化阶段后开始。注意：这里的顺序指的是<strong>按顺序开始</strong>，但之后执行与完成可能不是顺序的，这些阶段通常是交叉执行的。</p><h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2 类的加载过程"></a>2 类的加载过程</h2><h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>​    在这一阶段，虚拟机通常需要完成三件事情：</p><p>1）通过类的全限定名（包名+类名），获取到该类的<code>.class</code>文件的二进制字节流</p><p>2）将这个字节流所代表的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong></p><p>3）在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这些数据的访问入口</p><p>简单来说，就如下图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220207212532574.png" alt="加载阶段"></p><p>​    下面对再稍微细说下这三阶段</p><ol><li><p><strong>加载二进制数据到内存</strong></p><p> ​    这一阶段并没有说明从哪里获取以及怎么获取，这是交给开发人员自定义的，一般的读取方式有以下</p><ul><li>从ZIP包中获取，或者JAR包（很常见现在），WAR包等</li><li>从网络获取，例如Applet</li><li>运行时计算生成，使用动态代理技术</li><li>……</li></ul></li><li><p><strong>映射jvm能够识别的结构</strong></p><p> ​    将映射后可以被虚拟机识别的格式存储在方法区中，这种数据存储格式是由虚拟机自行定义</p></li><li><p><strong>在内存中生成class文件</strong></p><p> ​    在Java堆中实例化一个<code>java.lang.Class</code>类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口</p></li></ol><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>​    该阶段是连接阶段的第一步，这是要<strong>确保前面加载进来的字节流包含的数据符合要求，不会危害到虚拟机的安全</strong></p><p>​    一般有以下四个阶段的检验过程</p><ul><li><p><strong>文件格式检验</strong></p><p>  ​    <code>字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</code>。例如魔数开头是否正确，版本号是否在范围内，常量池是否有不支持的常量等</p></li><li><p><strong>元数据验证</strong></p><p>  ​    <code>对描述信息进行语义分析，确保描述的信息符合Java语言规范的要求</code>。例如该类是否有父类，是否继承了不允许被继承的类，如果不是抽象类，是否实现了该父类或接口要求实现的所有方法。</p></li><li><p><strong>字节码验证</strong></p><p>  ​    <code>进行数据流和控制流分析（对类的方法体进行校验分析）</code>。例如保证操作数栈的数据类型和指令代码序列能够配合工作，跳转指令不会跳转到方法体以外的字节码指令上，保证方法体类型转化有效。</p></li><li><p><strong>符号引用验证</strong></p><p>  ​    这会发生在虚拟机<strong>符号引用转化为直接引用</strong>的时候，这个转化动作将在连接的第三阶段——<strong>解析阶段</strong>发生。</p><p>  ​    这里符号引用是指任何形式的字面量，这与内存布局无关，<strong>引用的目标不一定加载到内存中</strong>，例如，引用了<code>org.simple.people</code>，那么则使用<code>org.simple.people</code>来表示该类的地址。而直接引用是则可以是指向目标的指针，相对偏移量，句柄等，<strong>该引用的目标必定存在于虚拟机内存中</strong></p><p>  ​    通常这里要检查以下内容</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li><li>….</li></ul></li></ul><h3 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h3><p>​    这一阶段将会<strong>为类变量分配内存并设置类变量初始值，这些内存都会在方法区中分配（JDK1.6）。</strong>注意，这里的类变量是指<code>被static修饰的变量</code>，实例变量将会在对象实例化随着对象分配到Java堆中。并且，初始值是指数据类型的零值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>​    这里，准备阶段后，初始值为0，不是123，将value赋值为123的操作在初始化阶段才会执行</p><p>​    但会存在特殊情况，如果某个变量是<code>不可变</code>的，例如上述变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>​    这样，准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将<code>value</code>赋值为123</p><h3 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h3><p>​    这一阶段将会<strong>将常量池内的符号引用替换为直接引用</strong>。符号引用的解析可以出现多次，虚拟机实现可能会对第一次解析的结果进行缓存，以便后续使用。</p><p>​    解析动作主要针对以下四类进行</p><ul><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ul><p>​    由于这些篇幅过长，就不细说，具体查看《深入理解Java虚拟机》</p><h3 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h3><p>​    这一阶段是<strong>通过程序制定的主观计划去初始化类变量和其他资源</strong>，从另一方面说，是<strong>执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</strong>。这一方法运行的行为和细节如下：</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值操作和<code>static&#123;&#125;块</code>合并产生。</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数不同，不需要显式调用父类构造器，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</li><li>通过以上两点可知，父类定义的静态语句块要优于子类的变量赋值操作</li><li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁和同步</li></ul><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3 类加载器"></a>3 类加载器</h2><p>​    通过对前面类加载过程的阐述，可以发现除了在加载阶段用户应用程序可以通过<strong>自定义类加载器</strong>参与之外，其余动作完全由虚拟机主导和控制。类加载器提高了JVM的可扩展性，是Java语言流行一大原因。</p><h3 id="3-1-双亲委派模型"><a href="#3-1-双亲委派模型" class="headerlink" title="3.1 双亲委派模型"></a>3.1 双亲委派模型</h3><p>​    绝大部分Java程序都会使用到以下三种系统提供的类加载器：</p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）</li><li>扩展类加载器（<code>Extension ClassLoader</code>）</li><li>应用程序类加载器（<code>Application ClassLoader</code>）</li></ul><p>​    应用程序都是由这三类类加载器互相配合进行加载的，如果有必要，可以加入自定义的类加载器</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220207232211098.png" alt="类加载器及双亲委派模型"></p><p>​    双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p><p>​    双亲委派模型的工作流程：</p><ul><li>一个类加载器收到类加载的请求，不会首先自己尝试加载该类</li><li>将该请求委派给父类加载器去完成，对于每个层次的类加载器都是如此</li><li>所有的加载请求最终都应该传送到顶层的启动类加载器中</li><li>只有当父加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载</li></ul><p>​    使用该模型的好处有如下：</p><ul><li><p>Java类和它的类加载器一起具备一种带有优先级的层次关系</p><blockquote><p>​    例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。如果您有</p></blockquote></li><li><p>上面的好处也从一定程度上防止了危险代码的植入</p></li></ul><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220207233247067.png" alt="双亲委派机制"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机-第3版》</p><p><a href="https://segmentfault.com/a/1190000037574626">jvm类加载器，类加载机制详解，看这一篇就够了 - SegmentFault 思否</a></p><p><a href="https://juejin.cn/post/6844903564804882445">Java类加载机制（全套） - 掘金 (juejin.cn)</a></p><p><a href="https://www.cnblogs.com/qlky/p/7643524.html">Java虚拟机 - 符号引用和直接引用理解 - qlky - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/weixin_38106322/article/details/109239971">(99条消息) 符号引用和直接引用有什么区别_绅士jiejie的博客-CSDN博客_符号引用和直接引用的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第279场周赛</title>
    <link href="/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC279%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC279%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="6000-对奇偶下标分别排序"><a href="#6000-对奇偶下标分别排序" class="headerlink" title="6000. 对奇偶下标分别排序"></a><a href="https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/">6000. 对奇偶下标分别排序</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortEvenOdd</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vec1, vec2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) vec1.<span class="hljs-built_in">push_back</span>(nums[i]); <span class="hljs-comment">// 偶数</span><br>            <span class="hljs-keyword">else</span> vec2.<span class="hljs-built_in">push_back</span>(nums[i]); <span class="hljs-comment">// 奇数</span><br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec1.<span class="hljs-built_in">begin</span>(), vec1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(vec2.<span class="hljs-built_in">begin</span>(), vec2.<span class="hljs-built_in">end</span>(), greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(vec1[j ++]);<br>            <span class="hljs-keyword">else</span> res.<span class="hljs-built_in">push_back</span>(vec2[k ++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6001-重排数字的最小值"><a href="#6001-重排数字的最小值" class="headerlink" title="6001. 重排数字的最小值"></a><a href="https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/">6001. 重排数字的最小值</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br>        <span class="hljs-keyword">while</span>(num) &#123;<br>            a.<span class="hljs-built_in">push_back</span>(num % <span class="hljs-number">10</span>);<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">smallestNumber</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">getNum</span>(num);<br>            <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, n =a.<span class="hljs-built_in">size</span>(), k = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>                <span class="hljs-keyword">if</span> (a[i] != <span class="hljs-number">0</span> &amp;&amp; flag)&#123;<br>                    k = i, flag = !flag;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <br>                vec.<span class="hljs-built_in">push_back</span>(a[i]);<br>            &#125;<br>            res += a[k] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, n - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> cnt = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                res += vec[i] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, cnt);<br>                cnt --;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n1 = -num;<br>            <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">getNum</span>(n1);<br>            <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>            <span class="hljs-keyword">int</span> cnt = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                res += a[i] * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, cnt);<br>                cnt --;<br>            &#125;<br>            res = -res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6002-设计位集"><a href="#6002-设计位集" class="headerlink" title="6002. 设计位集"></a><a href="https://leetcode-cn.com/problems/design-bitset/">6002. 设计位集</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bitset</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <br>    string bst, fbst;<br>    <span class="hljs-keyword">int</span> cnt;<br>    <span class="hljs-keyword">bool</span> flipped; <span class="hljs-comment">// 判断是否翻转</span><br>    <br>    <span class="hljs-built_in">Bitset</span>(<span class="hljs-keyword">int</span> size) &#123;<br>        bst = <span class="hljs-built_in">string</span>(size, <span class="hljs-string">&#x27;0&#x27;</span>);<br>        fbst = <span class="hljs-built_in">string</span>(size, <span class="hljs-string">&#x27;1&#x27;</span>);<br>        cnt = <span class="hljs-number">0</span>;<br>        flipped = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!flipped) &#123;<br>            <span class="hljs-keyword">if</span> (bst[idx] == <span class="hljs-string">&#x27;0&#x27;</span>) cnt ++;<br>            bst[idx] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            fbst[idx] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (bst[idx] == <span class="hljs-string">&#x27;1&#x27;</span>) cnt ++; <span class="hljs-comment">// 如果翻转了，则是fbit，那么翻转前是1，翻转后是0，fix设置fbit，则加1</span><br>            bst[idx] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            fbst[idx] = <span class="hljs-string">&#x27;1&#x27;</span>;    <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unfix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!flipped) &#123;<br>            <span class="hljs-keyword">if</span> (bst[idx] == <span class="hljs-string">&#x27;1&#x27;</span>) cnt --;<br>            bst[idx] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            fbst[idx] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (bst[idx] == <span class="hljs-string">&#x27;0&#x27;</span>) cnt --; <br>            bst[idx] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            fbst[idx] = <span class="hljs-string">&#x27;0&#x27;</span>;    <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flip</span><span class="hljs-params">()</span> </span>&#123;<br>        flipped = !flipped;<br>        cnt = bst.<span class="hljs-built_in">size</span>() - cnt;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">all</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt == bst.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">one</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!flipped) <span class="hljs-keyword">return</span> bst;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fbst;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Bitset object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Bitset* obj = new Bitset(size);</span><br><span class="hljs-comment"> * obj-&gt;fix(idx);</span><br><span class="hljs-comment"> * obj-&gt;unfix(idx);</span><br><span class="hljs-comment"> * obj-&gt;flip();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;all();</span><br><span class="hljs-comment"> * bool param_5 = obj-&gt;one();</span><br><span class="hljs-comment"> * int param_6 = obj-&gt;count();</span><br><span class="hljs-comment"> * string param_7 = obj-&gt;toString();</span><br><span class="hljs-comment"> */</span> <br></code></pre></td></tr></table></figure><h3 id="6003-移除所有载有违禁货物车厢所需的最少时间"><a href="#6003-移除所有载有违禁货物车厢所需的最少时间" class="headerlink" title="6003. 移除所有载有违禁货物车厢所需的最少时间"></a><a href="https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/">6003. 移除所有载有违禁货物车厢所需的最少时间</a></h3><p><a href="https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution/qian-hou-zhui-fen-jie-dp-by-endlesscheng-6u1b/">前后缀分解 + DP - 移除所有载有违禁货物车厢所需的最少时间</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        考虑左半部分的最少时间。</span><br><span class="hljs-comment">        当s[i] == &#x27;0&#x27; pre[i] = pre[i - 1]</span><br><span class="hljs-comment">        当s[i] == &#x27;1&#x27; pre[i] = min(pre[i - 1] + 2, i + 1)</span><br><span class="hljs-comment">        考虑右半部分的最少时间</span><br><span class="hljs-comment">        s[i] == &#x27;0&#x27; , suf[i] = suf[i + 1]</span><br><span class="hljs-comment">        s[i] == &#x27;1&#x27; , suf[i] = min(suf[i + 1] + 2, n - i)</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTime</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">suf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 移除后i个载有违禁货物车所需的最少单位时间数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            suf[i] = s[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? suf[i + <span class="hljs-number">1</span>] : <span class="hljs-built_in">min</span>(suf[i + <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>, n - i);<br>        &#125;<br><br>        <span class="hljs-comment">// 枚举分割点</span><br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, ans = suf[<span class="hljs-number">0</span>];  <span class="hljs-comment">// pre使用滚动数组优化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) pre = <span class="hljs-built_in">min</span>(pre + <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>);<br>            ans = <span class="hljs-built_in">min</span>(ans, pre + suf[i]);<br>        &#125; <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第71周双周赛</title>
    <link href="/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC71%E5%91%A8%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC71%E5%91%A8%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="5984-拆分数位后四位数字的最小和"><a href="#5984-拆分数位后四位数字的最小和" class="headerlink" title="5984. 拆分数位后四位数字的最小和"></a><a href="https://leetcode-cn.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/">5984. 拆分数位后四位数字的最小和</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>        <span class="hljs-keyword">int</span> t = num;<br>        <span class="hljs-keyword">while</span> (t) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> zero = <span class="hljs-built_in">count</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (zero == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> vec[<span class="hljs-number">3</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zero == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> vec[<span class="hljs-number">2</span>] + vec[<span class="hljs-number">3</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zero == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (vec[<span class="hljs-number">2</span>] &gt; vec[<span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> vec[<span class="hljs-number">1</span>] * <span class="hljs-number">10</span> + vec[<span class="hljs-number">3</span>] + vec[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">return</span> vec[<span class="hljs-number">1</span>] * <span class="hljs-number">10</span> + vec[<span class="hljs-number">2</span>] + vec[<span class="hljs-number">3</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> vec[<span class="hljs-number">0</span>] * <span class="hljs-number">10</span> + vec[<span class="hljs-number">2</span>] + vec[<span class="hljs-number">1</span>] * <span class="hljs-number">10</span> + vec[<span class="hljs-number">3</span>]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5985-根据给定数字划分数组"><a href="#5985-根据给定数字划分数组" class="headerlink" title="5985. 根据给定数字划分数组"></a><a href="https://leetcode-cn.com/problems/partition-array-according-to-given-pivot/">5985. 根据给定数字划分数组</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pivotArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vec1;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num: nums) <br>            <span class="hljs-keyword">if</span> (num &lt; pivot) vec1.<span class="hljs-built_in">push_back</span>(num);<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vec2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num: nums) <br>            <span class="hljs-keyword">if</span> (num &gt; pivot) vec2.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-keyword">int</span> tot = <span class="hljs-built_in">count</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), pivot);<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: vec1) res.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tot; i ++) res.<span class="hljs-built_in">push_back</span>(pivot);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: vec2) res.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5986-设置时间的最少代价"><a href="#5986-设置时间的最少代价" class="headerlink" title="5986. 设置时间的最少代价"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-set-cooking-time/">5986. 设置时间的最少代价</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        分类讨论</span><br><span class="hljs-comment">            因为秒数的范围[0,99], 分两种场景讨论:</span><br><span class="hljs-comment">            a. mins = target / 60, secs = target % 60;</span><br><span class="hljs-comment">            b. mins = target / 60 - 1, secs = target % 60 + 60;</span><br><span class="hljs-comment">            将mins*100+secs转为字符串进行处理, 求出花费的时间即可;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostSetTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startAt, <span class="hljs-keyword">int</span> moveCost, <span class="hljs-keyword">int</span> pushCost, <span class="hljs-keyword">int</span> targetSeconds)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> mins = targetSeconds / <span class="hljs-number">60</span>, secs = targetSeconds % <span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">int</span> ans1 = <span class="hljs-built_in">calTime</span>(startAt, moveCost, pushCost, mins, secs);<br>        <span class="hljs-keyword">int</span> ans2 = <span class="hljs-built_in">calTime</span>(startAt, moveCost, pushCost, mins - <span class="hljs-number">1</span>, secs + <span class="hljs-number">60</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ans1, ans2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startAt, <span class="hljs-keyword">int</span> moveCost, <span class="hljs-keyword">int</span> pushCost, <span class="hljs-keyword">int</span> mins, <span class="hljs-keyword">int</span> secs)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mins &lt; <span class="hljs-number">0</span> || mins &gt; <span class="hljs-number">99</span> || secs &gt; <span class="hljs-number">99</span>) &#123;<br>            <span class="hljs-keyword">return</span> INT_MAX;<br>        &#125;<br>        string s = <span class="hljs-built_in">to_string</span>(mins * <span class="hljs-number">100</span> + secs);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] - <span class="hljs-string">&#x27;0&#x27;</span> == startAt) &#123;<br>                ans += pushCost;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += pushCost + moveCost;<br>            &#125;<br>            startAt = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5987-删除元素后和的最小差值"><a href="#5987-删除元素后和的最小差值" class="headerlink" title="5987. 删除元素后和的最小差值"></a><a href="https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/">5987. 删除元素后和的最小差值</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        枚举i为分界点，维护0-i内长度为n / 3 的最小值，i + 1 - n - 1内长度为n / 3的最大值</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minimumDifference</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), k = n / <span class="hljs-number">3</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <br>        priority_queue&lt;<span class="hljs-keyword">int</span>&gt; small; <span class="hljs-comment">// 大根堆，维护0 - i内的最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * k; i ++) &#123;<br>            s1[i] = (i &gt; <span class="hljs-number">0</span>) ? s1[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>            small.<span class="hljs-built_in">push</span>(nums[i]);<br>            s1[i] += nums[i];<br>            <span class="hljs-keyword">if</span> (small.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>                s1[i] -= small.<span class="hljs-built_in">top</span>();<br>                small.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">s2</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; big; <span class="hljs-comment">// 小根堆，维护 i + 1 - n - 1内的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= k - <span class="hljs-number">1</span>; i --) &#123; <br>            <span class="hljs-comment">// 注意这里是n - 2的原因是，下面计算答案是从 k - 1 ~ 2 *k - 1，如果为n-1，会多算一个数进来</span><br>            <span class="hljs-comment">// 例如 1 2 3 4 5 6  ，n-2会使得下标为1的位置s[1] 表示 后4个数中最大值，n-1则表示5个数了</span><br>            s2[i] = s2[i + <span class="hljs-number">1</span>];<br>            big.<span class="hljs-built_in">push</span>(nums[i + <span class="hljs-number">1</span>]);<br>            s2[i] += nums[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (big.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>                s2[i] -= big.<span class="hljs-built_in">top</span>();<br>                big.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1e15</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * k; i ++) &#123;<br>            res = <span class="hljs-built_in">min</span>(res, s1[i] - s2[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组 "></a><a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 </span><br><span class="hljs-comment">            cur 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 curcur 值即可</span><br><span class="hljs-comment">        */</span><br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            cur += nums[i] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(cur)) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, i - hash[cur]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                hash[cur] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-II-010-和为-k-的子数组"><a href="#剑指-Offer-II-010-和为-k-的子数组" class="headerlink" title="剑指 Offer II 010. 和为 k 的子数组 "></a><a href="https://leetcode-cn.com/problems/QTMn0o/">剑指 Offer II 010. 和为 k 的子数组 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1，</span><br>        <span class="hljs-comment">// 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            res += hash[s[i] - k];<br>            hash[s[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper基本使用与集群搭建</title>
    <link href="/2022/02/04/%E6%A1%86%E6%9E%B6/zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/02/04/%E6%A1%86%E6%9E%B6/zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ZK简介"><a href="#1-ZK简介" class="headerlink" title="1. ZK简介"></a>1. ZK简介</h2><p>​    一个分布式的，开放源码的分布式应用程序协调服务。</p><h2 id="2-ZK数据模型"><a href="#2-ZK数据模型" class="headerlink" title="2. ZK数据模型"></a>2. ZK数据模型</h2><h3 id="2-1-模型结构"><a href="#2-1-模型结构" class="headerlink" title="2.1 模型结构"></a>2.1 模型结构</h3><p>​    <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115193533781.png" alt="image-20220115193533781"></p><h3 id="2-2-模型的特点"><a href="#2-2-模型的特点" class="headerlink" title="2.2 模型的特点"></a>2.2 模型的特点</h3><ul><li>每个子目录如/node1都被称作一个znode（节点）。这个znode是它所在的路径唯一标识</li><li>znode可以有子节点目录，并且每个znode可以存储数据</li><li>znode是有有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据</li><li>znode是可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端</li></ul><h2 id="3-节点的分类"><a href="#3-节点的分类" class="headerlink" title="3. 节点的分类"></a>3. 节点的分类</h2><h3 id="3-1-持久节点（PERSISTENT）"><a href="#3-1-持久节点（PERSISTENT）" class="headerlink" title="3.1  持久节点（PERSISTENT）"></a>3.1  持久节点（PERSISTENT）</h3><p>​    指在节点创建后，就一直存在，知道有删除操作来主动删除这个节点–会因为创建该节点的客户端会话失效而消失</p><h3 id="3-2-持久顺序节点（PERSISTENT-SEQUENTIAL）"><a href="#3-2-持久顺序节点（PERSISTENT-SEQUENTIAL）" class="headerlink" title="3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）"></a>3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）</h3><p>​    这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。</p><h3 id="3-3-临时节点（EPHEMERAL）"><a href="#3-3-临时节点（EPHEMERAL）" class="headerlink" title="3.3 临时节点（EPHEMERAL）"></a>3.3 临时节点（EPHEMERAL）</h3><p>​    和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。</p><h3 id="3-4-临时顺序节点（EPHEMERAL-SEQUENTIAL）"><a href="#3-4-临时顺序节点（EPHEMERAL-SEQUENTIAL）" class="headerlink" title="3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）"></a>3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）</h3><p>​    具有临时节点特点额外的特性是，每个父节点会为他的第一级子节点维护一份时序。这点和刚才提到的持久顺序节点类似</p><h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><h3 id="4-1-linux系统安装"><a href="#4-1-linux系统安装" class="headerlink" title="4.1 linux系统安装"></a>4.1 linux系统安装</h3><ul><li>安装JDK</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf jdk-8u171-linux-x64.tar.gz <br>mv ./jdk1.8.0_171/ /usr/java/<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/profile<br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115200800125.png" alt="image-20220115200800125"></p><ul><li>安装ZK</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115201522943.png" alt="image-20220115201522943"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> conf/<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115201545453.png" alt="image-20220115201545453"></p><p>由于zk默认加载的是<code>zoo.cfg</code>，所以需要改名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv zoo_sample.cfg zoo.cfg<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115201752620.png" alt="image-20220115201752620"></p><p>由于zookeeper加载要将节点加载到磁盘，所以需要预先新建一个磁盘目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir /tmp/zookeeper<br></code></pre></td></tr></table></figure><ul><li>启动ZK</li></ul><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115201952338.png" alt="image-20220115201952338"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost bin]<span class="hljs-comment"># ./zkServer.sh start /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg </span><br>ZooKeeper JMX enabled by default<br>Using config: /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg<br>Starting zookeeper ... STARTED<br><br><span class="hljs-comment"># 查看是否启动</span><br>jps<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115202134008.png" alt="image-20220115202134008"></p><p>​    QuorumPeerMain就是zk</p><ul><li>连接ZK</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./zkCli.sh -server 192.168.9.3:2181<br></code></pre></td></tr></table></figure><p>如果是本机，-server后可不加</p><h2 id="5-配置文件说明"><a href="#5-配置文件说明" class="headerlink" title="5. 配置文件说明"></a>5. 配置文件说明</h2><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115202623979.png" alt="image-20220115202623979"></p><ul><li><code>tickTime</code>：集群节点心跳时间，</li><li><code>initLimit</code>：初始化集群时集群节点同步超时时间20s</li><li><code>syncLimit</code>：集群在运行过程中，同步数据超时时间为10s（这里5是指5次心跳）</li><li><code>dataDir</code>：默认数据存储位置</li><li><code>clientPort</code>：zk服务监听端口号</li><li><code>maxClientCnxns</code>：线程池线程数量</li></ul><h2 id="6-客户端基本指令"><a href="#6-客户端基本指令" class="headerlink" title="6. 客户端基本指令"></a>6. 客户端基本指令</h2><ul><li>查看节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls / <span class="hljs-comment"># 根节点</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115203707976.png" alt="image-20220115203707976"></p><ul><li>创建节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">create path data <span class="hljs-comment"># 创建一个节点，并给节点绑定数据（默认是持久性节点）</span><br>- create path data <span class="hljs-comment"># 持久节点</span><br>- create -s path data <span class="hljs-comment"># 持久性顺序节点</span><br>- create -e path data <span class="hljs-comment"># 临时性节点</span><br>- create -e -s path data <span class="hljs-comment"># 临时顺序节点</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115204244695.png" alt="image-20220115204244695"></p><p><code>quit</code>：会直接导致会话断开，会话失效，其他ctrl+c会导致触发倒计时</p><p>注：临时节点上不能创建<strong>任何</strong>节点</p><ul><li>查看节点状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> /node1<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115204735555.png" alt="image-20220115204735555"></p><p><code>cZxid</code>：创建事务ID</p><p><code>ctime</code>：创建时间</p><p><code>mZxid</code>：修改ID</p><p><code>mtime</code>：修改时间</p><p><code>pZxid</code>：父结点版本号</p><p><code>cversion</code>：创建版本号</p><p><code>dataVersion</code>：数据版本号</p><p><code>aclVersion</code>：</p><p><code>ephemerslOwner</code>：是否是临时节点</p><p><code>dataLength</code>：存储数据长度</p><p><code>numChildren</code>：子节点数量</p><ul><li>获得节点上绑定的数据信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">get /node1<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115205118959.png" alt="image-20220115205118959"></p><ul><li>删除节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">delete /node1<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115205520902.png" alt="image-20220115205520902"></p><p>只能删除没有子节点的节点，如果有子节点，则无法删除</p><p>若想删除有子节点的，则需要<code>deleteall</code></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115205748540.png" alt="image-20220115205748540"></p><h2 id="7-watch节点监听机制"><a href="#7-watch节点监听机制" class="headerlink" title="7. watch节点监听机制"></a>7. watch节点监听机制</h2><p>监听分为<strong>节点目录监听</strong>和<strong>节点数据监听</strong></p><ul><li>目录监听是监听节点目录的变化</li><li>数据监听是监听当前节点数据的变化</li></ul><p>两种监听都是一次性的，也就是发现一个修改，下次修改则不会触发监听机制</p><ul><li>目录监听</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -w /node<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115210841507.png" alt="image-20220115210841507"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115210831701.png" alt="image-20220115210831701"></p><p>再次创建，无触发</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115210951358.png" alt="image-20220115210951358"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115210958554.png" alt="image-20220115210958554"></p><ul><li>数据监听</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">get -w /node <br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115211117526.png" alt="image-20220115211117526"></p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220115211125730.png" alt="image-20220115211125730"></p><h2 id="8-Java操作ZK"><a href="#8-Java操作ZK" class="headerlink" title="8. Java操作ZK"></a>8. Java操作ZK</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.test;<br><br><span class="hljs-keyword">import</span> org.I0Itec.zkclient.IZkChildListener;<br><span class="hljs-keyword">import</span> org.I0Itec.zkclient.IZkDataListener;<br><span class="hljs-keyword">import</span> org.I0Itec.zkclient.ZkClient;<br><span class="hljs-keyword">import</span> org.I0Itec.zkclient.serialize.SerializableSerializer;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.CreateMode;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestZKClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br><br>    <span class="hljs-comment">// 1. 在zk创建节点</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateNode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 持久节点</span><br>        zkClient.create(<span class="hljs-string">&quot;/node1&quot;</span>, <span class="hljs-string">&quot;xiaochen&quot;</span>, CreateMode.PERSISTENT);<br>        <span class="hljs-comment">// 2. 持久顺序节点</span><br>        zkClient.create(<span class="hljs-string">&quot;/node1/names&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, CreateMode.PERSISTENT_SEQUENTIAL);<br>        <span class="hljs-comment">// 3. 临时节点</span><br>        zkClient.create(<span class="hljs-string">&quot;/node1/lists&quot;</span>, <span class="hljs-string">&quot;xiaoxiao&quot;</span>, CreateMode.EPHEMERAL);<br>        <span class="hljs-comment">// 4. 临时顺序节点</span><br>        zkClient.create(<span class="hljs-string">&quot;/node1/lists1&quot;</span>, <span class="hljs-string">&quot;xiaoming&quot;</span>, CreateMode.EPHEMERAL_SEQUENTIAL);<br><br>    &#125;<br><br>    <span class="hljs-comment">// 2. 删除节点</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteNode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 删除没有子节点的节点，返回值：是否成功</span><br>        <span class="hljs-keyword">boolean</span> delete = zkClient.delete(<span class="hljs-string">&quot;/node1&quot;</span>);<br>        <span class="hljs-comment">// 递归删除节点信息，返回值：是否删除成功</span><br>        <span class="hljs-keyword">boolean</span> b = zkClient.deleteRecursive(<span class="hljs-string">&quot;/node1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 查询当前节点下所有子节点</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindNodes</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 获取指定路径的节点信息</span><br>        List&lt;String&gt; children = zkClient.getChildren(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String child : children) &#123;<br>            System.out.println(child);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 查看某个节点数据，注意：通过java客户端操作需要保证节点存储的数据和节点时序列化方式一致</span><br>    <span class="hljs-comment">// shell中的数据序列化方式和java中的不一致</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindNodeData</span><span class="hljs-params">()</span> </span>&#123;<br>        Object readData = zkClient.readData(<span class="hljs-string">&quot;/node3&quot;</span>);<br>        System.out.println(readData);<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 查看节点状态信息</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindNodeDataAndStat</span><span class="hljs-params">()</span> </span>&#123;<br>        Stat stat = <span class="hljs-keyword">new</span> Stat();<br>        Object readData = zkClient.readData(<span class="hljs-string">&quot;/node1&quot;</span>, stat);<br>        System.out.println(readData);<br>        System.out.println(stat);<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 修改节点数据</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWriteData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// User user = new User();</span><br>        <span class="hljs-comment">// user.setId(1);</span><br>        <span class="hljs-comment">// zkClient.writeData(&quot;/node1&quot;, user);</span><br>    &#125;<br><br>    <span class="hljs-comment">// 监听节点数据的变化</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOnNodeDataChange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        zkClient.subscribeDataChanges(<span class="hljs-string">&quot;/node1&quot;</span>, <span class="hljs-keyword">new</span> IZkDataListener() &#123;<br>            <span class="hljs-comment">// 当节点数据变化时触发对应这个方法</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String s, Object o)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;当前节点路径：&quot;</span> + s);<br>                System.out.println(<span class="hljs-string">&quot;当前节点变化后数据：&quot;</span> + o);<br>            &#125;<br>            <span class="hljs-comment">// 当前节点删除时触发这个方法</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;当前节点路径：&quot;</span> + s);<br>            &#125;<br>        &#125;);<br>        System.in.read(); <span class="hljs-comment">// 阻塞当前监听</span><br>    &#125;<br><br>    <span class="hljs-comment">// 监听节点目录的变化</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOnNodesChange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        zkClient.subscribeChildChanges(<span class="hljs-string">&quot;/node1&quot;</span>, <span class="hljs-keyword">new</span> IZkChildListener() &#123;<br>            <span class="hljs-comment">// 当节点的发生变化时，会自动调用这个方法</span><br>            <span class="hljs-comment">// 参数1：父节点名称</span><br>            <span class="hljs-comment">// 参数2：父节点中的所有子节点名称</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleChildChange</span><span class="hljs-params">(String s, List&lt;String&gt; list)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;父节点名称：&quot;</span> + s);<br>                System.out.println(<span class="hljs-string">&quot;发生变更后孩子节点名称：&quot;</span>);<br>                <span class="hljs-keyword">for</span> (String name: list) &#123;<br>                    System.out.println(name);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        System.in.read(); <span class="hljs-comment">// 阻塞当前监听</span><br>    &#125;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 参数1：Server服务器ip地址</span><br>        <span class="hljs-comment">// 参数2：会话超时时间</span><br>        <span class="hljs-comment">// 参数3：连接超时时间</span><br>        <span class="hljs-comment">// 参数4：序列化方式</span><br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(<span class="hljs-string">&quot;192.168.9.3:2181&quot;</span>, <span class="hljs-number">60000</span> * <span class="hljs-number">30</span>, <span class="hljs-number">60000</span>, <span class="hljs-keyword">new</span> SerializableSerializer());<br>    &#125;<br><br>    <span class="hljs-meta">@After</span> <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient.close();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-ZK集群"><a href="#9-ZK集群" class="headerlink" title="9. ZK集群"></a>9. ZK集群</h2><h3 id="9-1-集群（cluster）"><a href="#9-1-集群（cluster）" class="headerlink" title="9.1 集群（cluster）"></a>9.1 集群（cluster）</h3><p>​    集群是指同一种软件服务的多个节点同时提供服务</p><p>​    集群解决了什么问题？</p><ul><li>单节点的并发访问的压力问题</li><li>单节点故障问题</li></ul><h3 id="9-2-集群架构"><a href="#9-2-集群架构" class="headerlink" title="9.2 集群架构"></a>9.2 集群架构</h3><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220126170237466.png" alt="image-20220126170237466"></p><h3 id="9-3-集群搭建"><a href="#9-3-集群搭建" class="headerlink" title="9.3 集群搭建"></a>9.3 集群搭建</h3><ol><li>在~目录下新建三个文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir zkdata1 zkdata2 zkdata3<br></code></pre></td></tr></table></figure><ol start="2"><li>建立myid文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch zkdata1/myid zkdata2/myid zkdata3/myid<br></code></pre></td></tr></table></figure><ol start="3"><li>为每个zk指定id</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;1&quot; &gt;&gt; zkdata1/myid <br>echo &quot;2&quot; &gt;&gt; zkdata2/myid <br>echo &quot;3&quot; &gt;&gt; zkdata3/myid<br></code></pre></td></tr></table></figure><ol start="4"><li>添加配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim zkdata1/zoo.cfg<br>vim zkdata2/zoo.cfg<br>vim zkdata3/zoo.cfg<br><br>tickTime=2000<br>initLimit=10<br>syncLimit=5<br>dataDir=/root/zkdata1<br>clientPort=3001<br>server.1=196.168.9.3:3002:3003<br>server.2=192.158.9.3:4002:4003<br>server.3=192.168.9.3:5002:5003<br><br></code></pre></td></tr></table></figure><ol start="5"><li>相关操作</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动</span><br>./bin/zkServer.sh start /root/zkdata1/zoo.cfg<br>./bin/zkServer.sh start /root/zkdata2/zoo.cfg<br>./bin/zkServer.sh start /root/zkdata3/zoo.cfg<br><span class="hljs-meta">#</span><span class="bash"> 查看状态</span><br>./bin/zkServer.sh status /root/zkdata1/zoo.cfg<br><span class="hljs-meta">#</span><span class="bash"> 停止</span><br>./bin/zkServer.sh stop /root/zkdata1/zoo.cfg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo从入门到实战</title>
    <link href="/2022/02/04/%E6%A1%86%E6%9E%B6/dubbo%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <url>/2022/02/04/%E6%A1%86%E6%9E%B6/dubbo%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-互联网系统架构演变"><a href="#1-互联网系统架构演变" class="headerlink" title="1 互联网系统架构演变"></a>1 互联网系统架构演变</h2><p>​    随着互联网的发展，网站应用规模不断壮大，由此系统架构也在不断演变，下图是一张经典的演变过程图：</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204143340306.png" alt="image-20220204143340306"></p><ul><li><p>单一应用架构</p><p>  ​    优点：当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本</p><p>  ​    缺点：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护</p><p>  ​    此时：用于简化增删改查工作量的<strong>数据访问框架（ORM）</strong>是关键</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204135821620.png" alt="image-20220204135821620"></p></li><li><p>垂直应用架构</p><p>  ​    优点：解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率</p><p>  ​    缺点：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。</p><p>  ​    此时：用于加速前端页面开发的<strong>Web框架（MVC）</strong>是关键</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204140523510.png" alt="image-20220204140523510"></p></li><li><p>分布式应用架构（RPC）</p><p>  ​    当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心</p><p>  ​    此时：用于提高业务复用及整合的<strong>分布式服务框架（RPC）</strong>是关键</p><p>  <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204140538092.png" alt="image-20220204140538092"></p></li><li><p>流动计算架构（SOA）</p><p>  ​    随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架</p><p>  ​    此时，用于提高机器利用率**资源调度和治理中心(SOA)**是关键。</p></li></ul><h2 id="2-什么是Dubbo"><a href="#2-什么是Dubbo" class="headerlink" title="2 什么是Dubbo"></a>2 什么是Dubbo</h2><p>​    Dubbo是一个微服务开发框架，提供了<strong>RPC通信</strong>与<strong>微服务治理</strong>两大关键能力。它提供了远程过程调用的能力，使得远程调用像本地调用一样方便</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204205020171.png" alt="image-20220204205020171"></p><p>​        Dubbo提供的基础能力包括：</p><ul><li>服务发现</li><li>流式通信</li><li>负载均衡</li><li>流量治理</li><li>集群容错</li><li>服务降级</li><li>…</li></ul><h2 id="3-Dubbo总体架构"><a href="#3-Dubbo总体架构" class="headerlink" title="3 Dubbo总体架构"></a>3 Dubbo总体架构</h2><p>​    以下是官网的一张图</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204205839887.png" alt="image-20220204205839887"></p><table><thead><tr><th>节点</th><th>说明</th></tr></thead><tbody><tr><td>Consumer</td><td>需要调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>注册中心</td></tr><tr><td>Provider</td><td>服务提供方</td></tr><tr><td>Container</td><td>服务运行的容器</td></tr><tr><td>Monitor</td><td>监控中心</td></tr></tbody></table><p>​    通过上图，可以知道服务发现整体流程如下：</p><ol><li>服务提供者Provider启动然后向注册中心注册自己所能提供的服务。</li><li>消费者Consumer启动向注册中心订阅所需的服务。</li><li>然后注册中心返回服务提供者地址列表给消费者Consumer，如果有变更，注册中心将基于长连接推送变更数据给消费者Consumer。</li><li>消费者Consumer就可以负载均衡选择一个Provier直接调用。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li></ol><h2 id="4-快速入门"><a href="#4-快速入门" class="headerlink" title="4 快速入门"></a>4 快速入门</h2><p>​    新建两个Maven项目，JDK版本1.8，Dubbo版本2.7，一个消费者，一个提供者</p><p><img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204211356423.png" alt="image-20220204211356423"></p><ol><li><p>引入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tiza.leo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo_001_p<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--引入依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--   core  context  beans  spring三件套--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--    dubbo  2.5.3--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--      zookeeper   zkclient--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.101tec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--  junit--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>提供端代码</p><p> <img src="https://raw.githubusercontent.com/2w1nd/pic-bed/main/blog/image-20220204211624171.png" alt="image-20220204211624171"></p><p> UserService</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.dubbo.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">findName</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>   <span class="hljs-title">addUser</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> UserServiceImpl</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.dubbo.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">findName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;姓名:&quot;</span> +name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello: &quot;</span>+name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;添加用户,用户名为: &quot;</span>+username);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> spring-dubbo.xml（重要）</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--suppress SpringFacetInspection --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--通过duboo发布服务 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo_001_p&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:application</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--将服务注册到指定的注册中心--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;multicast://224.5.6.7:1234&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:registry</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--指定服务的协议 和 使用端口号   注意此处服务端使用客户端无需使用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:provider</span>&gt;</span>                                              <span class="hljs-comment">&lt;!--定义超时时间方式一--&gt;</span><br>    <span class="hljs-comment">&lt;!--注册服务到注册中心--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.w1nd.dubbo.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;4000&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--定义超时时间方二--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;findName&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;3000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:method</span>&gt;</span>                              <span class="hljs-comment">&lt;!--定义超时时间方式三--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--服务提供者--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.w1nd.dubbo.service.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 测试代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.dubbo.publish;<br><br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PublishServiceTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-dubbo.xml&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务提供者,开始提供服务.....&quot;</span>);<br>        System.in.read();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费端代码</p><p> UserService</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.dubbo.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">findName</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>   <span class="hljs-title">addUser</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> spring-dubbo.xml（重要）</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--suppress SpringFacetInspection --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--通过dubbo消费服务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo_001_c&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--指定的注册中心--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;multicast://224.5.6.7:1234&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:registry</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--关闭所有服务的启动时检查 (没有提供者时报错)：--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:consumer</span>&gt;</span>          <span class="hljs-comment">&lt;!--定义超时时间方式一--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--调用服务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.w1nd.dubbo.service.UserService&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;4000&quot;</span>  &gt;</span>     <span class="hljs-comment">&lt;!--定义超时时间方式二--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;findName&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;3000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:method</span>&gt;</span>                                   <span class="hljs-comment">&lt;!--定义超时时间方式三--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 测试代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.w1nd.dubbo.invoke;<br><br><span class="hljs-keyword">import</span> com.w1nd.dubbo.service.UserService;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvokeServiceTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-dubbo.xml&quot;</span>);<br>        UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>        userService.addUser(<span class="hljs-string">&quot;w1nd&quot;</span>);<br>       <span class="hljs-comment">/* String serverReturn = userService.findName(&quot;GouSheng&quot;);</span><br><span class="hljs-comment">        System.out.println(&quot;get message from server message is  &quot; + serverReturn);*/</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-集群"><a href="#5-集群" class="headerlink" title="5 集群"></a>5 集群</h2><p>​    不同消费者的使用端口号设置不一样，即可。</p><p>dubbo_cluster_001_p</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20881&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>dubbo_cluster_002_p</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20882&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>dubbo_cluster_003_p</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20883&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_35190492/article/details/108071612?ops_request_misc=%7B%22request_id%22:%22164397818316780357231616%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164397818316780357231616&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-108071612.pc_search_insert_ulrmf&utm_term=dubbo&spm=1018.2226.3001.4187">(96条消息) 朋友国企干了5年java，居然不知道Dubbo是做什么呢？我真信了！_敖丙-CSDN博客</a></p><p><a href="https://dubbo.apache.org/zh/docs/introduction/">Dubbo3 简介 | Apache Dubbo</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-II-008-和大于等于-target-的最短子数组"><a href="#剑指-Offer-II-008-和大于等于-target-的最短子数组" class="headerlink" title="剑指 Offer II 008. 和大于等于 target 的最短子数组"></a><a href="https://leetcode-cn.com/problems/2VG8Kg/">剑指 Offer II 008. 和大于等于 target 的最短子数组</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), sum = <span class="hljs-number">0</span>, res = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">while</span> (sum - nums[j] &gt;= target) sum -= nums[j ++];<br>            <span class="hljs-keyword">if</span> (sum &gt;= target) res = <span class="hljs-built_in">min</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == INT_MAX ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-II-009-乘积小于-K-的子数组"><a href="#剑指-Offer-II-009-乘积小于-K-的子数组" class="headerlink" title="剑指 Offer II 009. 乘积小于 K 的子数组 "></a><a href="https://leetcode-cn.com/problems/ZVAVXX/">剑指 Offer II 009. 乘积小于 K 的子数组 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//已知ABC &lt; target, 新增一位X变成ABCX, 若ABCX &lt; target 则新增的subarray中必须满足 1.连续 2.包含X</span><br>        <span class="hljs-comment">//所以从X向左数: X, CX, BCX, ABCX</span><br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), product = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            product *= nums[i];<br>            <span class="hljs-keyword">while</span> (i &gt;= j &amp;&amp; product &gt;= k) product /= nums[j ++];<br>            res += i - j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/QTMn0o/">剑指 Offer II 010. 和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1，</span><br>        <span class="hljs-comment">// 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            res += hash[s[i] - k];<br>            hash[s[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;    <span class="hljs-comment">// 存储子串各个字符数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: s1) hash[c] ++;    <br>        <span class="hljs-keyword">int</span> tot = hash.<span class="hljs-built_in">size</span>(), statify = <span class="hljs-number">0</span>; <span class="hljs-comment">// tot是字符总数，statify是s2中满足要求的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s2.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (--hash[s2[i]] == <span class="hljs-number">0</span>) statify ++; <br>            <span class="hljs-keyword">while</span> (i - j + <span class="hljs-number">1</span> &gt; s1.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 窗口大小小于s1.size</span><br>                <span class="hljs-keyword">if</span> (hash[s2[j]] == <span class="hljs-number">0</span>) statify --;<br>                hash[s2[j ++]] ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (statify == tot) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t) hash[c] ++;<br>        <span class="hljs-keyword">int</span> tot = hash.<span class="hljs-built_in">size</span>(), statify = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[s[i]] == <span class="hljs-number">1</span>) statify ++;<br>            hash[s[i]] --;<br>            <span class="hljs-keyword">while</span> (hash[s[j]] &lt; <span class="hljs-number">0</span>) hash[s[j ++]] ++;    <span class="hljs-comment">// 注意这里是&lt;，所以不会出现后续的不符合要求的字符顶去前面的，例如BANC，N的出现不会将B删去</span><br>            <span class="hljs-keyword">if</span> (statify == tot) &#123;<br>                <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">empty</span>() || res.<span class="hljs-built_in">size</span>() &gt; i - j + <span class="hljs-number">1</span>) &#123;<br>                    res = s.<span class="hljs-built_in">substr</span>(j, i - j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-II-004-只出现一次的数字"><a href="#剑指-Offer-II-004-只出现一次的数字" class="headerlink" title="剑指 Offer II 004. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/WGki4K/">剑指 Offer II 004. 只出现一次的数字</a></h3><p><a href="https://leetcode-cn.com/problems/WGki4K/solution/shua-chuan-jian-zhi-offer-day02-zheng-sh-tlce/">刷穿剑指offer-Day02-整数II 004.只出现一次的数字 位运算讲解 - 只出现一次的数字</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i ++) &#123; <br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num: nums) &#123;<br>                cnt += num &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;<br>                ret |= <span class="hljs-number">1</span> &lt;&lt; i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-II-005-单词长度的最大乘积"><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><a href="https://leetcode-cn.com/problems/aseY1I/">剑指 Offer II 005. 单词长度的最大乘积</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dict</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: words[i]) &#123;<br>                <span class="hljs-keyword">int</span> bit = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                t |= (<span class="hljs-number">1</span> &lt;&lt; bit);<br>            &#125;<br>            dict[i] = t;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) <br>                <span class="hljs-keyword">if</span> ((dict[i] &amp; dict[j]) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">int</span> temp = words[i].<span class="hljs-built_in">size</span>() * words[j].<span class="hljs-built_in">size</span>();<br>                    ans = <span class="hljs-built_in">max</span>(ans, temp);<br>                &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状压DP</title>
    <link href="/2022/02/03/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%8A%B6%E5%8E%8BDP/"/>
    <url>/2022/02/03/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%8A%B6%E5%8E%8BDP/</url>
    
    <content type="html"><![CDATA[<h3 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countArrangement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; n;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(mask, <span class="hljs-number">0</span>));<br><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 考虑前i个数，状态为0的方案数（优美排列数量）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   <span class="hljs-comment">// 枚举当前位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> state = <span class="hljs-number">1</span>; state &lt;= mask; state ++)  <span class="hljs-comment">// 枚举当前状态，0为选该数，1为不选</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++)  &#123;  <span class="hljs-comment">// 枚举当前位置填了什么数</span><br>                    <span class="hljs-keyword">if</span> (!((state &gt;&gt; (k - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果当前数在状态中为0，则跳过</span><br>                    <span class="hljs-keyword">if</span> (k % i &amp;&amp; i % k) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 不满足任何整除关系</span><br>                    <span class="hljs-comment">// state &amp; (~(1 &lt;&lt; (k - 1))) 代表将 state 中数值 k 的位置置零</span><br>                    f[i][state] += f[i - <span class="hljs-number">1</span>][state &amp; ~(<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))];<br>                &#125;<br>        <span class="hljs-keyword">return</span> f[n][mask - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; n;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(mask, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX)); <span class="hljs-comment">// state和u(该状态下的最后一步)对应的步数</span><br>        deque&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; d; <span class="hljs-comment">// 存储state 和 u</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            dist[<span class="hljs-number">1</span> &lt;&lt; i][i] = <span class="hljs-number">0</span>;<br>            d.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span> &lt;&lt; i, i&#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!d.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> poll = d.<span class="hljs-built_in">front</span>();<br>            d.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">int</span> state = poll[<span class="hljs-number">0</span>], u = poll[<span class="hljs-number">1</span>], step = dist[state][u];<br>            <span class="hljs-keyword">if</span> (state == mask - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i: graph[u]) &#123;<br>                <span class="hljs-keyword">if</span> (dist[state | (<span class="hljs-number">1</span> &lt;&lt; i)][i] == INT_MAX) &#123;<br>                    dist[state | (<span class="hljs-number">1</span> &lt;&lt; i)][i] = step + <span class="hljs-number">1</span>;<br>                    d.<span class="hljs-built_in">push_back</span>(&#123;state | (<span class="hljs-number">1</span> &lt;&lt; i), i&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>状态DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2022/02/02/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2022/02/02/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h3 id="87-扰乱字符串"><a href="#87-扰乱字符串" class="headerlink" title="87. 扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/">87. 扰乱字符串</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isScramble</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (s1 == s2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt;  <span class="hljs-built_in">f</span>(n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)));<br><br>        <span class="hljs-comment">// 处理长度为1的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">if</span> (s1[i] == s2[j]) f[i][j][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// f[i][j][len] 代表 s1s1 从 ii 开始，s2s2 从 jj 开始，后面长度为 lenlen 的字符是否能形成「扰乱字符串」（互为翻转）。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - len; i ++) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n - len; j ++)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k ++) &#123; <span class="hljs-comment">// 分割点</span><br>                        <span class="hljs-comment">// a : 0 - i, b : 0 - j ; a: i - n, j - n</span><br>                        <span class="hljs-keyword">bool</span> a = f[i][j][k] &amp;&amp; f[i + k][j + k][len - k];<br>                        <span class="hljs-comment">// a : 0 - i, b : n - i, n ; a: i - n, 0 - j</span><br>                        <span class="hljs-keyword">bool</span> b = f[i][j + len - k][k] &amp;&amp; f[i + k][j][len - k];<br>                        <span class="hljs-keyword">if</span> (a || b) &#123;<br>                            f[i][j][len] = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="375-猜数字大小-II"><a href="#375-猜数字大小-II" class="headerlink" title="375. 猜数字大小 II"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//定义 f[l][r]f[l][r] 为考虑在 [l, r][l,r] 范围内进行猜数的最小成本。</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-comment">// 需要找到能猜中数字的最小成本，也就是最坏情况最好的结果</span><br>        <span class="hljs-comment">// 对于任一区间取min是因为我们在该区间可以先选择小的数去试，由此降低成本</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= n; l ++) &#123;<br>                <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>                f[l][r] = <span class="hljs-number">0x3f3f3f3f</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = l; x &lt;= r; x ++) &#123;<br>                    <span class="hljs-keyword">int</span> cur = <span class="hljs-built_in">max</span>(f[l][x - <span class="hljs-number">1</span>], f[x + <span class="hljs-number">1</span>][r]) + x;<br>                    f[l][r] = <span class="hljs-built_in">min</span>(f[l][r], cur);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        bb aa bb</span><br><span class="hljs-comment">        bb a  bb</span><br><span class="hljs-comment">        dp[i][j] 表示 第 i 个字符到 第 j 个字符之间最长的回文子序列长度</span><br><span class="hljs-comment">        1、当 s[i] == s[j] 时，考虑 i 和 j 中间序列的奇偶个数， dp[i][j] = dp[i+1][j-1] + 2</span><br><span class="hljs-comment">        对上述 dp[i][j] =  dp[i+1][j-1] + 2 的解释：</span><br><span class="hljs-comment">        当序列为 b aa b 时， i = 0, j = 3，则 dp[0][3] = dp[1][2] + 2 = 4</span><br><span class="hljs-comment">        当序列为 b a b 时，i = 0, j = 2，则 dp[0][2] = dp[1][1] + 2 = 3 </span><br><span class="hljs-comment">        当序列为 b b 时， i = 0, j = 1，则 dp[0][1] = dp[1][0] = 0 + 2 = 2 (dp[1][0] 默认值为 0)</span><br><span class="hljs-comment">        该式子同时考虑到了奇偶</span><br><span class="hljs-comment">        2、当 s[i] != s[j] ，那么 dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1])</span><br><span class="hljs-comment">        对上述 dp[i][j] 式子的解释：</span><br><span class="hljs-comment">        假如序列为 d c b c c（index：0-4），s[0] != s[4] ，则 dp[0][4] = Math.max(dp[0][3],dp[1,4]) = Math.max(2,3) = 3</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            f[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    f[i][j] = f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i + <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="664-奇怪的打印机"><a href="#664-奇怪的打印机" class="headerlink" title="664. 奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">664. 奇怪的打印机</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strangePrinter</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// f[i][j] 表示 区间[i,j]的最小打印次数</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            f[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    f[i][j] = f[i][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k ++) &#123;<br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="hljs-number">1</span>][j]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; piles)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义 f[l][r]f[l][r] 为考虑区间 [l,r][l,r]，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt;= n;  len ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= n; l ++) &#123;<br>                <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> a = piles[l - <span class="hljs-number">1</span>] + f[l + <span class="hljs-number">1</span>][r];<br>                <span class="hljs-keyword">int</span> b = piles[r - <span class="hljs-number">1</span>] + f[l][r - <span class="hljs-number">1</span>];<br>                f[l][r] = <span class="hljs-built_in">max</span>(a, b);<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">1</span>][n] &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列DP</title>
    <link href="/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%BA%8F%E5%88%97DP/"/>
    <url>/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%BA%8F%E5%88%97DP/</url>
    
    <content type="html"><![CDATA[<h3 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列 "></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> small = INT_MAX, big = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>            <span class="hljs-keyword">if</span> (x &lt;= small) &#123;<br>                small = x;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt;= big) &#123;<br>                big = x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>; <span class="hljs-comment">// f[len] = x 表示 以 长度为 len 的序列的最小尾元素为x</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> x = nums[i];<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123; <span class="hljs-comment">// 二分查找小于nums[i]的最小元素</span><br>                <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (f[mid] &gt;= x) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>; <br>            &#125;<br>            f[r] = x;<br>            ans = <span class="hljs-built_in">max</span>(ans, r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &gt;= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题 "></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = envelopes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 以 i 结尾的最大信封</span><br>        <span class="hljs-built_in">sort</span>(envelopes.<span class="hljs-built_in">begin</span>(), envelopes.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (envelopes[i][<span class="hljs-number">0</span>] &gt; envelopes[j][<span class="hljs-number">0</span>] &amp;&amp; envelopes[i][<span class="hljs-number">1</span>] &gt; envelopes[j][<span class="hljs-number">1</span>]) <br>                    f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集 "></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">368. 最大整除子集 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">largestDivisibleSubset</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// f[i] 表示 前i个数中以a[i]结尾的整除子集的最长序列的元素个数</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 整除序列最后一个元素下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) <br>                <span class="hljs-keyword">if</span> (nums[i] % nums[j] == <span class="hljs-number">0</span>) <br>                    f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (f[k] &lt; f[i]) k = i;<br>        &#125;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res; <span class="hljs-comment">// 逆推得出答案</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums[k]);<br>            <span class="hljs-keyword">if</span> (f[k] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 只剩一个元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++) &#123;<br>                <span class="hljs-keyword">if</span> ((nums[k] % nums[i] == <span class="hljs-number">0</span>) &amp;&amp; f[k] == f[i] + <span class="hljs-number">1</span>) &#123;<br>                    k = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="390-消除游戏"><a href="#390-消除游戏" class="headerlink" title="390. 消除游戏 "></a><a href="https://leetcode-cn.com/problems/elimination-game/">390. 消除游戏 </a></h3><p><img src="image/image-20220126114611818-16436168322851.png" alt="image-20220126114611818"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> - <span class="hljs-built_in">lastRemaining</span>(n / <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="446-等差数列划分-II-子序列"><a href="#446-等差数列划分-II-子序列" class="headerlink" title="446. 等差数列划分 II - 子序列 "></a><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/submissions/">446. 等差数列划分 II - 子序列 </a></h3><p><a href="https://www.acwing.com/solution/content/61868/">LeetCode 446. 等差数列划分 II - 子序列 - AcWing</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 由于每个数可能都会在不同等差数列中，需要用哈希表来存</span><br>        vector&lt;unordered_map&lt;LL, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n); <span class="hljs-comment">// f[i][j] 表示 考虑以第 i 个数结尾 公差为j的等差数列的个数</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; i; k ++) &#123;<br>                LL j = (LL)a[i] - a[k];<br>                <span class="hljs-keyword">auto</span> it = f[k].<span class="hljs-built_in">find</span>(j); <span class="hljs-comment">// 查找a[k]结尾公差为j的等差数列的个数</span><br>                <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (it != f[k].<span class="hljs-built_in">end</span>()) &#123;<br>                    t = it-&gt;second;<br>                    res += t;<br>                &#125;<br>                f[i][j] += t + <span class="hljs-number">1</span>;<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="472-连接词"><a href="#472-连接词" class="headerlink" title="472. 连接词 "></a><a href="https://leetcode-cn.com/problems/concatenated-words/">472. 连接词 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br>    unordered_set&lt;ULL&gt; hash;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> P = <span class="hljs-number">131</span>;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findAllConcatenatedWordsInADict</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化字符串哈希表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;s: words) &#123;<br>            ULL t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: s) &#123;<br>                t = t * P + c;<br>            &#125;<br>            hash.<span class="hljs-built_in">insert</span>(t);<br>        &#125;<br><br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;s: words) <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s)) res.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// f[i] 表示 在i前面的连接词的个数</span><br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (f[i]== <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            ULL cur = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j ++) &#123;<br>                cur = cur * P + str[j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(cur)) &#123;<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[i] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[n] &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作 "></a><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/submissions/">583. 两个字符串的删除操作 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = word1.<span class="hljs-built_in">size</span>(), m = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++) f[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]);<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">int</span> maxn = f[n][m] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> n + m - <span class="hljs-number">2</span> * maxn;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="629-K个逆序对数组"><a href="#629-K个逆序对数组" class="headerlink" title="629. K个逆序对数组 "></a><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组 </a></h3><p><a href="https://www.acwing.com/solution/content/18355/">LeetCode 629. K个逆序对数组 - AcWing</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kInversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// f[i][j] 表示 所有由数字 1 ~ i 组成的含有 j 个 逆序对的数组个数</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j ++) &#123;<br>                s += f[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= i) s -= f[i - <span class="hljs-number">1</span>][j - i];<br>                f[i][j] = s % MOD;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> (f[n][k] + MOD) % MOD;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数 "></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span>, <span class="hljs-title">g</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// f 表示 以i结尾的最长上升子序列长度，g 表示 以 i 结尾的最长上升子序列的个数</span><br>        <br>        <span class="hljs-keyword">int</span> maxl = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxl是最长子序列长度，cnt是子序列个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            f[i] = g[i] = <span class="hljs-number">1</span>; <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    <span class="hljs-keyword">if</span> (f[i] &lt; f[j] + <span class="hljs-number">1</span>) f[i] = f[j] + <span class="hljs-number">1</span>, g[i] = g[j];<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f[i] == f[j] + <span class="hljs-number">1</span>) g[i] += g[j];<br>                &#125; <br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxl &lt; f[i]) maxl = f[i], cnt = g[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxl == f[i]) cnt += g[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="689-三个无重叠子数组的最大和"><a href="#689-三个无重叠子数组的最大和" class="headerlink" title="689. 三个无重叠子数组的最大和 "></a><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSumOfThreeSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(); <br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            sum += nums[i];<br><br>            <span class="hljs-keyword">if</span> (i &gt;= k) sum -= nums[i - k];<br><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) s[i - k + <span class="hljs-number">1</span>] = sum;<br>        &#125;   <br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> maxIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (s[maxIndex] &lt; s[i]) <br>                maxIndex = i;<br>            left[i] = maxIndex;<br>        &#125;<br><br>        maxIndex = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (s[maxIndex] &lt;= s[i]) <br>                maxIndex = i;<br>            right[i] = maxIndex;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; n - k; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (res[<span class="hljs-number">0</span>] == <span class="hljs-number">-1</span> || s[res[<span class="hljs-number">0</span>]] + s[res[<span class="hljs-number">1</span>]] + s[res[<span class="hljs-number">2</span>]] &lt; s[i] + s[left[i - k]] + s[right[i + k]]) &#123;<br>                res[<span class="hljs-number">0</span>] = left[i - k];<br>                res[<span class="hljs-number">1</span>] = i;<br>                res[<span class="hljs-number">2</span>] = right[i + k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="740-删除并获得点数"><a href="#740-删除并获得点数" class="headerlink" title="740. 删除并获得点数 "></a><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// f[i][j] 表示是否删除 j 数 的 最大点数</span><br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(N)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x: nums) &#123;<br>            cnt[x] ++;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, x);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(maxn + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxn; i ++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            f[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + cnt[i] * i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[maxn][<span class="hljs-number">0</span>], f[maxn][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组 "></a><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 优化了空间</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// f[i][0/1]表示 以i结尾的数组 元素状态为j的最大湍流子数组长度</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j ++) f[i % <span class="hljs-number">2</span>][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>] &lt; arr[i]) f[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = f[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>] &gt; arr[i]) f[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = f[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j ++) ans = <span class="hljs-built_in">max</span>(ans, f[i % <span class="hljs-number">2</span>][j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线 "></a><a href="https://leetcode-cn.com/problems/uncrossed-lines/submissions/">1035. 不相交的线 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxUncrossedLines</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// f[i][j] 表示 考虑 前 i 个 数字，前 j 个数字组成最大公共子序列长度</span><br>        <span class="hljs-comment">// 最长公共子序列 是考虑的情况是不一定包含第i个字符的</span><br>        <span class="hljs-comment">// 例如，我们通常考虑f[i - 1][j]为前i - 1，j个数字的最长子序列，但这里不一定包含第j个，只是可能，所以 f[i - 1][j] 包含 f[i - 1][j - 1];</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列 "></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = text1.<span class="hljs-built_in">size</span>(), m = text2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1218-最长定差子序列"><a href="#1218-最长定差子序列" class="headerlink" title="1218. 最长定差子序列 "></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 注意覆盖问题：hash.insert遇到一样的键不会覆盖</span><br>    <span class="hljs-comment">// 由于 arr长度 为 1e5，不能用两层循环，使用哈希表进行优化</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubsequence</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> diff)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// f[i][j] 表示 前i个数，第i个数选或不选的最长定差子序列长度</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        hash[arr[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            f[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> prev = arr[i] - diff;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(prev)) &#123;<br>                f[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">1</span>], f[hash[prev]][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>            hash[arr[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1473-粉刷房子-III"><a href="#1473-粉刷房子-III" class="headerlink" title="1473. 粉刷房子 III "></a><a href="https://leetcode-cn.com/problems/paint-house-iii/">1473. 粉刷房子 III </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; houses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; cost, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-comment">// f[i][j][k] 表示 考慮前i个房子，第i个房子粉刷为j，分区数量为k的所有方案中的最小总花费</span><br>        vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(t + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>                f[i][j][<span class="hljs-number">0</span>] = INF;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> color = houses[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 当前房子的颜色</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= t; k ++) &#123;<br>                    <span class="hljs-keyword">if</span> (k &gt; i) &#123; <span class="hljs-comment">// 如果分区数量大于房子数，不合法</span><br>                        f[i][j][k] = INF;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (color != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当前房子已经染色</span><br>                        <span class="hljs-keyword">if</span> (color == j) &#123; <span class="hljs-comment">// 只有与当前颜色相同才能被转移</span><br>                            <span class="hljs-keyword">int</span> tmp = INF;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>; p &lt;= m; p ++) &#123; <span class="hljs-comment">// 与前面颜色不同（可组成分区的情况）</span><br>                                <span class="hljs-keyword">if</span> (p != j) &#123;<br>                                    tmp = <span class="hljs-built_in">min</span>(tmp, f[i - <span class="hljs-number">1</span>][p][k - <span class="hljs-number">1</span>]);<br>                                &#125;<br>                            &#125;<br>                            f[i][j][k] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j][k], tmp); <span class="hljs-comment">// 与前面颜色相同的情况</span><br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            f[i][j][k] = INF;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当前房子未被染色</span><br>                        <span class="hljs-keyword">int</span> u = cost[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">int</span> tmp = INF;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>; p &lt;= m; p ++) &#123; <span class="hljs-comment">// 与前面颜色不同（可组成分区的情况）</span><br>                            <span class="hljs-keyword">if</span> (p != j) &#123;<br>                                tmp = <span class="hljs-built_in">min</span>(tmp, f[i - <span class="hljs-number">1</span>][p][k - <span class="hljs-number">1</span>]);<br>                            &#125;<br>                        &#125;<br>                        f[i][j][k] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j][k], tmp) + u; <span class="hljs-comment">// 与前面颜色相同的情况</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> ans = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++) ans = <span class="hljs-built_in">min</span>(ans, f[n][i][t]);<br>        <span class="hljs-keyword">return</span> ans == INF ? <span class="hljs-number">-1</span>: ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1713-得到子序列的最少操作次数"><a href="#1713-得到子序列的最少操作次数" class="headerlink" title="1713. 得到子序列的最少操作次数 "></a><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        target 6 4 8 1 3 2</span><br><span class="hljs-comment">        arr    4 7 6 2 3 8 6 1</span><br><span class="hljs-comment">        list   1 0 5 4 2 0 3</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; t, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = t.<span class="hljs-built_in">size</span>(), m = a.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) hash.<span class="hljs-built_in">insert</span>(&#123;t[i], i&#125;);<br>        <span class="hljs-comment">// 建立 target 和 arr 的映射关系</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; list;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;<br>             <span class="hljs-comment">// 由于target各元素不相同，list中保存了arr与target相同元素的下标，并且递增，故可转化为LIS问题</span><br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(x))  list.<span class="hljs-built_in">push_back</span>(hash[x]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> cnt = list.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// q[i] 表示 长度为i的上升子序列 中末尾元素最小的数</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">q</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 使用LIS的贪心+二分的方法求解，复杂度为nlog(n)</span><br>        <span class="hljs-comment">// 个人感觉这种优化方式主要是维护一个单调队列，每次加入新的元素，要和之前加入的对比，</span><br>        <span class="hljs-comment">// 找到比自己小的最后一个数，那么它就可以代替这之前的那个数，因为它更小，更好维护递增序列，</span><br>        <span class="hljs-comment">// 例如 1 3 5 ，加入1个4（规定长度3），那肯定4替换掉5更好</span><br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++) &#123;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt; list[i]) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            q[r + <span class="hljs-number">1</span>] = list[i];<br>            <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &gt; len) len ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>序列DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string ss, string pp)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = ss.<span class="hljs-built_in">size</span>(), m = pp.<span class="hljs-built_in">size</span>();<br>        string s = <span class="hljs-string">&quot; &quot;</span> + ss;<br>        string p = <span class="hljs-string">&quot; &quot;</span> + pp;<br>        <span class="hljs-comment">// dp状态表示：dp[i][j] s以i结尾的子串与p以j结尾的子串是否匹配</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(m + <span class="hljs-number">1</span>)); <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= m &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 下一个是*，当前 字符不能单独使用，跳过</span><br><br>                <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; p[j] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>); <span class="hljs-comment">// 对应了p[j]为普通字符和&#x27;.&#x27;两种情况</span><br>                &#125;<br><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 字符为&#x27;*&#x27;</span><br>                    dp[i][j] = (j - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i][j - <span class="hljs-number">2</span>]) || (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; (s[i] == p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>));<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string ss, string pp)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = ss.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> m = pp.<span class="hljs-built_in">size</span>();<br>        string s = <span class="hljs-string">&quot; &quot;</span> + ss;<br>        string p = <span class="hljs-string">&quot; &quot;</span> + pp;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(m + <span class="hljs-number">1</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (p[j] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    dp[i][j] = i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (p[j] == s[i] || p[j] == <span class="hljs-string">&#x27;?&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">while</span> (j + nums[j] &lt; i) j ++;<br>            dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string ss)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = ss.<span class="hljs-built_in">size</span>();<br>        string s = <span class="hljs-string">&quot; &quot;</span> + ss;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> a = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>, b = (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">1</span> &amp;&amp; a &lt;= <span class="hljs-number">9</span>) dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (b &gt;= <span class="hljs-number">10</span> &amp;&amp; b &lt;= <span class="hljs-number">26</span>) dp[i] += dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string ss, string tt)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = ss.<span class="hljs-built_in">size</span>(), m = tt.<span class="hljs-built_in">size</span>();<br>        string s = <span class="hljs-string">&quot; &quot;</span> + ss;<br>        string t = <span class="hljs-string">&quot; &quot;</span> + tt;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// f[i][j] 表示 0~i，0~j的字符串匹配个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                <span class="hljs-comment">// 不匹配s[i]</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (s[i] == t[j]) &#123; <span class="hljs-comment">// 匹配s[i]</span><br>                    dp[i][j] = (<span class="hljs-number">0LL</span> + dp[i][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % INT_MAX;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(rowIndex + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j --) &#123;<br>                <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (dp[j] == <span class="hljs-number">0</span>) dp[j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowIndex + <span class="hljs-number">1</span>; i ++) res.<span class="hljs-built_in">push_back</span>(dp[i]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-comment">// 不选第1间, 0不选，1选</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> res1 = <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i ++) &#123;<br>            dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);    <br>        &#125;<br>        <span class="hljs-keyword">int</span> res2 = <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res1, res2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canCross</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (stones[<span class="hljs-number">1</span>] != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// dp[i][j]表示跳到位置i步长为j是否可以</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++) &#123;<br>                <span class="hljs-keyword">int</span> k = stones[i] - stones[j]; <span class="hljs-comment">// 步长</span><br>                <span class="hljs-keyword">if</span>(k &lt;= j + <span class="hljs-number">1</span>) &#123;<br>                    dp[i][k] = dp[j][k - <span class="hljs-number">1</span>] || dp[j][k] || dp[j][k + <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) <br>            <span class="hljs-keyword">if</span> (dp[n - <span class="hljs-number">1</span>][i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576. 出界的路径数"></a><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/">576. 出界的路径数</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">int</span> n, m, maxn;<br><br>    <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _m, <span class="hljs-keyword">int</span> _n, <span class="hljs-keyword">int</span> _maxMove, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        n = _m, m = _n, maxn = _maxMove;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n * m, vector&lt;<span class="hljs-keyword">int</span>&gt;(maxn + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 初始化边缘</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-built_in">add</span>(i, j, dp);<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) <span class="hljs-built_in">add</span>(i, j, dp);<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(i, j, dp);<br>                <span class="hljs-keyword">if</span> (j == m - <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(i, j, dp);<br>            &#125;<br><br>        <span class="hljs-comment">// f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= maxn; k ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; idx &lt; m * n; idx ++) &#123;<br>                <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>                info = <span class="hljs-built_in">parseIdx</span>(idx);<br>                <span class="hljs-keyword">int</span> x = info[<span class="hljs-number">0</span>], y = info[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>                    <span class="hljs-keyword">int</span> nx = x + dx[i], ny = y + dy[i];<br>                    <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">int</span> nidx = <span class="hljs-built_in">getIdx</span>(nx, ny);<br>                    dp[idx][k] += dp[nidx][k - <span class="hljs-number">1</span>];<br>                    dp[idx][k] %= MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>           <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">getIdx</span>(r, c)][maxn];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;dp)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= maxn; k ++) &#123;<br>            dp[<span class="hljs-built_in">getIdx</span>(x, y)][k] ++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * m + y;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parseIdx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;idx / m, idx % m&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="639-解码方法-II"><a href="#639-解码方法-II" class="headerlink" title="639. 解码方法 II"></a><a href="https://leetcode-cn.com/problems/decode-ways-ii/submissions/">639. 解码方法 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-comment">// i 表示当前遍历字符下标，j表示前一个字符下标</span><br>    <span class="hljs-comment">// f[i] 表示 以 s[i] 结尾的字符串，共有多少种解码方法</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        s[i] == &#x27;*&#x27;：</span><br><span class="hljs-comment">            s[i]可以单独组成一个，f[i] += f[i - 1] * 9</span><br><span class="hljs-comment">            可以和前面的字符组成：</span><br><span class="hljs-comment">                若s[j] == 1，那么 f[i] += f[i - 2] * 9 (11 - 19)</span><br><span class="hljs-comment">                若s[j] == 2，那么 f[i] += f[i - 2] * 6 (21 - 26)</span><br><span class="hljs-comment">                若s[j] == *，那么 f[i] += f[i - 2] * 15</span><br><span class="hljs-comment">        s[i] != &#x27;*&#x27;，s[i]为数字时：</span><br><span class="hljs-comment">            s[j] 为 &#x27;*&#x27;：</span><br><span class="hljs-comment">                s[i] == 0，f[i] += f[i - 2] * 2;  （10，20）</span><br><span class="hljs-comment">                s[i] != 0：</span><br><span class="hljs-comment">                    f[i] = f[i - 1] (1 - 9)</span><br><span class="hljs-comment">                    1 &lt;= s[i] &lt;= 6  f[i] += f[i - 2] * 2    （11 - 16，21 - 26）</span><br><span class="hljs-comment">                    7 &lt;= s[i] &lt;= 9  f[i] += f[i - 2] * 1    （17 - 19）</span><br><span class="hljs-comment">            s[j] != &#x27;*&#x27;：</span><br><span class="hljs-comment">                s[i] == 0，f[i] = f[i - 2] (10, 20)</span><br><span class="hljs-comment">                s[i] != 0： </span><br><span class="hljs-comment">                    f[i] = f[i - 1] (1 - 9)</span><br><span class="hljs-comment">                    s[j] == 1，f[i] = f[i - 2]; (11 - 19)</span><br><span class="hljs-comment">                    s[j] == 2 且 1 &lt;= s[i] &lt;= 6 ，f[i] = f[i - 2]; (21 - 26)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">long</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 注意这里要long</span><br>        f[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> ? <span class="hljs-number">9</span> : (s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">char</span> c = s[i], prev = s[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                f[i] += f[i - <span class="hljs-number">1</span>] * <span class="hljs-number">9</span>;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-string">&#x27;*&#x27;</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>) * <span class="hljs-number">15</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">int</span> u = prev - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>) * <span class="hljs-number">9</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (u == <span class="hljs-number">2</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>) * <span class="hljs-number">6</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> t = c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (prev == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        f[i] += f[i - <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">1</span> &amp;&amp; t &lt;= <span class="hljs-number">6</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">7</span> &amp;&amp; t &lt;= <span class="hljs-number">9</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>);<br>                    &#125; <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">int</span> u = prev - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span> || u == <span class="hljs-number">2</span>) &#123;<br>                            f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        f[i] = f[i - <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>);<br>                        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">2</span> &amp;&amp; t &lt;= <span class="hljs-number">6</span>) f[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            f[i] %= MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// f[i][j]表示经过最后一次操作，记事本上有i个字符，粘贴板上有j个字符的最小操作次数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_INT = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, MAX_INT));<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> minN = MAX_INT;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i / <span class="hljs-number">2</span>; j ++) &#123;<br>                dp[i][j] = dp[i - j][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// paste</span><br>                minN = <span class="hljs-built_in">min</span>(minN, dp[i][j]); <br>            &#125;<br>            dp[i][i] = minN + <span class="hljs-number">1</span>; <span class="hljs-comment">// copy all</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> res = MAX_INT;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) res = <span class="hljs-built_in">min</span>(res, dp[n][i]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/submissions/">678. 有效的括号字符串</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">char</span> c = s[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;  <br>                    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= i) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) dp[i][j] = dp[i][j] | dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= i) dp[i][j] = dp[i][j] | dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1220-统计元音字母序列的数目"><a href="#1220-统计元音字母序列的数目" class="headerlink" title="1220. 统计元音字母序列的数目"></a><a href="https://leetcode-cn.com/problems/count-vowels-permutation/">1220. 统计元音字母序列的数目</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-comment">// dp[i][j] 表示 长度为i的字符串，结尾为j的字符串 的 个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countVowelPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">long</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-comment">// 每个元音 &#x27;a&#x27; 后面都只能跟着 &#x27;e&#x27;</span><br>            dp[i][<span class="hljs-number">1</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 每个元音 &#x27;e&#x27; 后面只能跟着 &#x27;a&#x27; 或者是 &#x27;i&#x27;</span><br>            dp[i][<span class="hljs-number">0</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            dp[i][<span class="hljs-number">2</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 每个元音 &#x27;i&#x27; 后面 不能 再跟着另一个 &#x27;i&#x27;</span><br>            dp[i][<span class="hljs-number">0</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            dp[i][<span class="hljs-number">1</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            dp[i][<span class="hljs-number">3</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            dp[i][<span class="hljs-number">4</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 每个元音 &#x27;o&#x27; 后面只能跟着 &#x27;i&#x27; 或者是 &#x27;u&#x27;</span><br>            dp[i][<span class="hljs-number">2</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>            dp[i][<span class="hljs-number">4</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>             <span class="hljs-comment">// 每个元音 &#x27;u&#x27; 后面只能跟着 &#x27;a&#x27;</span><br>            dp[i][<span class="hljs-number">0</span>] += dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j ++) dp[i][j] %= MOD;<br>        &#125;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) res += dp[n - <span class="hljs-number">1</span>][i];<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (res % MOD);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1751-最多可以参加的会议数目-II"><a href="#1751-最多可以参加的会议数目-II" class="headerlink" title="1751. 最多可以参加的会议数目 II"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/">1751. 最多可以参加的会议数目 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)</span> </span>&#123; <span class="hljs-comment">// 升序排序</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt;= b[<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; events, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = events.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">sort</span>(events.<span class="hljs-built_in">begin</span>(), events.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d %d %d]&quot;</span>, events[i][<span class="hljs-number">0</span>], events[i][<span class="hljs-number">1</span>], events[i][<span class="hljs-number">2</span>]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">auto</span> p = events[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> s = p[<span class="hljs-number">0</span>], e = p[<span class="hljs-number">1</span>], v = p[<span class="hljs-number">2</span>];<br><br>            <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = i - <span class="hljs-number">1</span>; t &gt;= <span class="hljs-number">1</span>; t --) &#123;<br>                <span class="hljs-keyword">auto</span> l = events[t - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (s &gt; l[<span class="hljs-number">1</span>]) &#123;<br>                    last = t; <span class="hljs-comment">// 更新为不冲突的事件下标</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j ++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[last][j - <span class="hljs-number">1</span>] + v); <span class="hljs-comment">// 选与不选</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1787-使所有区间的异或结果为零"><a href="#1787-使所有区间的异或结果为零" class="headerlink" title="1787. 使所有区间的异或结果为零"></a><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/">1787. 使所有区间的异或结果为零</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        易知，将nums排列为一个二维数组（每行为k个），问题将转化为：</span><br><span class="hljs-comment">            使得每列相等，且最终首行异或值为0的更改元素数</span><br><span class="hljs-comment">        定义 f[i][xor]为考虑前i列，且首行前i列异或值的xor的更改元素数</span><br><span class="hljs-comment">        由于需要知道i - 1列的最小更改元素数，使之转态转移，所以需要一个状态数组prev</span><br><span class="hljs-comment">        另外，使用</span><br><span class="hljs-comment">        map记录每一列数字对应的个数</span><br><span class="hljs-comment">        cnt记录每一列数字总数</span><br><span class="hljs-comment">        所以，分析状态转移方程</span><br><span class="hljs-comment">        当在第0列时：</span><br><span class="hljs-comment">            f[0][xor] = f[0][xor] + cnt - map[xor]</span><br><span class="hljs-comment">        当在其他列时，需要考虑从前一列转移的状态：</span><br><span class="hljs-comment">            另外，还有</span><br><span class="hljs-comment">                考虑整列修改：</span><br><span class="hljs-comment">                    f[i][xor] = f[i - 1][xor] + cnt;</span><br><span class="hljs-comment">                考虑部分修改：</span><br><span class="hljs-comment">                    f[i][xor] = f[i - 1][xor ^ cur] + cnt - map[cur];</span><br><span class="hljs-comment">    */</span>  <br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxVal = INT_MAX / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxHalf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minChanges</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k, vector&lt;<span class="hljs-keyword">int</span>&gt;(maxHalf, maxVal));<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">prev</span><span class="hljs-params">(k, maxVal)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++) &#123; <span class="hljs-comment">// 遍历每一列</span><br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; map;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j += k) &#123;<br>                map[nums[j]] ++;<br>                cnt ++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 第0列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; maxHalf; x ++) &#123;<br>                    dp[<span class="hljs-number">0</span>][x] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][x], cnt - map[x]);<br>                    prev[<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(prev[<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][x]);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 其他列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; maxHalf; x ++) &#123;<br>                    dp[i][x] = prev[i - <span class="hljs-number">1</span>] + cnt;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it: map) &#123;<br>                        dp[i][x] = <span class="hljs-built_in">min</span>(dp[i][x], dp[i - <span class="hljs-number">1</span>][x ^ it.first] + cnt - it.second);<br>                    &#125;<br>                    prev[i] = <span class="hljs-built_in">min</span>(prev[i], dp[i][x]);<br>                &#125;<br>            &#125;   <br>        &#125;   <br>        <span class="hljs-keyword">return</span> dp[k - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> ans = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i], dp[i - <span class="hljs-number">1</span>] + nums[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++) <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;r: relation) &#123;<br>                <span class="hljs-keyword">int</span> a = r[<span class="hljs-number">0</span>], b = r[<span class="hljs-number">1</span>];<br>                dp[i][b] += dp[i - <span class="hljs-number">1</span>][a];<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="87-扰乱字符串"><a href="#87-扰乱字符串" class="headerlink" title="87. 扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/">87. 扰乱字符串</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; cache;<br>    <span class="hljs-keyword">int</span> Y = <span class="hljs-number">1</span>, N = <span class="hljs-number">-1</span>;<br>    string s1, s2;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isScramble</span><span class="hljs-params">(string _s1, string _s2)</span> </span>&#123;<br>        s1 = _s1, s2 = _s2;<br>        <span class="hljs-keyword">if</span> (s1 == s2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// cache表示s1从i开始，s2从j开始 len 位，是否形成扰动字符串</span><br>        cache.<span class="hljs-built_in">resize</span>(n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache[i][j][len] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cache[i][j][len] == Y;<br>        string a = s1.<span class="hljs-built_in">substr</span>(i, len), b = s2.<span class="hljs-built_in">substr</span>(j, len);<br>        <span class="hljs-keyword">if</span> (a == b)&#123;<br>            cache[i][j][len] = Y;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(a, b)) &#123;<br>            cache[i][j][len] = N;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k ++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, j, k) &amp;&amp; <span class="hljs-built_in">dfs</span>(i + k, j + k, len - k)) &#123;<br>                cache[i][j][len] = Y;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, len - k + j, k) &amp;&amp; <span class="hljs-built_in">dfs</span>(i + k, j, len - k)) &#123;<br>                cache[i][j][len] = Y;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        cache[i][j][len] = N;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() != b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt1</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">cnt2</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: s1) &#123;<br>            cnt1[c - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: s2) &#123;<br>            cnt2[c - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt1 == cnt2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="375-猜数字大小-II"><a href="#375-猜数字大小-II" class="headerlink" title="375. 猜数字大小 II"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; cache;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        cache.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (cache[l][r] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cache[l][r];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = l; x &lt;= r; x ++) &#123;<br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(l, x - <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, r)) + x;<br>            ans = <span class="hljs-built_in">min</span>(ans, cnt);<br>        &#125;<br>        cache[l][r] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    unordered_map&lt;string, <span class="hljs-keyword">bool</span>&gt; cache; <span class="hljs-comment">// 存储u下标跳k步有没有方案</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; map; <span class="hljs-comment">// 存储每个石块对应的下标</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canCross</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n  = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            map.<span class="hljs-built_in">insert</span>(&#123;stones[i], i&#125;);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(stones, n, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;stones, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        string key = <span class="hljs-built_in">to_string</span>(u) + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-built_in">to_string</span>(k);<br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> cache[key];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">-1</span>; i &lt;= <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (k + i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">int</span> next = stones[u] + i + k;  <span class="hljs-comment">// 下一个跳跃点</span><br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(next)) &#123;<br>                <span class="hljs-keyword">bool</span> cur = <span class="hljs-built_in">dfs</span>(stones, n, map[next], k + i);<br>                cache.<span class="hljs-built_in">insert</span>(&#123;key, cur&#125;);<br>                <span class="hljs-keyword">if</span> (cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        cache.<span class="hljs-built_in">insert</span>(&#123;key, <span class="hljs-literal">false</span>&#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; cache; <span class="hljs-comment">// 表示从u下标,当前计算结果为string，的方案数int</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br>        string key = <span class="hljs-built_in">to_string</span>(u) + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-built_in">to_string</span>(cur); <br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> cache[key];<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            cache.<span class="hljs-built_in">insert</span>(&#123;key, cur == target ? <span class="hljs-number">1</span>: <span class="hljs-number">0</span>&#125;);<br>            <span class="hljs-keyword">return</span> cache[key];<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">dfs</span>(nums, target, u + <span class="hljs-number">1</span>, cur - nums[u]);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">dfs</span>(nums, target, u + <span class="hljs-number">1</span>, cur + nums[u]);<br>        cache.<span class="hljs-built_in">insert</span>(&#123;key, left + right&#125;);<br>        <span class="hljs-keyword">return</span> cache[key];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="552-学生出勤记录-II"><a href="#552-学生出勤记录-II" class="headerlink" title="552. 学生出勤记录 II"></a><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// cache 是指 下标为u，连续a个数为acnt，l个数为lcnt的方案数</span><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; cache;<br>    <span class="hljs-keyword">int</span> mod = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkRecord</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        cache.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>)));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> acnt, <span class="hljs-keyword">int</span> lcnt)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (acnt &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (lcnt &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cache[u][acnt][lcnt] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> cache[u][acnt][lcnt];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        ans = <span class="hljs-built_in">dfs</span>(u - <span class="hljs-number">1</span>, acnt + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) % mod;  <span class="hljs-comment">// A</span><br>        ans = (ans + <span class="hljs-built_in">dfs</span>(u - <span class="hljs-number">1</span>, acnt, lcnt + <span class="hljs-number">1</span>)) % mod; <span class="hljs-comment">// L</span><br>        ans = (ans + <span class="hljs-built_in">dfs</span>(u - <span class="hljs-number">1</span>, acnt, <span class="hljs-number">0</span>)) % mod; <span class="hljs-comment">// P</span><br>        cache[u][acnt][lcnt] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="576-出界的路径数"><a href="#576-出界的路径数" class="headerlink" title="576. 出界的路径数"></a><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/">576. 出界的路径数</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; cache;<br>    <span class="hljs-keyword">int</span> MOD = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> maxMove, <span class="hljs-keyword">int</span> startRow, <span class="hljs-keyword">int</span> startColumn)</span> </span>&#123;<br>        cache.<span class="hljs-built_in">resize</span>(maxMove + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">-1</span>)));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(m, n, maxMove, startRow, startColumn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= m || x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &gt;= n || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (cache[u][x][y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> cache[u][x][y];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        ans = <span class="hljs-built_in">dfs</span>(m, n, u - <span class="hljs-number">1</span>, x + <span class="hljs-number">1</span>, y) % MOD;<br>        ans = (ans + <span class="hljs-built_in">dfs</span>(m, n, u - <span class="hljs-number">1</span>, x, y + <span class="hljs-number">1</span>)) % MOD;<br>        ans = (ans + <span class="hljs-built_in">dfs</span>(m, n, u - <span class="hljs-number">1</span>, x, y - <span class="hljs-number">1</span>)) % MOD;<br>        ans = (ans + <span class="hljs-built_in">dfs</span>(m, n, u - <span class="hljs-number">1</span>, x - <span class="hljs-number">1</span>, y)) % MOD;<br>        cache[u][x][y] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">int</span> cache[<span class="hljs-number">40</span>];<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tribonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cache[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cache[n];<br>        cache[n] = <span class="hljs-built_in">tribonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">tribonacci</span>(n - <span class="hljs-number">2</span>) + <span class="hljs-built_in">tribonacci</span>(n - <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">return</span> cache[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">int</span> mod = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">int</span> cache[<span class="hljs-number">110</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span> (cache[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cache[n];<br>        cache[n] = <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);<br>        cache[n] %= mod;<br>        <span class="hljs-keyword">return</span> cache[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包 "></a><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; price;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; special;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; needs;<br>    map&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">int</span>&gt; cache;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shoppingOffers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; _price, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; _special, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; _needs)</span> </span>&#123;<br>        price = _price;<br>        special = _special;<br>        needs = _needs;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(needs);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; needs)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">count</span>(needs)) &#123;<br>            <span class="hljs-keyword">return</span> cache[needs];<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = needs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> minN = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            minN += price[i] * needs[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; special.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; nextNeeds = needs;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (special[i][j] &gt; nextNeeds[j]) flag = <span class="hljs-literal">false</span>;<br>                nextNeeds[j] -= special[i][j];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">continue</span>;<br>            minN = <span class="hljs-built_in">min</span>(minN, <span class="hljs-built_in">dfs</span>(nextNeeds) + special[i][n]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache[needs] = minN;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包DP</title>
    <link href="/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85DP/"/>
    <url>/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85DP/</url>
    
    <content type="html"><![CDATA[<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数 "></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i] 表示 能凑出i的完全平方数的最小数量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            dp[i] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; i - j * j &gt;= <span class="hljs-number">0</span>; j ++)<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换 "></a><a href="https://leetcode-cn.com/problems/coin-change/submissions/">322. 零钱兑换 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = coins.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coins[i]; j &lt;= amount; j ++)<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (dp[amount] == <span class="hljs-number">1e9</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集 "></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: nums) sum += x;<br>        <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target * <span class="hljs-number">2</span> != sum) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// dp[i] 表示 凑出 i 所需的价值数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x: nums)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= x; j --) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - x] + x);<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[target] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零 "></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = strs.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">cnt</span>(len, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>            <span class="hljs-keyword">int</span> zero = <span class="hljs-number">0</span>, one = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: strs[i]) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) one ++;<br>                <span class="hljs-keyword">else</span> zero ++;<br>            &#125;<br>            cnt[i][<span class="hljs-number">0</span>] = zero, cnt[i][<span class="hljs-number">1</span>] = one;<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k ++) &#123;<br>            <span class="hljs-keyword">int</span> zero = cnt[k][<span class="hljs-number">0</span>], one = cnt[k][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= zero; i --)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= one; j --) &#123;<br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - zero][j - one] + <span class="hljs-number">1</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和 "></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Offset = <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i: a) s += <span class="hljs-built_in">abs</span>(i);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(t) &gt; s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * s + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][s] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = -s; j &lt;= s; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (j - a[i - <span class="hljs-number">1</span>] &gt;= -s) dp[i][j + s] += dp[i - <span class="hljs-number">1</span>][j - a[i - <span class="hljs-number">1</span>] + s];<br>                <span class="hljs-keyword">if</span> (j + a[i - <span class="hljs-number">1</span>] &lt;= s) dp[i][j + s] += dp[i - <span class="hljs-number">1</span>][j + a[i - <span class="hljs-number">1</span>] + s];<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[n][t + s];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II "></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i][j] 表示 考虑前i个物品，凑出 j 的方案数</span><br>        <span class="hljs-keyword">int</span> n = coins.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coins[i]; j &lt;= amount; j ++) &#123;<br>                dp[j] += dp[j - coins[i]];<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="879-盈利计划"><a href="#879-盈利计划" class="headerlink" title="879. 盈利计划 "></a><a href="https://leetcode-cn.com/problems/profitable-schemes/">879. 盈利计划 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; <br>    <span class="hljs-comment">// dp[i][j][k] 表示 前i个个物品，人数不超过j，利润至少为k的方案数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">profitableSchemes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> minProfit, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; group, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; profit)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = group.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(minProfit + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++) &#123;<br>            <span class="hljs-keyword">int</span> a = group[i - <span class="hljs-number">1</span>], b = profit[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= a; j --)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = minProfit; k &gt;= <span class="hljs-number">0</span>; k --) &#123;<br>                    dp[j][k] += dp[j - a][<span class="hljs-built_in">max</span>(k - b, <span class="hljs-number">0</span>)];<br>                    dp[j][k] %= MOD;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][minProfit];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II "></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II </a></h3><p><strong>未优化空间</strong></p><p>问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值<br>进一步分析：要让差值小,两堆石头的重量都要接近sum/2;我们假设两堆分别为A,B,A&lt;sum/2,B&gt;sum/2,若A更接近sum/2,B也相应更接近sum/2<br>进一步转化：将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// d[i][j]代表考虑前 i 个物品（数值），凑成总和不超过 j 的最大价值。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: stones) sum += x;<br>        <span class="hljs-keyword">int</span> t = sum / <span class="hljs-number">2</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(t + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> x = stones[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= t; j ++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= x) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - x] + x);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[n][t];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>优化空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: stones) sum += x;<br>        <span class="hljs-keyword">int</span> t = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(t + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> x = stones[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = t; j &gt;= x; j --) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - x] + x);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[t];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法 "></a><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/submissions/">1155. 掷骰子的N种方法 </a></h3><p><strong>未优化空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n  + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(t + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= t; j ++) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++) &#123;<br>                    <span class="hljs-keyword">if</span>(j &gt;= k) f[i][j] = (f[i][j] + f[i - <span class="hljs-number">1</span>][j - k]) % MOD;<br>                &#125;<br>        <span class="hljs-keyword">return</span> f[n][t];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>优化空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(t + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = t; j &gt;= <span class="hljs-number">0</span>; j --) &#123;<br>                f[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//由于我们直接是在 f[i][j]f[i][j] 格子的基础上进行方案数累加，因此在计算 f[i][j]f[i][j] 记得手动置零。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++) &#123;<br>                    <span class="hljs-keyword">if</span>(j &gt;= k) f[j] = (f[j] + f[j - k]) % MOD;<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[t];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1449-数位成本和为目标值的最大数字"><a href="#1449-数位成本和为目标值的最大数字" class="headerlink" title="1449. 数位成本和为目标值的最大数字 "></a><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/">1449. 数位成本和为目标值的最大数字 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// dp[i][j] 表示 考虑前i个物品，总成本为j的最大整数长度</span><br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(t + <span class="hljs-number">1</span>, INT_MIN)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> x = cost[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = x; j &lt;= t; j ++) &#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - x] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dp[t] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>, j = t; i &gt;= <span class="hljs-number">1</span>; i --) &#123;<br>            <span class="hljs-keyword">int</span> x = cost[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (j &gt;= x &amp;&amp; dp[j] == dp[j - x] + <span class="hljs-number">1</span>) &#123;<br>                res += <span class="hljs-built_in">to_string</span>(i);<br>                j -= x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1995-统计特殊四元组"><a href="#1995-统计特殊四元组" class="headerlink" title="1995. 统计特殊四元组 "></a><a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组 </a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countQuadruplets</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i][j][k] 考虑前i个数，恰好凑出j，使用个数为k的方案数</span><br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">110</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">int</span> x = nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">110</span>; j ++) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k ++) &#123;<br>                    f[i][j][k] += f[i - <span class="hljs-number">1</span>][j][k];<br>                    <span class="hljs-keyword">if</span> (j &gt;= x &amp;&amp; k &gt;= <span class="hljs-number">1</span>) f[i][j][k] += f[i - <span class="hljs-number">1</span>][j - x][k - <span class="hljs-number">1</span>];<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; n; i ++) res += f[i][nums[i]][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>背包DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
