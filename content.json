{"pages":[{"title":"","text":"About Me​ 一个菜狗","link":"/about/index.html"}],"posts":[{"title":"dubbo从入门到实战","text":"1 互联网系统架构演变​ 随着互联网的发展，网站应用规模不断壮大，由此系统架构也在不断演变，下图是一张经典的演变过程图： 单一应用架构 ​ 优点：当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本 ​ 缺点：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护 ​ 此时：用于简化增删改查工作量的数据访问框架（ORM）是关键 垂直应用架构 ​ 优点：解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率 ​ 缺点：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。 ​ 此时：用于加速前端页面开发的Web框架（MVC）是关键 分布式应用架构（RPC） ​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心 ​ 此时：用于提高业务复用及整合的分布式服务框架（RPC）是关键 流动计算架构（SOA） ​ 随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架 ​ 此时，用于提高机器利用率**资源调度和治理中心(SOA)**是关键。 2 什么是Dubbo​ Dubbo是一个微服务开发框架，提供了RPC通信与微服务治理两大关键能力。它提供了远程过程调用的能力，使得远程调用像本地调用一样方便 ​ Dubbo提供的基础能力包括： 服务发现 流式通信 负载均衡 流量治理 集群容错 服务降级 … 3 Dubbo总体架构​ 以下是官网的一张图 节点 说明 Consumer 需要调用远程服务的服务消费方 Registry 注册中心 Provider 服务提供方 Container 服务运行的容器 Monitor 监控中心 ​ 通过上图，可以知道服务发现整体流程如下： 服务提供者Provider启动然后向注册中心注册自己所能提供的服务。 消费者Consumer启动向注册中心订阅所需的服务。 然后注册中心返回服务提供者地址列表给消费者Consumer，如果有变更，注册中心将基于长连接推送变更数据给消费者Consumer。 消费者Consumer就可以负载均衡选择一个Provier直接调用。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4 快速入门​ 新建两个Maven项目，JDK版本1.8，Dubbo版本2.7，一个消费者，一个提供者 引入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;groupId&gt;com.tiza.leo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo_001_p&lt;/artifactId&gt; &lt;!--引入依赖--&gt; &lt;dependencies&gt; &lt;!-- core context beans spring三件套--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo 2.5.3--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper zkclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 提供端代码 UserService 12345678package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} UserServiceImpl 12345678910111213package com.w1nd.dubbo.service;public class UserServiceImpl implements UserService { public String findName(String name) { System.out.println(&quot;姓名:&quot; +name); return &quot;hello: &quot;+name; } public void addUser(String username) { System.out.println(&quot;添加用户,用户名为: &quot;+username); }} spring-dubbo.xml（重要） 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过duboo发布服务 --&gt; &lt;dubbo:application name=&quot;dubbo_001_p&quot;&gt;&lt;/dubbo:application&gt; &lt;!--将服务注册到指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--指定服务的协议 和 使用端口号 注意此处服务端使用客户端无需使用 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt; &lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--注册服务到注册中心--&gt; &lt;dubbo:service interface=&quot;com.w1nd.dubbo.service.UserService&quot; ref=&quot;userService&quot; timeout=&quot;4000&quot;&gt; &lt;!--定义超时时间方二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:service&gt; &lt;!--服务提供者--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.w1nd.dubbo.service.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 测试代码 1234567891011121314151617package com.w1nd.dubbo.publish;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;import static org.junit.Assert.*;public class PublishServiceTest { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); System.out.println(&quot;服务提供者,开始提供服务.....&quot;); System.in.read(); }} 消费端代码 UserService 1234567package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} spring-dubbo.xml（重要） 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过dubbo消费服务--&gt; &lt;dubbo:application name=&quot;dubbo_001_c&quot;/&gt; &lt;!--指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--关闭所有服务的启动时检查 (没有提供者时报错)：--&gt; &lt;dubbo:consumer timeout=&quot;5000&quot; &gt;&lt;/dubbo:consumer&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--调用服务--&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.w1nd.dubbo.service.UserService&quot; timeout=&quot;4000&quot; &gt; &lt;!--定义超时时间方式二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:reference&gt; &lt;/beans&gt; 测试代码 12345678910111213141516package com.w1nd.dubbo.invoke;import com.w1nd.dubbo.service.UserService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class InvokeServiceTest { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.addUser(&quot;w1nd&quot;); /* String serverReturn = userService.findName(&quot;GouSheng&quot;); System.out.println(&quot;get message from server message is &quot; + serverReturn);*/ }} 5 集群​ 不同消费者的使用端口号设置不一样，即可。 dubbo_cluster_001_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_002_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_003_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20883&quot;&gt;&lt;/dubbo:protocol&gt; 参考(96条消息) 朋友国企干了5年java，居然不知道Dubbo是做什么呢？我真信了！_敖丙-CSDN博客 Dubbo3 简介 | Apache Dubbo","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/dubbo%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"},{"title":"zookeeper基本使用与集群搭建","text":"1. ZK简介​ 一个分布式的，开放源码的分布式应用程序协调服务。 2. ZK数据模型2.1 模型结构​ 2.2 模型的特点 每个子目录如/node1都被称作一个znode（节点）。这个znode是它所在的路径唯一标识 znode可以有子节点目录，并且每个znode可以存储数据 znode是有有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据 znode是可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端 3. 节点的分类3.1 持久节点（PERSISTENT）​ 指在节点创建后，就一直存在，知道有删除操作来主动删除这个节点–会因为创建该节点的客户端会话失效而消失 3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）​ 这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 3.3 临时节点（EPHEMERAL）​ 和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）​ 具有临时节点特点额外的特性是，每个父节点会为他的第一级子节点维护一份时序。这点和刚才提到的持久顺序节点类似 4. 安装4.1 linux系统安装 安装JDK 12tar -zxvf jdk-8u171-linux-x64.tar.gz mv ./jdk1.8.0_171/ /usr/java/ 12vim /etc/profilesource /etc/profile 安装ZK 1tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz 1cd conf/ 由于zk默认加载的是zoo.cfg，所以需要改名 1mv zoo_sample.cfg zoo.cfg 由于zookeeper加载要将节点加载到磁盘，所以需要预先新建一个磁盘目录 1mkdir /tmp/zookeeper 启动ZK 1234567[root@localhost bin]# ./zkServer.sh start /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg ZooKeeper JMX enabled by defaultUsing config: /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfgStarting zookeeper ... STARTED# 查看是否启动jps ​ QuorumPeerMain就是zk 连接ZK 1./zkCli.sh -server 192.168.9.3:2181 如果是本机，-server后可不加 5. 配置文件说明 tickTime：集群节点心跳时间， initLimit：初始化集群时集群节点同步超时时间20s syncLimit：集群在运行过程中，同步数据超时时间为10s（这里5是指5次心跳） dataDir：默认数据存储位置 clientPort：zk服务监听端口号 maxClientCnxns：线程池线程数量 6. 客户端基本指令 查看节点 1ls / # 根节点 创建节点 12345create path data # 创建一个节点，并给节点绑定数据（默认是持久性节点）- create path data # 持久节点- create -s path data # 持久性顺序节点- create -e path data # 临时性节点- create -e -s path data # 临时顺序节点 quit：会直接导致会话断开，会话失效，其他ctrl+c会导致触发倒计时 注：临时节点上不能创建任何节点 查看节点状态 1stat /node1 cZxid：创建事务ID ctime：创建时间 mZxid：修改ID mtime：修改时间 pZxid：父结点版本号 cversion：创建版本号 dataVersion：数据版本号 aclVersion： ephemerslOwner：是否是临时节点 dataLength：存储数据长度 numChildren：子节点数量 获得节点上绑定的数据信息 1get /node1 删除节点 1delete /node1 只能删除没有子节点的节点，如果有子节点，则无法删除 若想删除有子节点的，则需要deleteall 7. watch节点监听机制监听分为节点目录监听和节点数据监听 目录监听是监听节点目录的变化 数据监听是监听当前节点数据的变化 两种监听都是一次性的，也就是发现一个修改，下次修改则不会触发监听机制 目录监听 1ls -w /node 再次创建，无触发 数据监听 1get -w /node 8. Java操作ZK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.w1nd.test;import org.I0Itec.zkclient.IZkChildListener;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import org.I0Itec.zkclient.serialize.SerializableSerializer;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.data.Stat;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.List;public class TestZKClient { private ZkClient zkClient; // 1. 在zk创建节点 @Test public void testCreateNode() { // 1. 持久节点 zkClient.create(&quot;/node1&quot;, &quot;xiaochen&quot;, CreateMode.PERSISTENT); // 2. 持久顺序节点 zkClient.create(&quot;/node1/names&quot;, &quot;zhangsan&quot;, CreateMode.PERSISTENT_SEQUENTIAL); // 3. 临时节点 zkClient.create(&quot;/node1/lists&quot;, &quot;xiaoxiao&quot;, CreateMode.EPHEMERAL); // 4. 临时顺序节点 zkClient.create(&quot;/node1/lists1&quot;, &quot;xiaoming&quot;, CreateMode.EPHEMERAL_SEQUENTIAL); } // 2. 删除节点 @Test public void testDeleteNode() { // 删除没有子节点的节点，返回值：是否成功 boolean delete = zkClient.delete(&quot;/node1&quot;); // 递归删除节点信息，返回值：是否删除成功 boolean b = zkClient.deleteRecursive(&quot;/node1&quot;); } // 3. 查询当前节点下所有子节点 @Test public void testFindNodes() { // 获取指定路径的节点信息 List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;); for (String child : children) { System.out.println(child); } } // 4. 查看某个节点数据，注意：通过java客户端操作需要保证节点存储的数据和节点时序列化方式一致 // shell中的数据序列化方式和java中的不一致 @Test public void testFindNodeData() { Object readData = zkClient.readData(&quot;/node3&quot;); System.out.println(readData); } // 5. 查看节点状态信息 @Test public void testFindNodeDataAndStat() { Stat stat = new Stat(); Object readData = zkClient.readData(&quot;/node1&quot;, stat); System.out.println(readData); System.out.println(stat); } // 6. 修改节点数据 @Test public void testWriteData() { // User user = new User(); // user.setId(1); // zkClient.writeData(&quot;/node1&quot;, user); } // 监听节点数据的变化 @Test public void testOnNodeDataChange() throws IOException { zkClient.subscribeDataChanges(&quot;/node1&quot;, new IZkDataListener() { // 当节点数据变化时触发对应这个方法 @Override public void handleDataChange(String s, Object o) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); System.out.println(&quot;当前节点变化后数据：&quot; + o); } // 当前节点删除时触发这个方法 @Override public void handleDataDeleted(String s) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); } }); System.in.read(); // 阻塞当前监听 } // 监听节点目录的变化 @Test public void testOnNodesChange() throws IOException { zkClient.subscribeChildChanges(&quot;/node1&quot;, new IZkChildListener() { // 当节点的发生变化时，会自动调用这个方法 // 参数1：父节点名称 // 参数2：父节点中的所有子节点名称 @Override public void handleChildChange(String s, List&lt;String&gt; list) throws Exception { System.out.println(&quot;父节点名称：&quot; + s); System.out.println(&quot;发生变更后孩子节点名称：&quot;); for (String name: list) { System.out.println(name); } } }); System.in.read(); // 阻塞当前监听 } @Before public void before() { // 参数1：Server服务器ip地址 // 参数2：会话超时时间 // 参数3：连接超时时间 // 参数4：序列化方式 zkClient = new ZkClient(&quot;192.168.9.3:2181&quot;, 60000 * 30, 60000, new SerializableSerializer()); } @After // 释放资源 public void after() { zkClient.close(); } // 获取连接 public static void main(String[] args) { }} 9. ZK集群9.1 集群（cluster）​ 集群是指同一种软件服务的多个节点同时提供服务 ​ 集群解决了什么问题？ 单节点的并发访问的压力问题 单节点故障问题 9.2 集群架构 9.3 集群搭建 在~目录下新建三个文件夹 1mkdir zkdata1 zkdata2 zkdata3 建立myid文件 1touch zkdata1/myid zkdata2/myid zkdata3/myid 为每个zk指定id 123echo &quot;1&quot; &gt;&gt; zkdata1/myid echo &quot;2&quot; &gt;&gt; zkdata2/myid echo &quot;3&quot; &gt;&gt; zkdata3/myid 添加配置文件 12345678910111213vim zkdata1/zoo.cfgvim zkdata2/zoo.cfgvim zkdata3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/root/zkdata1clientPort=3001server.1=196.168.9.3:3002:3003server.2=192.158.9.3:4002:4003server.3=192.168.9.3:5002:5003 相关操作 12345678# 启动./bin/zkServer.sh start /root/zkdata1/zoo.cfg./bin/zkServer.sh start /root/zkdata2/zoo.cfg./bin/zkServer.sh start /root/zkdata3/zoo.cfg# 查看状态./bin/zkServer.sh status /root/zkdata1/zoo.cfg# 停止./bin/zkServer.sh stop /root/zkdata1/zoo.cfg","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"前缀和","text":"525. 连续数组 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920class Solution {public: int findMaxLength(vector&lt;int&gt;&amp; nums) { /* 由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 cur 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 curcur 值即可 */ unordered_map&lt;int, int&gt; hash{{0, -1}}; int cur = 0, ans = 0; for (int i = 0; i &lt; nums.size(); i ++) { cur += nums[i] == 0 ? -1 : 1; if (hash.count(cur)) { ans = max(ans, i - hash[cur]); } else { hash[cur] = i; } } return ans; }}; 剑指 Offer II 010. 和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"位运算","text":"剑指 Offer II 004. 只出现一次的数字刷穿剑指offer-Day02-整数II 004.只出现一次的数字 位运算讲解 - 只出现一次的数字 12345678910111213141516class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int ret = 0; for (int i = 0; i &lt; 32; i ++) { int cnt = 0; for (auto num: nums) { cnt += num &gt;&gt; i &amp; 1; } if (cnt % 3 != 0) { ret |= 1 &lt;&lt; i; } } return ret; }}; 剑指 Offer II 005. 单词长度的最大乘积123456789101112131415161718192021222324class Solution {public: int maxProduct(vector&lt;string&gt;&amp; words) { int n = words.size(); vector&lt;int&gt; dict(n, 0); for (int i = 0; i &lt; words.size(); i ++) { int t = 0; for (auto c: words[i]) { int bit = c - 'a'; t |= (1 &lt;&lt; bit); } dict[i] = t; } int ans = 0; for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; i; j ++) if ((dict[i] &amp; dict[j]) == 0) { int temp = words[i].size() * words[j].size(); ans = max(ans, temp); } return ans; } };","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"区间DP","text":"87. 扰乱字符串1234567891011121314151617181920212223242526272829class Solution {public: bool isScramble(string s1, string s2) { int n = s1.size(); if (s1 == s2) return true; if (s1.size() != s2.size()) return false; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, false))); // 处理长度为1的情况 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; n; j ++) if (s1[i] == s2[j]) f[i][j][1] = true; // f[i][j][len] 代表 s1s1 从 ii 开始，s2s2 从 jj 开始，后面长度为 lenlen 的字符是否能形成「扰乱字符串」（互为翻转）。 for (int len = 2; len &lt;= n; len ++) for (int i = 0; i &lt;= n - len; i ++) for (int j = 0; j &lt;= n - len; j ++) for (int k = 1; k &lt; len; k ++) { // 分割点 // a : 0 - i, b : 0 - j ; a: i - n, j - n bool a = f[i][j][k] &amp;&amp; f[i + k][j + k][len - k]; // a : 0 - i, b : n - i, n ; a: i - n, 0 - j bool b = f[i][j + len - k][k] &amp;&amp; f[i + k][j][len - k]; if (a || b) { f[i][j][len] = true; } } return f[0][0][n]; }}; 375. 猜数字大小 II1234567891011121314151617181920class Solution {public: int getMoneyAmount(int n) { //定义 f[l][r]f[l][r] 为考虑在 [l, r][l,r] 范围内进行猜数的最小成本。 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); // 需要找到能猜中数字的最小成本，也就是最坏情况最好的结果 // 对于任一区间取min是因为我们在该区间可以先选择小的数去试，由此降低成本 for (int len = 2; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; f[l][r] = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cur = max(f[l][x - 1], f[x + 1][r]) + x; f[l][r] = min(f[l][r], cur); } } return f[1][n]; }}; 516. 最长回文子序列123456789101112131415161718192021222324252627282930313233class Solution {public: /* bb aa bb bb a bb dp[i][j] 表示 第 i 个字符到 第 j 个字符之间最长的回文子序列长度 1、当 s[i] == s[j] 时，考虑 i 和 j 中间序列的奇偶个数， dp[i][j] = dp[i+1][j-1] + 2 对上述 dp[i][j] = dp[i+1][j-1] + 2 的解释： 当序列为 b aa b 时， i = 0, j = 3，则 dp[0][3] = dp[1][2] + 2 = 4 当序列为 b a b 时，i = 0, j = 2，则 dp[0][2] = dp[1][1] + 2 = 3 当序列为 b b 时， i = 0, j = 1，则 dp[0][1] = dp[1][0] = 0 + 2 = 2 (dp[1][0] 默认值为 0) 该式子同时考虑到了奇偶 2、当 s[i] != s[j] ，那么 dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]) 对上述 dp[i][j] 式子的解释： 假如序列为 d c b c c（index：0-4），s[0] != s[4] ，则 dp[0][4] = Math.max(dp[0][3],dp[1,4]) = Math.max(2,3) = 3 */ int longestPalindromeSubseq(string s) { int n = s.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i + 1][j - 1] + 2; } else { f[i][j] = max(f[i + 1][j], f[i][j - 1]); } } } return f[0][n - 1]; }}; 664. 奇怪的打印机123456789101112131415161718192021class Solution {public: int strangePrinter(string s) { int n = s.size(); // f[i][j] 表示 区间[i,j]的最小打印次数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i][j - 1]; } else { for (int k = i; k &lt; j; k ++) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } } return f[0][n - 1]; }}; 877. 石子游戏1234567891011121314151617class Solution {public: bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); // 定义 f[l][r]f[l][r] 为考虑区间 [l,r][l,r]，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); for (int len = 1; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; int a = piles[l - 1] + f[l + 1][r]; int b = piles[r - 1] + f[l][r - 1]; f[l][r] = max(a, b); } return f[1][n] &gt; 0; }};","link":"/2022/02/02/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4DP/"},{"title":"双指针","text":"剑指 Offer II 008. 和大于等于 target 的最短子数组123456789101112class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(), sum = 0, res = INT_MAX; for (int i = 0, j = 0; i &lt; n; i ++) { sum += nums[i]; while (sum - nums[j] &gt;= target) sum -= nums[j ++]; if (sum &gt;= target) res = min(res, i - j + 1); } return res == INT_MAX ? 0 : res; }}; 剑指 Offer II 009. 乘积小于 K 的子数组 1234567891011121314class Solution {public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) { //已知ABC &lt; target, 新增一位X变成ABCX, 若ABCX &lt; target 则新增的subarray中必须满足 1.连续 2.包含X //所以从X向左数: X, CX, BCX, ABCX int n = nums.size(), product = 1, res = 0; for (int i = 0, j = 0; i &lt; n; i ++ ) { product *= nums[i]; while (i &gt;= j &amp;&amp; product &gt;= k) product /= nums[j ++]; res += i - j + 1; } return res; }}; 剑指 Offer II 010. 和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }}; 剑指 Offer II 014. 字符串中的变位词 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617class Solution {public: bool checkInclusion(string s1, string s2) { map&lt;char, int&gt; hash; // 存储子串各个字符数量 for (auto c: s1) hash[c] ++; int tot = hash.size(), statify = 0; // tot是字符总数，statify是s2中满足要求的数量 for (int i = 0, j = 0; i &lt; s2.size(); i ++) { if (--hash[s2[i]] == 0) statify ++; while (i - j + 1 &gt; s1.size()) { // 窗口大小小于s1.size if (hash[s2[j]] == 0) statify --; hash[s2[j ++]] ++; } if (statify == tot) return true; } return false; }}; 剑指 Offer II 017. 含有所有字符的最短字符串 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920class Solution {public: string minWindow(string s, string t) { map&lt;char, int&gt; hash; for (auto c: t) hash[c] ++; int tot = hash.size(), statify = 0; string res; for (int i = 0, j = 0; i &lt; s.size(); i ++) { if (hash[s[i]] == 1) statify ++; hash[s[i]] --; while (hash[s[j]] &lt; 0) hash[s[j ++]] ++; // 注意这里是&lt;，所以不会出现后续的不符合要求的字符顶去前面的，例如BANC，N的出现不会将B删去 if (statify == tot) { if (res.empty() || res.size() &gt; i - j + 1) { res = s.substr(j, i - j + 1); } } } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"状压DP","text":"526. 优美的排列123456789101112131415161718class Solution {public: int countArrangement(int n) { int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(mask, 0)); f[0][0] = 1; // 考虑前i个数，状态为0的方案数（优美排列数量） for (int i = 1; i &lt;= n; i ++) // 枚举当前位置 for (int state = 1; state &lt;= mask; state ++) // 枚举当前状态，0为选该数，1为不选 for (int k = 1; k &lt;= n; k ++) { // 枚举当前位置填了什么数 if (!((state &gt;&gt; (k - 1)) &amp; 1)) continue; // 如果当前数在状态中为0，则跳过 if (k % i &amp;&amp; i % k) continue; // 不满足任何整除关系 // state &amp; (~(1 &lt;&lt; (k - 1))) 代表将 state 中数值 k 的位置置零 f[i][state] += f[i - 1][state &amp; ~(1 &lt;&lt; (k - 1))]; } return f[n][mask - 1]; }}; 847. 访问所有节点的最短路径1234567891011121314151617181920212223242526class Solution {public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; dist(mask, vector&lt;int&gt;(n + 1, INT_MAX)); // state和u(该状态下的最后一步)对应的步数 deque&lt;vector&lt;int&gt;&gt; d; // 存储state 和 u for (int i = 0; i &lt; n; i ++) { dist[1 &lt;&lt; i][i] = 0; d.push_back({1 &lt;&lt; i, i}); } while (!d.empty()) { auto poll = d.front(); d.pop_front(); int state = poll[0], u = poll[1], step = dist[state][u]; if (state == mask - 1) return step; for (int i: graph[u]) { if (dist[state | (1 &lt;&lt; i)][i] == INT_MAX) { dist[state | (1 &lt;&lt; i)][i] = step + 1; d.push_back({state | (1 &lt;&lt; i), i}); } } } return -1; }};","link":"/2022/02/03/%E7%AE%97%E6%B3%95/%E7%8A%B6%E5%8E%8BDP/"},{"title":"背包DP","text":"279. 完全平方数 12345678910111213class Solution {public: int numSquares(int n) { // dp[i] 表示 能凑出i的完全平方数的最小数量 vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i ++) { dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j ++) dp[i] = min(dp[i], dp[i - j * j] + 1); } return dp[n]; }}; 322. 零钱兑换 12345678910111213class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 1e9); dp[0] = 0; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) dp[j] = min(dp[j], dp[j - coins[i]] + 1); if (dp[amount] == 1e9) return -1; return dp[amount]; }}; 416. 分割等和子集 12345678910111213141516class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = 0; for (auto &amp;x: nums) sum += x; int target = sum / 2; if (target * 2 != sum) return false; vector&lt;int&gt; dp(target + 1, 0); // dp[i] 表示 凑出 i 所需的价值数 for (auto &amp;x: nums) for (int j = target; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } return dp[target] == target; }}; 474. 一和零 12345678910111213141516171819202122232425class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int len = strs.size(); vector&lt;vector&lt;int&gt;&gt; cnt(len, vector&lt;int&gt;(2, 0)); for (int i = 0; i &lt; len; i ++) { int zero = 0, one = 0; for (auto &amp;c: strs[i]) { if (c == '1') one ++; else zero ++; } cnt[i][0] = zero, cnt[i][1] = one; } vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int k = 0; k &lt; len; k ++) { int zero = cnt[k][0], one = cnt[k][1]; for (int i = m; i &gt;= zero; i --) for (int j = n; j &gt;= one; j --) { f[i][j] = max(f[i][j], f[i - zero][j - one] + 1); } } return f[m][n]; }}; 494. 目标和 1234567891011121314151617181920class Solution {public: const int Offset = 1000; int findTargetSumWays(vector&lt;int&gt;&amp; a, int t) { int n = a.size(); int s = 0; for (int i: a) s += abs(i); if (abs(t) &gt; s) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2 * s + 1, 0)); dp[0][s] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = -s; j &lt;= s; j ++) { if (j - a[i - 1] &gt;= -s) dp[i][j + s] += dp[i - 1][j - a[i - 1] + s]; if (j + a[i - 1] &lt;= s) dp[i][j + s] += dp[i - 1][j + a[i - 1] + s]; } return dp[n][t + s]; }}; 518. 零钱兑换 II 1234567891011121314class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { // dp[i][j] 表示 考虑前i个物品，凑出 j 的方案数 int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) { dp[j] += dp[j - coins[i]]; } return dp[amount]; }}; 879. 盈利计划 12345678910111213141516171819class Solution {public: const int MOD = 1e9 + 7; // dp[i][j][k] 表示 前i个个物品，人数不超过j，利润至少为k的方案数 int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) { int m = group.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(minProfit + 1, 0)); for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= m; i ++) { int a = group[i - 1], b = profit[i - 1]; for (int j = n; j &gt;= a; j --) for (int k = minProfit; k &gt;= 0; k --) { dp[j][k] += dp[j - a][max(k - b, 0)]; dp[j][k] %= MOD; } } return dp[n][minProfit]; }}; 1049. 最后一块石头的重量 II 未优化空间 问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值进一步分析：要让差值小,两堆石头的重量都要接近sum/2;我们假设两堆分别为A,B,A&lt;sum/2,B&gt;sum/2,若A更接近sum/2,B也相应更接近sum/2进一步转化：将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;、 123456789101112131415161718// d[i][j]代表考虑前 i 个物品（数值），凑成总和不超过 j 的最大价值。class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(t + 1, 0)); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = 0; j &lt;= t; j ++) { dp[i][j] = dp[i - 1][j]; if (j &gt;= x) dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + x); } } return sum - 2 * dp[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;int&gt; dp(t + 1, 0); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = t; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } } return sum - 2 * dp[t]; }}; 1155. 掷骰子的N种方法 未优化空间 1234567891011121314class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(t + 1, 0)); f[0][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 0; j &lt;= t; j ++) for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[i][j] = (f[i][j] + f[i - 1][j - k]) % MOD; } return f[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;int&gt; f(t + 1, 0); f[0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = t; j &gt;= 0; j --) { f[j] = 0; //由于我们直接是在 f[i][j]f[i][j] 格子的基础上进行方案数累加，因此在计算 f[i][j]f[i][j] 记得手动置零。 for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[j] = (f[j] + f[j - k]) % MOD; } } return f[t]; }}; 1449. 数位成本和为目标值的最大数字 1234567891011121314151617181920212223242526class Solution {public: // dp[i][j] 表示 考虑前i个物品，总成本为j的最大整数长度 string largestNumber(vector&lt;int&gt;&amp; cost, int t) { int n = cost.size(); vector&lt;int&gt; dp(t + 1, INT_MIN); dp[0] = 0; for (int i = 1; i &lt;= n; i ++) { int x = cost[i - 1]; for (int j = x; j &lt;= t; j ++) { dp[j] = max(dp[j], dp[j - x] + 1); } } if (dp[t] &lt; 0) return &quot;0&quot;; string res = &quot;&quot;; for (int i = 9, j = t; i &gt;= 1; i --) { int x = cost[i - 1]; while (j &gt;= x &amp;&amp; dp[j] == dp[j - x] + 1) { res += to_string(i); j -= x; } } return res; }}; 1995. 统计特殊四元组 123456789101112131415161718192021class Solution {public: int countQuadruplets(vector&lt;int&gt;&amp; nums) { // dp[i][j][k] 考虑前i个数，恰好凑出j，使用个数为k的方案数 int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(110, vector&lt;int&gt;(4, 0))); f[0][0][0] = 1; for (int i = 1; i &lt;= n; i ++) { int x = nums[i - 1]; for (int j = 0; j &lt; 110; j ++) for (int k = 0; k &lt; 4; k ++) { f[i][j][k] += f[i - 1][j][k]; if (j &gt;= x &amp;&amp; k &gt;= 1) f[i][j][k] += f[i - 1][j - x][k - 1]; } } int res = 0; for (int i = 3; i &lt; n; i ++) res += f[i][nums[i]][3]; return res; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85DP/"},{"title":"记忆化搜索","text":"87. 扰乱字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int Y = 1, N = -1; string s1, s2; bool isScramble(string _s1, string _s2) { s1 = _s1, s2 = _s2; if (s1 == s2) return true; if (s1.size() != s2.size()) return false; int n = s1.size(); // cache表示s1从i开始，s2从j开始 len 位，是否形成扰动字符串 cache.resize(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0))); return dfs(0, 0, n); } bool dfs(int i, int j, int len) { if (cache[i][j][len] != 0) return cache[i][j][len] == Y; string a = s1.substr(i, len), b = s2.substr(j, len); if (a == b){ cache[i][j][len] = Y; return true; } if (!check(a, b)) { cache[i][j][len] = N; return false; } for (int k = 1; k &lt; len; k ++) { if (dfs(i, j, k) &amp;&amp; dfs(i + k, j + k, len - k)) { cache[i][j][len] = Y; return true; } if (dfs(i, len - k + j, k) &amp;&amp; dfs(i + k, j, len - k)) { cache[i][j][len] = Y; return true; } } cache[i][j][len] = N; return false; } bool check(string a, string b) { if (a.size() != b.size()) return false; vector&lt;int&gt; cnt1(26, 0), cnt2(26, 0); for (auto c: s1) { cnt1[c - 'a'] ++; } for (auto c: s2) { cnt2[c - 'a'] ++; } return cnt1 == cnt2; }}; 375. 猜数字大小 II12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; int getMoneyAmount(int n) { cache.resize(n + 1, vector&lt;int&gt;(n + 1, 0)); return dfs(1, n); } int dfs(int l, int r) { if (l &gt;= r) return 0; if (cache[l][r] != 0) return cache[l][r]; int ans = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cnt = max(dfs(l, x - 1), dfs(x + 1, r)) + x; ans = min(ans, cnt); } cache[l][r] = ans; return ans; }}; 403. 青蛙过河1234567891011121314151617181920212223242526272829303132class Solution {public: unordered_map&lt;string, bool&gt; cache; // 存储u下标跳k步有没有方案 unordered_map&lt;int, int&gt; map; // 存储每个石块对应的下标 bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); for (int i = 0; i &lt; n; i ++) { map.insert({stones[i], i}); } if (!map.count(1)) return false; return dfs(stones, n, 1, 1); } bool dfs(vector&lt;int&gt; &amp;stones, int n, int u, int k) { if (u == n - 1) return true; string key = to_string(u) + '_' + to_string(k); if (cache.count(key)) return cache[key]; for (int i = -1; i &lt;= 1; i ++) { if (k + i == 0) continue; int next = stones[u] + i + k; // 下一个跳跃点 if (map.count(next)) { bool cur = dfs(stones, n, map[next], k + i); cache.insert({key, cur}); if (cur) return true; } } cache.insert({key, false}); return false; }}; 494. 目标和12345678910111213141516171819202122class Solution {public: unordered_map&lt;string, int&gt; cache; // 表示从u下标,当前计算结果为string，的方案数int int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { return dfs(nums, target, 0, 0); } int dfs(vector&lt;int&gt; &amp;nums, int target, int u, int cur) { string key = to_string(u) + '_' + to_string(cur); if (cache.count(key)) return cache[key]; if (u == nums.size()) { cache.insert({key, cur == target ? 1: 0}); return cache[key]; } int left = dfs(nums, target, u + 1, cur - nums[u]); int right = dfs(nums, target, u + 1, cur + nums[u]); cache.insert({key, left + right}); return cache[key]; }}; 552. 学生出勤记录 II1234567891011121314151617181920212223class Solution {public: // cache 是指 下标为u，连续a个数为acnt，l个数为lcnt的方案数 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int mod = (int)1e9 + 7; int checkRecord(int n) { cache.resize(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3, -1))); return dfs(n, 0, 0); } int dfs(int u, int acnt, int lcnt) { if (acnt &gt;= 2) return 0; if (lcnt &gt;= 3) return 0; if (u == 0) return 1; if (cache[u][acnt][lcnt] != -1) return cache[u][acnt][lcnt]; int ans = 0; ans = dfs(u - 1, acnt + 1, 0) % mod; // A ans = (ans + dfs(u - 1, acnt, lcnt + 1)) % mod; // L ans = (ans + dfs(u - 1, acnt, 0)) % mod; // P cache[u][acnt][lcnt] = ans; return ans; }}; 576. 出界的路径数12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int MOD = (int) 1e9 + 7; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { cache.resize(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, -1))); return dfs(m, n, maxMove, startRow, startColumn); } int dfs(int m, int n, int u, int x, int y) { if (x &gt;= m || x &lt; 0) return 1; if (y &gt;= n || y &lt; 0) return 1; if (u == 0) return 0; if (cache[u][x][y] != -1) return cache[u][x][y]; int ans = 0; ans = dfs(m, n, u - 1, x + 1, y) % MOD; ans = (ans + dfs(m, n, u - 1, x, y + 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x, y - 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x - 1, y)) % MOD; cache[u][x][y] = ans; return ans; }}; 1137. 第 N 个泰波那契数12345678910111213class Solution {public: int cache[40]; int tribonacci(int n) { if (n == 0) return 0; if (n == 1 || n == 2) return 1; if (cache[n] != 0) return cache[n]; cache[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3); return cache[n]; }}; 剑指 Offer 10- I. 斐波那契数列1234567891011121314class Solution {public: int mod = (int) 1e9 + 7; int cache[110]; int fib(int n) { if (n &lt;= 1) return n; if (cache[n] != 0) return cache[n]; cache[n] = fib(n - 1) + fib(n - 2); cache[n] %= mod; return cache[n]; }}; 638. 大礼包 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;int&gt; price; vector&lt;vector&lt;int&gt;&gt; special; vector&lt;int&gt; needs; map&lt;vector&lt;int&gt;, int&gt; cache; int shoppingOffers(vector&lt;int&gt;&amp; _price, vector&lt;vector&lt;int&gt;&gt;&amp; _special, vector&lt;int&gt;&amp; _needs) { price = _price; special = _special; needs = _needs; return dfs(needs); } int dfs(vector&lt;int&gt; needs) { if (cache.count(needs)) { return cache[needs]; } int n = needs.size(); int minN = 0; for (int i = 0; i &lt; n; i ++) { minN += price[i] * needs[i]; } for (int i = 0; i &lt; special.size(); i ++) { bool flag = true; vector&lt;int&gt; nextNeeds = needs; for (int j = 0; j &lt; n; j ++) { if (special[i][j] &gt; nextNeeds[j]) flag = false; nextNeeds[j] -= special[i][j]; } if (!flag) continue; minN = min(minN, dfs(nextNeeds) + special[i][n]); } return cache[needs] = minN; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"title":"序列DP","text":"334. 递增的三元子序列 12345678910111213141516class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int small = INT_MAX, big = INT_MAX; for (int x: nums) { if (x &lt;= small) { small = x; } else if (x &lt;= big) { big = x; } else { return true; } } return false; }}; 1234567891011121314151617181920class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1, INT_MAX); // f[len] = x 表示 以 长度为 len 的序列的最小尾元素为x int ans = 1; for (int i = 0; i &lt; n; i ++) { int l = 1, r = i + 1; int x = nums[i]; while (l &lt; r) { // 二分查找小于nums[i]的最小元素 int mid = l + r &gt;&gt; 1; if (f[mid] &gt;= x) r = mid; else l = mid + 1; } f[r] = x; ans = max(ans, r); } return ans &gt;= 3; }}; 354. 俄罗斯套娃信封问题 123456789101112131415161718class Solution {public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) { int n = envelopes.size(); vector&lt;int&gt; f(n, 0); // 以 i 结尾的最大信封 sort(envelopes.begin(), envelopes.end()); int res = 0; for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) { if (envelopes[i][0] &gt; envelopes[j][0] &amp;&amp; envelopes[i][1] &gt; envelopes[j][1]) f[i] = max(f[i], f[j] + 1); } res = max(res, f[i]); } return res; }}; 368. 最大整除子集 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, 0); // f[i] 表示 前i个数中以a[i]结尾的整除子集的最长序列的元素个数 sort(nums.begin(), nums.end()); int k = 0; // 整除序列最后一个元素下标 for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) if (nums[i] % nums[j] == 0) f[i] = max(f[i], f[j] + 1); if (f[k] &lt; f[i]) k = i; } vector&lt;int&gt; res; // 逆推得出答案 while (true) { res.push_back(nums[k]); if (f[k] == 1) break; // 只剩一个元素 for (int i = 0; i &lt; k; i ++) { if ((nums[k] % nums[i] == 0) &amp;&amp; f[k] == f[i] + 1) { k = i; break; } } } return res; }}; 390. 消除游戏 1234567class Solution {public: int lastRemaining(int n) { if (n == 1) return 1; return 2 * (n / 2 + 1 - lastRemaining(n / 2)); }}; 446. 等差数列划分 II - 子序列 LeetCode 446. 等差数列划分 II - 子序列 - AcWing 12345678910111213141516171819202122class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; a) { typedef long long LL; int n = a.size(); // 由于每个数可能都会在不同等差数列中，需要用哈希表来存 vector&lt;unordered_map&lt;LL, int&gt;&gt; f(n); // f[i][j] 表示 考虑以第 i 个数结尾 公差为j的等差数列的个数 int res = 0; for (int i = 0; i &lt; n; i ++) for (int k = 0; k &lt; i; k ++) { LL j = (LL)a[i] - a[k]; auto it = f[k].find(j); // 查找a[k]结尾公差为j的等差数列的个数 int t = 0; if (it != f[k].end()) { t = it-&gt;second; res += t; } f[i][j] += t + 1; } return res; }}; 472. 连接词 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: typedef unsigned long long ULL; unordered_set&lt;ULL&gt; hash; const int P = 131; vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) { // 初始化字符串哈希表 for (auto &amp;s: words) { ULL t = 0; for (auto &amp;c: s) { t = t * P + c; } hash.insert(t); } vector&lt;string&gt; res; for (auto &amp;s: words) if (check(s)) res.push_back(s); return res; } bool check(string str) { int n = str.size(); vector&lt;int&gt; f(n + 1, -1); // f[i] 表示 在i前面的连接词的个数 f[0] = 0; for (int i = 0; i &lt;= n; i ++) { if (f[i]== -1) continue; ULL cur = 0; for (int j = i + 1; j &lt;= n; j ++) { cur = cur * P + str[j - 1]; if (hash.count(cur)) { f[j] = max(f[j], f[i] + 1); } } if (f[n] &gt;= 2) return true; } return false; }}; 583. 两个字符串的删除操作 123456789101112131415161718class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 0; i &lt;= n; i ++) f[i][0] = 1; for (int j = 0; j &lt;= m; j ++) f[0][j] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i][j - 1], f[i - 1][j]); if (word1[i - 1] == word2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } int maxn = f[n][m] - 1; return n + m - 2 * maxn; }}; 629. K个逆序对数组 LeetCode 629. K个逆序对数组 - AcWing 123456789101112131415161718class Solution {public: const int MOD = 1e9 + 7; int kInversePairs(int n, int k) { // f[i][j] 表示 所有由数字 1 ~ i 组成的含有 j 个 逆序对的数组个数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1, 0)); f[1][0] = 1; for (int i = 2; i &lt;= n; i ++) { long long s = 0; for (int j = 0; j &lt;= k; j ++) { s += f[i - 1][j]; if (j &gt;= i) s -= f[i - 1][j - i]; f[i][j] = s % MOD; } } return (f[n][k] + MOD) % MOD; } }; 673. 最长递增子序列的个数 123456789101112131415161718192021class Solution {public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n), g(n); // f 表示 以i结尾的最长上升子序列长度，g 表示 以 i 结尾的最长上升子序列的个数 int maxl = 0, cnt = 0; // maxl是最长子序列长度，cnt是子序列个数 for (int i = 0; i &lt; n; i ++) { f[i] = g[i] = 1; for (int j = 0; j &lt; i; j ++) { if (nums[j] &lt; nums[i]) { if (f[i] &lt; f[j] + 1) f[i] = f[j] + 1, g[i] = g[j]; else if (f[i] == f[j] + 1) g[i] += g[j]; } } if (maxl &lt; f[i]) maxl = f[i], cnt = g[i]; else if (maxl == f[i]) cnt += g[i]; } return cnt; }}; 689. 三个无重叠子数组的最大和 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; s(n, 0); int sum = 0; for (int i = 0; i &lt; n; i ++) { sum += nums[i]; if (i &gt;= k) sum -= nums[i - k]; if (i &gt;= k - 1) s[i - k + 1] = sum; } vector&lt;int&gt; left(n, 0), right(n, 0); int maxIndex = 0; for (int i = 0; i &lt; n; i ++) { if (s[maxIndex] &lt; s[i]) maxIndex = i; left[i] = maxIndex; } maxIndex = n - 1; for (int i = n - 1; i &gt;= 0; i --) { if (s[maxIndex] &lt;= s[i]) maxIndex = i; right[i] = maxIndex; } vector&lt;int&gt; res(3, -1); for (int i = k; i &lt; n - k; i ++) { if (res[0] == -1 || s[res[0]] + s[res[1]] + s[res[2]] &lt; s[i] + s[left[i - k]] + s[right[i + k]]) { res[0] = left[i - k]; res[1] = i; res[2] = right[i + k]; } } return res; }}; 740. 删除并获得点数 1234567891011121314151617181920class Solution {public: const int N = 1e4 + 10; int deleteAndEarn(vector&lt;int&gt;&amp; nums) { // f[i][j] 表示是否删除 j 数 的 最大点数 int n = nums.size(); int maxn = 0; vector&lt;int&gt; cnt(N); for(auto x: nums) { cnt[x] ++; maxn = max(maxn, x); } vector&lt;vector&lt;int&gt;&gt; f(maxn + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= maxn; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = max(f[i][1], f[i - 1][0] + cnt[i] * i); } return max(f[maxn][0], f[maxn][1]); }}; 978. 最长湍流子数组 12345678910111213141516171819// 优化了空间class Solution {public: int maxTurbulenceSize(vector&lt;int&gt;&amp; arr) { int n = arr.size(); // f[i][0/1]表示 以i结尾的数组 元素状态为j的最大湍流子数组长度 vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(2, 0)); int ans = 1; f[0][0] = f[0][1] = 1; for (int i = 1; i &lt; n; i ++) { for (int j = 0; j &lt; 2; j ++) f[i % 2][j] = 1; if (arr[i - 1] &lt; arr[i]) f[i % 2][0] = f[(i - 1) % 2][1] + 1; if (arr[i - 1] &gt; arr[i]) f[i % 2][1] = f[(i - 1) % 2][0] + 1; for (int j = 0; j &lt; 2; j ++) ans = max(ans, f[i % 2][j]); } return ans; }}; 1035. 不相交的线 123456789101112131415161718class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int n = nums1.size(), m = nums2.size(); // f[i][j] 表示 考虑 前 i 个 数字，前 j 个数字组成最大公共子序列长度 // 最长公共子序列 是考虑的情况是不一定包含第i个字符的 // 例如，我们通常考虑f[i - 1][j]为前i - 1，j个数字的最长子序列，但这里不一定包含第j个，只是可能，所以 f[i - 1][j] 包含 f[i - 1][j - 1]; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (nums1[i - 1] == nums2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1143. 最长公共子序列 12345678910111213141516class Solution {public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (text1[i - 1] == text2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1218. 最长定差子序列 1234567891011121314151617181920212223class Solution {public: // 注意覆盖问题：hash.insert遇到一样的键不会覆盖 // 由于 arr长度 为 1e5，不能用两层循环，使用哈希表进行优化 int longestSubsequence(vector&lt;int&gt;&amp; arr, int diff) { int n = arr.size(); // f[i][j] 表示 前i个数，第i个数选或不选的最长定差子序列长度 vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][1] = 1; unordered_map&lt;int, int&gt; hash; hash[arr[0]] = 0; for (int i = 1; i &lt; n; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = 1; int prev = arr[i] - diff; if (hash.count(prev)) { f[i][1] = max(f[i][1], f[hash[prev]][1] + 1); } hash[arr[i]] = i; } return max(f[n - 1][0], f[n - 1][1]); }}; 1473. 粉刷房子 III 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: const int INF = 0x3f3f3f3f; int minCost(vector&lt;int&gt;&amp; houses, vector&lt;vector&lt;int&gt;&gt;&amp; cost, int n, int m, int t) { // f[i][j][k] 表示 考慮前i个房子，第i个房子粉刷为j，分区数量为k的所有方案中的最小总花费 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(t + 1, 0))); for (int i = 0; i &lt;= n; i ++) for (int j = 0; j &lt;= m; j ++) f[i][j][0] = INF; for (int i = 1; i &lt;= n; i ++) { int color = houses[i - 1]; // 当前房子的颜色 for (int j = 1; j &lt;= m; j ++) { for (int k = 1; k &lt;= t; k ++) { if (k &gt; i) { // 如果分区数量大于房子数，不合法 f[i][j][k] = INF; continue; } if (color != 0) { // 当前房子已经染色 if (color == j) { // 只有与当前颜色相同才能被转移 int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp); // 与前面颜色相同的情况 } else { f[i][j][k] = INF; } } else { // 当前房子未被染色 int u = cost[i - 1][j - 1]; int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp) + u; // 与前面颜色相同的情况 } } } } int ans = INF; for (int i = 1; i &lt;= m; i ++) ans = min(ans, f[n][i][t]); return ans == INF ? -1: ans; }}; 1713. 得到子序列的最少操作次数 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: /* target 6 4 8 1 3 2 arr 4 7 6 2 3 8 6 1 list 1 0 5 4 2 0 3 */ int minOperations(vector&lt;int&gt;&amp; t, vector&lt;int&gt;&amp; a) { int n = t.size(), m = a.size(); unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; n; i ++) hash.insert({t[i], i}); // 建立 target 和 arr 的映射关系 vector&lt;int&gt; list; for (auto x: a) { // 由于target各元素不相同，list中保存了arr与target相同元素的下标，并且递增，故可转化为LIS问题 if (hash.count(x)) list.push_back(hash[x]); } int cnt = list.size(); // q[i] 表示 长度为i的上升子序列 中末尾元素最小的数 vector&lt;int&gt; q(cnt + 1, 0); // 使用LIS的贪心+二分的方法求解，复杂度为nlog(n) // 个人感觉这种优化方式主要是维护一个单调队列，每次加入新的元素，要和之前加入的对比， // 找到比自己小的最后一个数，那么它就可以代替这之前的那个数，因为它更小，更好维护递增序列， // 例如 1 3 5 ，加入1个4（规定长度3），那肯定4替换掉5更好 int len = 0; for (int i = 0; i &lt; cnt; i ++) { int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; list[i]) l = mid; else r = mid - 1; } q[r + 1] = list[i]; if (r + 1 &gt; len) len ++; } return n - len; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E5%BA%8F%E5%88%97DP/"},{"title":"线性DP","text":"10. 正则表达式匹配12345678910111213141516171819202122232425class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(), m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; // dp状态表示：dp[i][j] s以i结尾的子串与p以j结尾的子串是否匹配 vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; // 下一个是*，当前 字符不能单独使用，跳过 if (i - 1 &gt;= 0 &amp;&amp; p[j] != '*') { dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); // 对应了p[j]为普通字符和'.'两种情况 } else if (p[j] == '*') { // 字符为'*' dp[i][j] = (j - 2 &gt;= 0 &amp;&amp; dp[i][j - 2]) || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')); } } return dp[n][m]; }}; 44. 通配符匹配1234567891011121314151617181920class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(); int m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (p[j] != '*') { dp[i][j] = i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (p[j] == s[i] || p[j] == '?'); } else { dp[i][j] = dp[i][j - 1] || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j]); } } return dp[n][m]; }}; 45. 跳跃游戏 II123456789101112class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n); for (int i = 1, j = 0; i &lt; n; i ++) { while (j + nums[j] &lt; i) j ++; dp[i] = dp[j] + 1; } return dp[n - 1]; }}; 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string ss) { int n = ss.size(); string s = &quot; &quot; + ss; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; i ++) { int a = s[i] - '0', b = (s[i - 1] - '0') * 10 + (s[i] - '0'); if (a &gt;= 1 &amp;&amp; a &lt;= 9) dp[i] = dp[i - 1]; if (b &gt;= 10 &amp;&amp; b &lt;= 26) dp[i] += dp[i - 2]; } return dp[n]; }}; 115. 不同的子序列1234567891011121314151617181920class Solution {public: int numDistinct(string ss, string tt) { int n = ss.size(), m = tt.size(); string s = &quot; &quot; + ss; string t = &quot; &quot; + tt; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); // f[i][j] 表示 0~i，0~j的字符串匹配个数 for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { // 不匹配s[i] dp[i][j] = dp[i - 1][j]; if (s[i] == t[j]) { // 匹配s[i] dp[i][j] = (0LL + dp[i][j] + dp[i - 1][j - 1]) % INT_MAX; } } return dp[n][m]; }}; 119. 杨辉三角 II123456789101112131415class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; dp(rowIndex + 1); dp[0] = 1; for (int i = 1; i &lt;= rowIndex; i ++) for (int j = i; j &gt;= 0; j --) { if (j - 1 &gt;= 0) dp[j] += dp[j - 1]; if (dp[j] == 0) dp[j] = 1; } vector&lt;int&gt; res; for (int i = 0; i &lt; rowIndex + 1; i ++) res.push_back(dp[i]); return res; }}; 213. 打家劫舍 II1234567891011121314151617181920212223class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 1) return nums[0]; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0)); // 不选第1间, 0不选，1选 for (int i = 1; i &lt; n; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res1 = max(dp[n - 1][0], dp[n - 1][1]); dp[0][1] = nums[0], dp[0][0] = 0; for (int i = 1; i &lt; n - 1; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res2 = max(dp[n - 2][0], dp[n - 2][1]); return max(res1, res2); }}; 403. 青蛙过河1234567891011121314151617181920class Solution {public: bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); if (stones[1] != 1) return false; // dp[i][j]表示跳到位置i步长为j是否可以 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); dp[1][1] = true; for (int i = 2; i &lt; n; i ++) for (int j = 1; j &lt; i; j ++) { int k = stones[i] - stones[j]; // 步长 if(k &lt;= j + 1) { dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; } } for (int i = 1; i &lt; n; i ++) if (dp[n - 1][i]) return true; return false; }}; 576. 出界的路径数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: const int MOD = (int) 1e9 + 7; int n, m, maxn; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int findPaths(int _m, int _n, int _maxMove, int r, int c) { n = _m, m = _n, maxn = _maxMove; vector&lt;vector&lt;int&gt;&gt; dp(n * m, vector&lt;int&gt;(maxn + 1, 0)); // 初始化边缘 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j ++) { if (i == 0) add(i, j, dp); if (j == 0) add(i, j, dp); if (i == n - 1) add(i, j, dp); if (j == m - 1) add(i, j, dp); } // f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1] for (int k = 1; k &lt;= maxn; k ++) { for (int idx = 0; idx &lt; m * n; idx ++) { vector&lt;int&gt; info(2, 0); info = parseIdx(idx); int x = info[0], y = info[1]; for (int i = 0; i &lt; 4; i ++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; int nidx = getIdx(nx, ny); dp[idx][k] += dp[nidx][k - 1]; dp[idx][k] %= MOD; } } } return dp[getIdx(r, c)][maxn]; } void add(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;dp) { for (int k = 1; k &lt;= maxn; k ++) { dp[getIdx(x, y)][k] ++; } } int getIdx(int x, int y) { return x * m + y; } vector&lt;int&gt; parseIdx(int idx) { return vector&lt;int&gt;{idx / m, idx % m}; }}; 639. 解码方法 II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution {public: const int MOD = (int) 1e9 + 7; // i 表示当前遍历字符下标，j表示前一个字符下标 // f[i] 表示 以 s[i] 结尾的字符串，共有多少种解码方法 /* s[i] == '*'： s[i]可以单独组成一个，f[i] += f[i - 1] * 9 可以和前面的字符组成： 若s[j] == 1，那么 f[i] += f[i - 2] * 9 (11 - 19) 若s[j] == 2，那么 f[i] += f[i - 2] * 6 (21 - 26) 若s[j] == *，那么 f[i] += f[i - 2] * 15 s[i] != '*'，s[i]为数字时： s[j] 为 '*'： s[i] == 0，f[i] += f[i - 2] * 2; （10，20） s[i] != 0： f[i] = f[i - 1] (1 - 9) 1 &lt;= s[i] &lt;= 6 f[i] += f[i - 2] * 2 （11 - 16，21 - 26） 7 &lt;= s[i] &lt;= 9 f[i] += f[i - 2] * 1 （17 - 19） s[j] != '*'： s[i] == 0，f[i] = f[i - 2] (10, 20) s[i] != 0： f[i] = f[i - 1] (1 - 9) s[j] == 1，f[i] = f[i - 2]; (11 - 19) s[j] == 2 且 1 &lt;= s[i] &lt;= 6 ，f[i] = f[i - 2]; (21 - 26) */ int numDecodings(string s) { int n = s.size(); vector&lt;long&gt; f(n, 0); // 注意这里要long f[0] = s[0] == '*' ? 9 : (s[0] != '0' ? 1 : 0); for (int i = 1; i &lt; n; i ++) { char c = s[i], prev = s[i - 1]; if (c == '*') { f[i] += f[i - 1] * 9; if (prev == '*') f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 15; else { int u = prev - '0'; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 9; else if (u == 2) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 6; } } else { int t = c - '0'; if (prev == '*') { if (t == 0) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; else { f[i] += f[i - 1]; if (t &gt;= 1 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; if (t &gt;= 7 &amp;&amp; t &lt;= 9) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { int u = prev - '0'; if (t == 0) { if (u == 1 || u == 2) { f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { f[i] = f[i - 1]; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); if (u == 2 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } } f[i] %= MOD; } return (int) f[n - 1]; }}; 650. 只有两个键的键盘1234567891011121314151617181920// f[i][j]表示经过最后一次操作，记事本上有i个字符，粘贴板上有j个字符的最小操作次数class Solution {public: const int MAX_INT = 0x3f3f3f3f; int minSteps(int n) { vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, MAX_INT)); dp[1][0] = 0, dp[1][1] = 1; for (int i = 2; i &lt;= n; i ++) { int minN = MAX_INT; for (int j = 0; j &lt;= i / 2; j ++) { dp[i][j] = dp[i - j][j] + 1; // paste minN = min(minN, dp[i][j]); } dp[i][i] = minN + 1; // copy all } int res = MAX_INT; for (int i = 0; i &lt;= n; i ++) res = min(res, dp[n][i]); return res; }}; 678. 有效的括号字符串1234567891011121314151617181920212223class Solution {public: bool checkValidString(string s) { int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(n + 1, 0)); dp[0][0] = true; for (int i = 1; i &lt;= n; i ++) { char c = s[i - 1]; for (int j = 0; j &lt;= i; j ++) { if (c == '(') { if (j - 1 &gt;= 0) dp[i][j] = dp[i - 1][j - 1]; } else if (c == ')') { if (j + 1 &lt;= i) dp[i][j] = dp[i - 1][j + 1]; } else { dp[i][j] = dp[i - 1][j]; if (j - 1 &gt;= 0) dp[i][j] = dp[i][j] | dp[i - 1][j - 1]; if (j + 1 &lt;= i) dp[i][j] = dp[i][j] | dp[i - 1][j + 1]; } } } return dp[n][0]; }}; 1220. 统计元音字母序列的数目12345678910111213141516171819202122232425262728293031class Solution {public: const int MOD = 1e9 + 7; // dp[i][j] 表示 长度为i的字符串，结尾为j的字符串 的 个数 int countVowelPermutation(int n) { vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt;(5, 0)); for (int i = 0; i &lt; 5; i ++) dp[0][i] = 1; for (int i = 1; i &lt; n; i ++) { // 每个元音 'a' 后面都只能跟着 'e' dp[i][1] += dp[i - 1][0]; // 每个元音 'e' 后面只能跟着 'a' 或者是 'i' dp[i][0] += dp[i - 1][1]; dp[i][2] += dp[i - 1][1]; // 每个元音 'i' 后面 不能 再跟着另一个 'i' dp[i][0] += dp[i - 1][2]; dp[i][1] += dp[i - 1][2]; dp[i][3] += dp[i - 1][2]; dp[i][4] += dp[i - 1][2]; // 每个元音 'o' 后面只能跟着 'i' 或者是 'u' dp[i][2] += dp[i - 1][3]; dp[i][4] += dp[i - 1][3]; // 每个元音 'u' 后面只能跟着 'a' dp[i][0] += dp[i - 1][4]; for (int j = 0; j &lt; 5; j ++) dp[i][j] %= MOD; } long res = 0; for (int i = 0; i &lt; 5; i ++) res += dp[n - 1][i]; return (int) (res % MOD); }}; 1751. 最多可以参加的会议数目 II1234567891011121314151617181920212223242526272829303132333435class Solution {public: static bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) { // 升序排序 return a[1] &lt;= b[1]; } int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; events, int k) { int n = events.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k + 1, 0)); sort(events.begin(), events.end(), cmp); for (int i = 0; i &lt; n; i ++) printf(&quot;[%d %d %d]&quot;, events[i][0], events[i][1], events[i][2]); for (int i = 1; i &lt;= n; i ++) { auto p = events[i - 1]; int s = p[0], e = p[1], v = p[2]; int last = 0; for (int t = i - 1; t &gt;= 1; t --) { auto l = events[t - 1]; if (s &gt; l[1]) { last = t; // 更新为不冲突的事件下标 break; } } for (int j = 1; j &lt;= k; j ++) { dp[i][j] = max(dp[i - 1][j], dp[last][j - 1] + v); // 选与不选 } } return dp[n][k]; }}; 1787. 使所有区间的异或结果为零12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: /* 易知，将nums排列为一个二维数组（每行为k个），问题将转化为： 使得每列相等，且最终首行异或值为0的更改元素数 定义 f[i][xor]为考虑前i列，且首行前i列异或值的xor的更改元素数 由于需要知道i - 1列的最小更改元素数，使之转态转移，所以需要一个状态数组prev 另外，使用 map记录每一列数字对应的个数 cnt记录每一列数字总数 所以，分析状态转移方程 当在第0列时： f[0][xor] = f[0][xor] + cnt - map[xor] 当在其他列时，需要考虑从前一列转移的状态： 另外，还有 考虑整列修改： f[i][xor] = f[i - 1][xor] + cnt; 考虑部分修改： f[i][xor] = f[i - 1][xor ^ cur] + cnt - map[cur]; */ const int maxVal = INT_MAX / 2; const int maxHalf = 1 &lt;&lt; 10; int minChanges(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(maxHalf, maxVal)); vector&lt;int&gt; prev(k, maxVal); for (int i = 0; i &lt; k; i ++) { // 遍历每一列 int cnt = 0; unordered_map&lt;int, int&gt; map; for (int j = i; j &lt; n; j += k) { map[nums[j]] ++; cnt ++; } if (i == 0) { // 第0列 for (int x = 0; x &lt; maxHalf; x ++) { dp[0][x] = min(dp[0][x], cnt - map[x]); prev[0] = min(prev[0], dp[0][x]); } } else { // 其他列 for (int x = 0; x &lt; maxHalf; x ++) { dp[i][x] = prev[i - 1] + cnt; for (auto &amp;it: map) { dp[i][x] = min(dp[i][x], dp[i - 1][x ^ it.first] + cnt - it.second); } prev[i] = min(prev[i], dp[i][x]); } } } return dp[k - 1][0]; }}; 剑指 Offer 42. 连续子数组的最大和1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; int ans = dp[0]; for (int i = 1; i &lt; n; i ++) { dp[i] = max(nums[i], dp[i - 1] + nums[i]); ans = max(ans, dp[i]); } return ans; }}; LCP 07. 传递信息12345678910111213class Solution {public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) { vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(15, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= k; i ++) for(auto &amp;r: relation) { int a = r[0], b = r[1]; dp[i][b] += dp[i - 1][a]; } return dp[k][n - 1]; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7DP/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"状态DP","slug":"状态DP","link":"/tags/%E7%8A%B6%E6%80%81DP/"},{"name":"背包DP","slug":"背包DP","link":"/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"序列DP","slug":"序列DP","link":"/tags/%E5%BA%8F%E5%88%97DP/"},{"name":"线性DP","slug":"线性DP","link":"/tags/%E7%BA%BF%E6%80%A7DP/"}],"categories":[{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}