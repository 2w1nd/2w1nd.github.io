{"pages":[{"title":"","text":"About Me​ 一个菜狗","link":"/about/index.html"}],"posts":[{"title":"dubbo从入门到实战","text":"1 互联网系统架构演变​ 随着互联网的发展，网站应用规模不断壮大，由此系统架构也在不断演变，下图是一张经典的演变过程图： 单一应用架构 ​ 优点：当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本 ​ 缺点：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护 ​ 此时：用于简化增删改查工作量的数据访问框架（ORM）是关键 垂直应用架构 ​ 优点：解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率 ​ 缺点：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。 ​ 此时：用于加速前端页面开发的Web框架（MVC）是关键 分布式应用架构（RPC） ​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心 ​ 此时：用于提高业务复用及整合的分布式服务框架（RPC）是关键 流动计算架构（SOA） ​ 随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架 ​ 此时，用于提高机器利用率**资源调度和治理中心(SOA)**是关键。 2 什么是Dubbo​ Dubbo是一个微服务开发框架，提供了RPC通信与微服务治理两大关键能力。它提供了远程过程调用的能力，使得远程调用像本地调用一样方便 ​ Dubbo提供的基础能力包括： 服务发现 流式通信 负载均衡 流量治理 集群容错 服务降级 … 3 Dubbo总体架构​ 以下是官网的一张图 节点 说明 Consumer 需要调用远程服务的服务消费方 Registry 注册中心 Provider 服务提供方 Container 服务运行的容器 Monitor 监控中心 ​ 通过上图，可以知道服务发现整体流程如下： 服务提供者Provider启动然后向注册中心注册自己所能提供的服务。 消费者Consumer启动向注册中心订阅所需的服务。 然后注册中心返回服务提供者地址列表给消费者Consumer，如果有变更，注册中心将基于长连接推送变更数据给消费者Consumer。 消费者Consumer就可以负载均衡选择一个Provier直接调用。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4 快速入门​ 新建两个Maven项目，JDK版本1.8，Dubbo版本2.7，一个消费者，一个提供者 引入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;groupId&gt;com.tiza.leo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo_001_p&lt;/artifactId&gt; &lt;!--引入依赖--&gt; &lt;dependencies&gt; &lt;!-- core context beans spring三件套--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo 2.5.3--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper zkclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 提供端代码 UserService 12345678package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} UserServiceImpl 12345678910111213package com.w1nd.dubbo.service;public class UserServiceImpl implements UserService { public String findName(String name) { System.out.println(&quot;姓名:&quot; +name); return &quot;hello: &quot;+name; } public void addUser(String username) { System.out.println(&quot;添加用户,用户名为: &quot;+username); }} spring-dubbo.xml（重要） 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过duboo发布服务 --&gt; &lt;dubbo:application name=&quot;dubbo_001_p&quot;&gt;&lt;/dubbo:application&gt; &lt;!--将服务注册到指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--指定服务的协议 和 使用端口号 注意此处服务端使用客户端无需使用 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt; &lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--注册服务到注册中心--&gt; &lt;dubbo:service interface=&quot;com.w1nd.dubbo.service.UserService&quot; ref=&quot;userService&quot; timeout=&quot;4000&quot;&gt; &lt;!--定义超时时间方二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:service&gt; &lt;!--服务提供者--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.w1nd.dubbo.service.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 测试代码 1234567891011121314151617package com.w1nd.dubbo.publish;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;import static org.junit.Assert.*;public class PublishServiceTest { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); System.out.println(&quot;服务提供者,开始提供服务.....&quot;); System.in.read(); }} 消费端代码 UserService 1234567package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} spring-dubbo.xml（重要） 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过dubbo消费服务--&gt; &lt;dubbo:application name=&quot;dubbo_001_c&quot;/&gt; &lt;!--指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--关闭所有服务的启动时检查 (没有提供者时报错)：--&gt; &lt;dubbo:consumer timeout=&quot;5000&quot; &gt;&lt;/dubbo:consumer&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--调用服务--&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.w1nd.dubbo.service.UserService&quot; timeout=&quot;4000&quot; &gt; &lt;!--定义超时时间方式二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:reference&gt; &lt;/beans&gt; 测试代码 12345678910111213141516package com.w1nd.dubbo.invoke;import com.w1nd.dubbo.service.UserService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class InvokeServiceTest { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.addUser(&quot;w1nd&quot;); /* String serverReturn = userService.findName(&quot;GouSheng&quot;); System.out.println(&quot;get message from server message is &quot; + serverReturn);*/ }} 5 集群​ 不同消费者的使用端口号设置不一样，即可。 dubbo_cluster_001_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_002_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_003_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20883&quot;&gt;&lt;/dubbo:protocol&gt; 参考(96条消息) 朋友国企干了5年java，居然不知道Dubbo是做什么呢？我真信了！_敖丙-CSDN博客 Dubbo3 简介 | Apache Dubbo","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/dubbo%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"},{"title":"zookeeper基本使用与集群搭建","text":"1. ZK简介​ 一个分布式的，开放源码的分布式应用程序协调服务。 2. ZK数据模型2.1 模型结构​ 2.2 模型的特点 每个子目录如/node1都被称作一个znode（节点）。这个znode是它所在的路径唯一标识 znode可以有子节点目录，并且每个znode可以存储数据 znode是有有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据 znode是可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端 3. 节点的分类3.1 持久节点（PERSISTENT）​ 指在节点创建后，就一直存在，知道有删除操作来主动删除这个节点–会因为创建该节点的客户端会话失效而消失 3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）​ 这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 3.3 临时节点（EPHEMERAL）​ 和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）​ 具有临时节点特点额外的特性是，每个父节点会为他的第一级子节点维护一份时序。这点和刚才提到的持久顺序节点类似 4. 安装4.1 linux系统安装 安装JDK 12tar -zxvf jdk-8u171-linux-x64.tar.gz mv ./jdk1.8.0_171/ /usr/java/ 12vim /etc/profilesource /etc/profile 安装ZK 1tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz 1cd conf/ 由于zk默认加载的是zoo.cfg，所以需要改名 1mv zoo_sample.cfg zoo.cfg 由于zookeeper加载要将节点加载到磁盘，所以需要预先新建一个磁盘目录 1mkdir /tmp/zookeeper 启动ZK 1234567[root@localhost bin]# ./zkServer.sh start /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg ZooKeeper JMX enabled by defaultUsing config: /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfgStarting zookeeper ... STARTED# 查看是否启动jps ​ QuorumPeerMain就是zk 连接ZK 1./zkCli.sh -server 192.168.9.3:2181 如果是本机，-server后可不加 5. 配置文件说明 tickTime：集群节点心跳时间， initLimit：初始化集群时集群节点同步超时时间20s syncLimit：集群在运行过程中，同步数据超时时间为10s（这里5是指5次心跳） dataDir：默认数据存储位置 clientPort：zk服务监听端口号 maxClientCnxns：线程池线程数量 6. 客户端基本指令 查看节点 1ls / # 根节点 创建节点 12345create path data # 创建一个节点，并给节点绑定数据（默认是持久性节点）- create path data # 持久节点- create -s path data # 持久性顺序节点- create -e path data # 临时性节点- create -e -s path data # 临时顺序节点 quit：会直接导致会话断开，会话失效，其他ctrl+c会导致触发倒计时 注：临时节点上不能创建任何节点 查看节点状态 1stat /node1 cZxid：创建事务ID ctime：创建时间 mZxid：修改ID mtime：修改时间 pZxid：父结点版本号 cversion：创建版本号 dataVersion：数据版本号 aclVersion： ephemerslOwner：是否是临时节点 dataLength：存储数据长度 numChildren：子节点数量 获得节点上绑定的数据信息 1get /node1 删除节点 1delete /node1 只能删除没有子节点的节点，如果有子节点，则无法删除 若想删除有子节点的，则需要deleteall 7. watch节点监听机制监听分为节点目录监听和节点数据监听 目录监听是监听节点目录的变化 数据监听是监听当前节点数据的变化 两种监听都是一次性的，也就是发现一个修改，下次修改则不会触发监听机制 目录监听 1ls -w /node 再次创建，无触发 数据监听 1get -w /node 8. Java操作ZK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.w1nd.test;import org.I0Itec.zkclient.IZkChildListener;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import org.I0Itec.zkclient.serialize.SerializableSerializer;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.data.Stat;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.List;public class TestZKClient { private ZkClient zkClient; // 1. 在zk创建节点 @Test public void testCreateNode() { // 1. 持久节点 zkClient.create(&quot;/node1&quot;, &quot;xiaochen&quot;, CreateMode.PERSISTENT); // 2. 持久顺序节点 zkClient.create(&quot;/node1/names&quot;, &quot;zhangsan&quot;, CreateMode.PERSISTENT_SEQUENTIAL); // 3. 临时节点 zkClient.create(&quot;/node1/lists&quot;, &quot;xiaoxiao&quot;, CreateMode.EPHEMERAL); // 4. 临时顺序节点 zkClient.create(&quot;/node1/lists1&quot;, &quot;xiaoming&quot;, CreateMode.EPHEMERAL_SEQUENTIAL); } // 2. 删除节点 @Test public void testDeleteNode() { // 删除没有子节点的节点，返回值：是否成功 boolean delete = zkClient.delete(&quot;/node1&quot;); // 递归删除节点信息，返回值：是否删除成功 boolean b = zkClient.deleteRecursive(&quot;/node1&quot;); } // 3. 查询当前节点下所有子节点 @Test public void testFindNodes() { // 获取指定路径的节点信息 List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;); for (String child : children) { System.out.println(child); } } // 4. 查看某个节点数据，注意：通过java客户端操作需要保证节点存储的数据和节点时序列化方式一致 // shell中的数据序列化方式和java中的不一致 @Test public void testFindNodeData() { Object readData = zkClient.readData(&quot;/node3&quot;); System.out.println(readData); } // 5. 查看节点状态信息 @Test public void testFindNodeDataAndStat() { Stat stat = new Stat(); Object readData = zkClient.readData(&quot;/node1&quot;, stat); System.out.println(readData); System.out.println(stat); } // 6. 修改节点数据 @Test public void testWriteData() { // User user = new User(); // user.setId(1); // zkClient.writeData(&quot;/node1&quot;, user); } // 监听节点数据的变化 @Test public void testOnNodeDataChange() throws IOException { zkClient.subscribeDataChanges(&quot;/node1&quot;, new IZkDataListener() { // 当节点数据变化时触发对应这个方法 @Override public void handleDataChange(String s, Object o) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); System.out.println(&quot;当前节点变化后数据：&quot; + o); } // 当前节点删除时触发这个方法 @Override public void handleDataDeleted(String s) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); } }); System.in.read(); // 阻塞当前监听 } // 监听节点目录的变化 @Test public void testOnNodesChange() throws IOException { zkClient.subscribeChildChanges(&quot;/node1&quot;, new IZkChildListener() { // 当节点的发生变化时，会自动调用这个方法 // 参数1：父节点名称 // 参数2：父节点中的所有子节点名称 @Override public void handleChildChange(String s, List&lt;String&gt; list) throws Exception { System.out.println(&quot;父节点名称：&quot; + s); System.out.println(&quot;发生变更后孩子节点名称：&quot;); for (String name: list) { System.out.println(name); } } }); System.in.read(); // 阻塞当前监听 } @Before public void before() { // 参数1：Server服务器ip地址 // 参数2：会话超时时间 // 参数3：连接超时时间 // 参数4：序列化方式 zkClient = new ZkClient(&quot;192.168.9.3:2181&quot;, 60000 * 30, 60000, new SerializableSerializer()); } @After // 释放资源 public void after() { zkClient.close(); } // 获取连接 public static void main(String[] args) { }} 9. ZK集群9.1 集群（cluster）​ 集群是指同一种软件服务的多个节点同时提供服务 ​ 集群解决了什么问题？ 单节点的并发访问的压力问题 单节点故障问题 9.2 集群架构 9.3 集群搭建 在~目录下新建三个文件夹 1mkdir zkdata1 zkdata2 zkdata3 建立myid文件 1touch zkdata1/myid zkdata2/myid zkdata3/myid 为每个zk指定id 123echo &quot;1&quot; &gt;&gt; zkdata1/myid echo &quot;2&quot; &gt;&gt; zkdata2/myid echo &quot;3&quot; &gt;&gt; zkdata3/myid 添加配置文件 12345678910111213vim zkdata1/zoo.cfgvim zkdata2/zoo.cfgvim zkdata3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/root/zkdata1clientPort=3001server.1=196.168.9.3:3002:3003server.2=192.158.9.3:4002:4003server.3=192.168.9.3:5002:5003 相关操作 12345678# 启动./bin/zkServer.sh start /root/zkdata1/zoo.cfg./bin/zkServer.sh start /root/zkdata2/zoo.cfg./bin/zkServer.sh start /root/zkdata3/zoo.cfg# 查看状态./bin/zkServer.sh status /root/zkdata1/zoo.cfg# 停止./bin/zkServer.sh stop /root/zkdata1/zoo.cfg","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"前缀和","text":"525. 连续数组 1234567891011121314151617181920class Solution {public: int findMaxLength(vector&lt;int&gt;&amp; nums) { /* 由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 cur 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 curcur 值即可 */ unordered_map&lt;int, int&gt; hash{{0, -1}}; int cur = 0, ans = 0; for (int i = 0; i &lt; nums.size(); i ++) { cur += nums[i] == 0 ? -1 : 1; if (hash.count(cur)) { ans = max(ans, i - hash[cur]); } else { hash[cur] = i; } } return ans; }}; 剑指 Offer II 010. 和为 k 的子数组 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"位运算","text":"剑指 Offer II 004. 只出现一次的数字刷穿剑指offer-Day02-整数II 004.只出现一次的数字 位运算讲解 - 只出现一次的数字 12345678910111213141516class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int ret = 0; for (int i = 0; i &lt; 32; i ++) { int cnt = 0; for (auto num: nums) { cnt += num &gt;&gt; i &amp; 1; } if (cnt % 3 != 0) { ret |= 1 &lt;&lt; i; } } return ret; }}; 剑指 Offer II 005. 单词长度的最大乘积123456789101112131415161718192021222324class Solution {public: int maxProduct(vector&lt;string&gt;&amp; words) { int n = words.size(); vector&lt;int&gt; dict(n, 0); for (int i = 0; i &lt; words.size(); i ++) { int t = 0; for (auto c: words[i]) { int bit = c - 'a'; t |= (1 &lt;&lt; bit); } dict[i] = t; } int ans = 0; for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; i; j ++) if ((dict[i] &amp; dict[j]) == 0) { int temp = words[i].size() * words[j].size(); ans = max(ans, temp); } return ans; } };","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"区间DP","text":"87. 扰乱字符串1234567891011121314151617181920212223242526272829class Solution {public: bool isScramble(string s1, string s2) { int n = s1.size(); if (s1 == s2) return true; if (s1.size() != s2.size()) return false; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, false))); // 处理长度为1的情况 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; n; j ++) if (s1[i] == s2[j]) f[i][j][1] = true; // f[i][j][len] 代表 s1s1 从 ii 开始，s2s2 从 jj 开始，后面长度为 lenlen 的字符是否能形成「扰乱字符串」（互为翻转）。 for (int len = 2; len &lt;= n; len ++) for (int i = 0; i &lt;= n - len; i ++) for (int j = 0; j &lt;= n - len; j ++) for (int k = 1; k &lt; len; k ++) { // 分割点 // a : 0 - i, b : 0 - j ; a: i - n, j - n bool a = f[i][j][k] &amp;&amp; f[i + k][j + k][len - k]; // a : 0 - i, b : n - i, n ; a: i - n, 0 - j bool b = f[i][j + len - k][k] &amp;&amp; f[i + k][j][len - k]; if (a || b) { f[i][j][len] = true; } } return f[0][0][n]; }}; 375. 猜数字大小 II1234567891011121314151617181920class Solution {public: int getMoneyAmount(int n) { //定义 f[l][r]f[l][r] 为考虑在 [l, r][l,r] 范围内进行猜数的最小成本。 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); // 需要找到能猜中数字的最小成本，也就是最坏情况最好的结果 // 对于任一区间取min是因为我们在该区间可以先选择小的数去试，由此降低成本 for (int len = 2; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; f[l][r] = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cur = max(f[l][x - 1], f[x + 1][r]) + x; f[l][r] = min(f[l][r], cur); } } return f[1][n]; }}; 516. 最长回文子序列123456789101112131415161718192021222324252627282930313233class Solution {public: /* bb aa bb bb a bb dp[i][j] 表示 第 i 个字符到 第 j 个字符之间最长的回文子序列长度 1、当 s[i] == s[j] 时，考虑 i 和 j 中间序列的奇偶个数， dp[i][j] = dp[i+1][j-1] + 2 对上述 dp[i][j] = dp[i+1][j-1] + 2 的解释： 当序列为 b aa b 时， i = 0, j = 3，则 dp[0][3] = dp[1][2] + 2 = 4 当序列为 b a b 时，i = 0, j = 2，则 dp[0][2] = dp[1][1] + 2 = 3 当序列为 b b 时， i = 0, j = 1，则 dp[0][1] = dp[1][0] = 0 + 2 = 2 (dp[1][0] 默认值为 0) 该式子同时考虑到了奇偶 2、当 s[i] != s[j] ，那么 dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]) 对上述 dp[i][j] 式子的解释： 假如序列为 d c b c c（index：0-4），s[0] != s[4] ，则 dp[0][4] = Math.max(dp[0][3],dp[1,4]) = Math.max(2,3) = 3 */ int longestPalindromeSubseq(string s) { int n = s.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i + 1][j - 1] + 2; } else { f[i][j] = max(f[i + 1][j], f[i][j - 1]); } } } return f[0][n - 1]; }}; 664. 奇怪的打印机123456789101112131415161718192021class Solution {public: int strangePrinter(string s) { int n = s.size(); // f[i][j] 表示 区间[i,j]的最小打印次数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i][j - 1]; } else { for (int k = i; k &lt; j; k ++) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } } return f[0][n - 1]; }}; 877. 石子游戏1234567891011121314151617class Solution {public: bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); // 定义 f[l][r]f[l][r] 为考虑区间 [l,r][l,r]，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); for (int len = 1; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; int a = piles[l - 1] + f[l + 1][r]; int b = piles[r - 1] + f[l][r - 1]; f[l][r] = max(a, b); } return f[1][n] &gt; 0; }};","link":"/2022/02/02/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4DP/"},{"title":"双指针","text":"剑指 Offer II 008. 和大于等于 target 的最短子数组123456789101112class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(), sum = 0, res = INT_MAX; for (int i = 0, j = 0; i &lt; n; i ++) { sum += nums[i]; while (sum - nums[j] &gt;= target) sum -= nums[j ++]; if (sum &gt;= target) res = min(res, i - j + 1); } return res == INT_MAX ? 0 : res; }}; 剑指 Offer II 009. 乘积小于 K 的子数组 1234567891011121314class Solution {public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) { //已知ABC &lt; target, 新增一位X变成ABCX, 若ABCX &lt; target 则新增的subarray中必须满足 1.连续 2.包含X //所以从X向左数: X, CX, BCX, ABCX int n = nums.size(), product = 1, res = 0; for (int i = 0, j = 0; i &lt; n; i ++ ) { product *= nums[i]; while (i &gt;= j &amp;&amp; product &gt;= k) product /= nums[j ++]; res += i - j + 1; } return res; }}; 剑指 Offer II 010. 和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }}; 剑指 Offer II 014. 字符串中的变位词 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617class Solution {public: bool checkInclusion(string s1, string s2) { map&lt;char, int&gt; hash; // 存储子串各个字符数量 for (auto c: s1) hash[c] ++; int tot = hash.size(), statify = 0; // tot是字符总数，statify是s2中满足要求的数量 for (int i = 0, j = 0; i &lt; s2.size(); i ++) { if (--hash[s2[i]] == 0) statify ++; while (i - j + 1 &gt; s1.size()) { // 窗口大小小于s1.size if (hash[s2[j]] == 0) statify --; hash[s2[j ++]] ++; } if (statify == tot) return true; } return false; }}; 剑指 Offer II 017. 含有所有字符的最短字符串 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920class Solution {public: string minWindow(string s, string t) { map&lt;char, int&gt; hash; for (auto c: t) hash[c] ++; int tot = hash.size(), statify = 0; string res; for (int i = 0, j = 0; i &lt; s.size(); i ++) { if (hash[s[i]] == 1) statify ++; hash[s[i]] --; while (hash[s[j]] &lt; 0) hash[s[j ++]] ++; // 注意这里是&lt;，所以不会出现后续的不符合要求的字符顶去前面的，例如BANC，N的出现不会将B删去 if (statify == tot) { if (res.empty() || res.size() &gt; i - j + 1) { res = s.substr(j, i - j + 1); } } } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"状压DP","text":"526. 优美的排列123456789101112131415161718class Solution {public: int countArrangement(int n) { int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(mask, 0)); f[0][0] = 1; // 考虑前i个数，状态为0的方案数（优美排列数量） for (int i = 1; i &lt;= n; i ++) // 枚举当前位置 for (int state = 1; state &lt;= mask; state ++) // 枚举当前状态，0为选该数，1为不选 for (int k = 1; k &lt;= n; k ++) { // 枚举当前位置填了什么数 if (!((state &gt;&gt; (k - 1)) &amp; 1)) continue; // 如果当前数在状态中为0，则跳过 if (k % i &amp;&amp; i % k) continue; // 不满足任何整除关系 // state &amp; (~(1 &lt;&lt; (k - 1))) 代表将 state 中数值 k 的位置置零 f[i][state] += f[i - 1][state &amp; ~(1 &lt;&lt; (k - 1))]; } return f[n][mask - 1]; }}; 847. 访问所有节点的最短路径1234567891011121314151617181920212223242526class Solution {public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; dist(mask, vector&lt;int&gt;(n + 1, INT_MAX)); // state和u(该状态下的最后一步)对应的步数 deque&lt;vector&lt;int&gt;&gt; d; // 存储state 和 u for (int i = 0; i &lt; n; i ++) { dist[1 &lt;&lt; i][i] = 0; d.push_back({1 &lt;&lt; i, i}); } while (!d.empty()) { auto poll = d.front(); d.pop_front(); int state = poll[0], u = poll[1], step = dist[state][u]; if (state == mask - 1) return step; for (int i: graph[u]) { if (dist[state | (1 &lt;&lt; i)][i] == INT_MAX) { dist[state | (1 &lt;&lt; i)][i] = step + 1; d.push_back({state | (1 &lt;&lt; i), i}); } } } return -1; }};","link":"/2022/02/03/%E7%AE%97%E6%B3%95/%E7%8A%B6%E5%8E%8BDP/"},{"title":"背包DP","text":"279. 完全平方数 12345678910111213class Solution {public: int numSquares(int n) { // dp[i] 表示 能凑出i的完全平方数的最小数量 vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i ++) { dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j ++) dp[i] = min(dp[i], dp[i - j * j] + 1); } return dp[n]; }}; 322. 零钱兑换 12345678910111213class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 1e9); dp[0] = 0; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) dp[j] = min(dp[j], dp[j - coins[i]] + 1); if (dp[amount] == 1e9) return -1; return dp[amount]; }}; 416. 分割等和子集 12345678910111213141516class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = 0; for (auto &amp;x: nums) sum += x; int target = sum / 2; if (target * 2 != sum) return false; vector&lt;int&gt; dp(target + 1, 0); // dp[i] 表示 凑出 i 所需的价值数 for (auto &amp;x: nums) for (int j = target; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } return dp[target] == target; }}; 474. 一和零 12345678910111213141516171819202122232425class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int len = strs.size(); vector&lt;vector&lt;int&gt;&gt; cnt(len, vector&lt;int&gt;(2, 0)); for (int i = 0; i &lt; len; i ++) { int zero = 0, one = 0; for (auto &amp;c: strs[i]) { if (c == '1') one ++; else zero ++; } cnt[i][0] = zero, cnt[i][1] = one; } vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int k = 0; k &lt; len; k ++) { int zero = cnt[k][0], one = cnt[k][1]; for (int i = m; i &gt;= zero; i --) for (int j = n; j &gt;= one; j --) { f[i][j] = max(f[i][j], f[i - zero][j - one] + 1); } } return f[m][n]; }}; 494. 目标和 1234567891011121314151617181920class Solution {public: const int Offset = 1000; int findTargetSumWays(vector&lt;int&gt;&amp; a, int t) { int n = a.size(); int s = 0; for (int i: a) s += abs(i); if (abs(t) &gt; s) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2 * s + 1, 0)); dp[0][s] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = -s; j &lt;= s; j ++) { if (j - a[i - 1] &gt;= -s) dp[i][j + s] += dp[i - 1][j - a[i - 1] + s]; if (j + a[i - 1] &lt;= s) dp[i][j + s] += dp[i - 1][j + a[i - 1] + s]; } return dp[n][t + s]; }}; 518. 零钱兑换 II 1234567891011121314class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { // dp[i][j] 表示 考虑前i个物品，凑出 j 的方案数 int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) { dp[j] += dp[j - coins[i]]; } return dp[amount]; }}; 879. 盈利计划 12345678910111213141516171819class Solution {public: const int MOD = 1e9 + 7; // dp[i][j][k] 表示 前i个个物品，人数不超过j，利润至少为k的方案数 int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) { int m = group.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(minProfit + 1, 0)); for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= m; i ++) { int a = group[i - 1], b = profit[i - 1]; for (int j = n; j &gt;= a; j --) for (int k = minProfit; k &gt;= 0; k --) { dp[j][k] += dp[j - a][max(k - b, 0)]; dp[j][k] %= MOD; } } return dp[n][minProfit]; }}; 1049. 最后一块石头的重量 II 未优化空间 问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值进一步分析：要让差值小,两堆石头的重量都要接近sum/2;我们假设两堆分别为A,B,A&lt;sum/2,B&gt;sum/2,若A更接近sum/2,B也相应更接近sum/2进一步转化：将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;、 123456789101112131415161718// d[i][j]代表考虑前 i 个物品（数值），凑成总和不超过 j 的最大价值。class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(t + 1, 0)); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = 0; j &lt;= t; j ++) { dp[i][j] = dp[i - 1][j]; if (j &gt;= x) dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + x); } } return sum - 2 * dp[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;int&gt; dp(t + 1, 0); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = t; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } } return sum - 2 * dp[t]; }}; 1155. 掷骰子的N种方法 未优化空间 1234567891011121314class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(t + 1, 0)); f[0][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 0; j &lt;= t; j ++) for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[i][j] = (f[i][j] + f[i - 1][j - k]) % MOD; } return f[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;int&gt; f(t + 1, 0); f[0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = t; j &gt;= 0; j --) { f[j] = 0; //由于我们直接是在 f[i][j]f[i][j] 格子的基础上进行方案数累加，因此在计算 f[i][j]f[i][j] 记得手动置零。 for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[j] = (f[j] + f[j - k]) % MOD; } } return f[t]; }}; 1449. 数位成本和为目标值的最大数字 1234567891011121314151617181920212223242526class Solution {public: // dp[i][j] 表示 考虑前i个物品，总成本为j的最大整数长度 string largestNumber(vector&lt;int&gt;&amp; cost, int t) { int n = cost.size(); vector&lt;int&gt; dp(t + 1, INT_MIN); dp[0] = 0; for (int i = 1; i &lt;= n; i ++) { int x = cost[i - 1]; for (int j = x; j &lt;= t; j ++) { dp[j] = max(dp[j], dp[j - x] + 1); } } if (dp[t] &lt; 0) return &quot;0&quot;; string res = &quot;&quot;; for (int i = 9, j = t; i &gt;= 1; i --) { int x = cost[i - 1]; while (j &gt;= x &amp;&amp; dp[j] == dp[j - x] + 1) { res += to_string(i); j -= x; } } return res; }}; 1995. 统计特殊四元组 123456789101112131415161718192021class Solution {public: int countQuadruplets(vector&lt;int&gt;&amp; nums) { // dp[i][j][k] 考虑前i个数，恰好凑出j，使用个数为k的方案数 int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(110, vector&lt;int&gt;(4, 0))); f[0][0][0] = 1; for (int i = 1; i &lt;= n; i ++) { int x = nums[i - 1]; for (int j = 0; j &lt; 110; j ++) for (int k = 0; k &lt; 4; k ++) { f[i][j][k] += f[i - 1][j][k]; if (j &gt;= x &amp;&amp; k &gt;= 1) f[i][j][k] += f[i - 1][j - x][k - 1]; } } int res = 0; for (int i = 3; i &lt; n; i ++) res += f[i][nums[i]][3]; return res; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85DP/"},{"title":"记忆化搜索","text":"87. 扰乱字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int Y = 1, N = -1; string s1, s2; bool isScramble(string _s1, string _s2) { s1 = _s1, s2 = _s2; if (s1 == s2) return true; if (s1.size() != s2.size()) return false; int n = s1.size(); // cache表示s1从i开始，s2从j开始 len 位，是否形成扰动字符串 cache.resize(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0))); return dfs(0, 0, n); } bool dfs(int i, int j, int len) { if (cache[i][j][len] != 0) return cache[i][j][len] == Y; string a = s1.substr(i, len), b = s2.substr(j, len); if (a == b){ cache[i][j][len] = Y; return true; } if (!check(a, b)) { cache[i][j][len] = N; return false; } for (int k = 1; k &lt; len; k ++) { if (dfs(i, j, k) &amp;&amp; dfs(i + k, j + k, len - k)) { cache[i][j][len] = Y; return true; } if (dfs(i, len - k + j, k) &amp;&amp; dfs(i + k, j, len - k)) { cache[i][j][len] = Y; return true; } } cache[i][j][len] = N; return false; } bool check(string a, string b) { if (a.size() != b.size()) return false; vector&lt;int&gt; cnt1(26, 0), cnt2(26, 0); for (auto c: s1) { cnt1[c - 'a'] ++; } for (auto c: s2) { cnt2[c - 'a'] ++; } return cnt1 == cnt2; }}; 375. 猜数字大小 II12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; int getMoneyAmount(int n) { cache.resize(n + 1, vector&lt;int&gt;(n + 1, 0)); return dfs(1, n); } int dfs(int l, int r) { if (l &gt;= r) return 0; if (cache[l][r] != 0) return cache[l][r]; int ans = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cnt = max(dfs(l, x - 1), dfs(x + 1, r)) + x; ans = min(ans, cnt); } cache[l][r] = ans; return ans; }}; 403. 青蛙过河1234567891011121314151617181920212223242526272829303132class Solution {public: unordered_map&lt;string, bool&gt; cache; // 存储u下标跳k步有没有方案 unordered_map&lt;int, int&gt; map; // 存储每个石块对应的下标 bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); for (int i = 0; i &lt; n; i ++) { map.insert({stones[i], i}); } if (!map.count(1)) return false; return dfs(stones, n, 1, 1); } bool dfs(vector&lt;int&gt; &amp;stones, int n, int u, int k) { if (u == n - 1) return true; string key = to_string(u) + '_' + to_string(k); if (cache.count(key)) return cache[key]; for (int i = -1; i &lt;= 1; i ++) { if (k + i == 0) continue; int next = stones[u] + i + k; // 下一个跳跃点 if (map.count(next)) { bool cur = dfs(stones, n, map[next], k + i); cache.insert({key, cur}); if (cur) return true; } } cache.insert({key, false}); return false; }}; 494. 目标和12345678910111213141516171819202122class Solution {public: unordered_map&lt;string, int&gt; cache; // 表示从u下标,当前计算结果为string，的方案数int int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { return dfs(nums, target, 0, 0); } int dfs(vector&lt;int&gt; &amp;nums, int target, int u, int cur) { string key = to_string(u) + '_' + to_string(cur); if (cache.count(key)) return cache[key]; if (u == nums.size()) { cache.insert({key, cur == target ? 1: 0}); return cache[key]; } int left = dfs(nums, target, u + 1, cur - nums[u]); int right = dfs(nums, target, u + 1, cur + nums[u]); cache.insert({key, left + right}); return cache[key]; }}; 552. 学生出勤记录 II1234567891011121314151617181920212223class Solution {public: // cache 是指 下标为u，连续a个数为acnt，l个数为lcnt的方案数 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int mod = (int)1e9 + 7; int checkRecord(int n) { cache.resize(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3, -1))); return dfs(n, 0, 0); } int dfs(int u, int acnt, int lcnt) { if (acnt &gt;= 2) return 0; if (lcnt &gt;= 3) return 0; if (u == 0) return 1; if (cache[u][acnt][lcnt] != -1) return cache[u][acnt][lcnt]; int ans = 0; ans = dfs(u - 1, acnt + 1, 0) % mod; // A ans = (ans + dfs(u - 1, acnt, lcnt + 1)) % mod; // L ans = (ans + dfs(u - 1, acnt, 0)) % mod; // P cache[u][acnt][lcnt] = ans; return ans; }}; 576. 出界的路径数12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int MOD = (int) 1e9 + 7; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { cache.resize(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, -1))); return dfs(m, n, maxMove, startRow, startColumn); } int dfs(int m, int n, int u, int x, int y) { if (x &gt;= m || x &lt; 0) return 1; if (y &gt;= n || y &lt; 0) return 1; if (u == 0) return 0; if (cache[u][x][y] != -1) return cache[u][x][y]; int ans = 0; ans = dfs(m, n, u - 1, x + 1, y) % MOD; ans = (ans + dfs(m, n, u - 1, x, y + 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x, y - 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x - 1, y)) % MOD; cache[u][x][y] = ans; return ans; }}; 1137. 第 N 个泰波那契数12345678910111213class Solution {public: int cache[40]; int tribonacci(int n) { if (n == 0) return 0; if (n == 1 || n == 2) return 1; if (cache[n] != 0) return cache[n]; cache[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3); return cache[n]; }}; 剑指 Offer 10- I. 斐波那契数列1234567891011121314class Solution {public: int mod = (int) 1e9 + 7; int cache[110]; int fib(int n) { if (n &lt;= 1) return n; if (cache[n] != 0) return cache[n]; cache[n] = fib(n - 1) + fib(n - 2); cache[n] %= mod; return cache[n]; }}; 638. 大礼包 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;int&gt; price; vector&lt;vector&lt;int&gt;&gt; special; vector&lt;int&gt; needs; map&lt;vector&lt;int&gt;, int&gt; cache; int shoppingOffers(vector&lt;int&gt;&amp; _price, vector&lt;vector&lt;int&gt;&gt;&amp; _special, vector&lt;int&gt;&amp; _needs) { price = _price; special = _special; needs = _needs; return dfs(needs); } int dfs(vector&lt;int&gt; needs) { if (cache.count(needs)) { return cache[needs]; } int n = needs.size(); int minN = 0; for (int i = 0; i &lt; n; i ++) { minN += price[i] * needs[i]; } for (int i = 0; i &lt; special.size(); i ++) { bool flag = true; vector&lt;int&gt; nextNeeds = needs; for (int j = 0; j &lt; n; j ++) { if (special[i][j] &gt; nextNeeds[j]) flag = false; nextNeeds[j] -= special[i][j]; } if (!flag) continue; minN = min(minN, dfs(nextNeeds) + special[i][n]); } return cache[needs] = minN; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"title":"序列DP","text":"334. 递增的三元子序列 12345678910111213141516class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int small = INT_MAX, big = INT_MAX; for (int x: nums) { if (x &lt;= small) { small = x; } else if (x &lt;= big) { big = x; } else { return true; } } return false; }}; 1234567891011121314151617181920class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1, INT_MAX); // f[len] = x 表示 以 长度为 len 的序列的最小尾元素为x int ans = 1; for (int i = 0; i &lt; n; i ++) { int l = 1, r = i + 1; int x = nums[i]; while (l &lt; r) { // 二分查找小于nums[i]的最小元素 int mid = l + r &gt;&gt; 1; if (f[mid] &gt;= x) r = mid; else l = mid + 1; } f[r] = x; ans = max(ans, r); } return ans &gt;= 3; }}; 354. 俄罗斯套娃信封问题 123456789101112131415161718class Solution {public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) { int n = envelopes.size(); vector&lt;int&gt; f(n, 0); // 以 i 结尾的最大信封 sort(envelopes.begin(), envelopes.end()); int res = 0; for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) { if (envelopes[i][0] &gt; envelopes[j][0] &amp;&amp; envelopes[i][1] &gt; envelopes[j][1]) f[i] = max(f[i], f[j] + 1); } res = max(res, f[i]); } return res; }}; 368. 最大整除子集 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, 0); // f[i] 表示 前i个数中以a[i]结尾的整除子集的最长序列的元素个数 sort(nums.begin(), nums.end()); int k = 0; // 整除序列最后一个元素下标 for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) if (nums[i] % nums[j] == 0) f[i] = max(f[i], f[j] + 1); if (f[k] &lt; f[i]) k = i; } vector&lt;int&gt; res; // 逆推得出答案 while (true) { res.push_back(nums[k]); if (f[k] == 1) break; // 只剩一个元素 for (int i = 0; i &lt; k; i ++) { if ((nums[k] % nums[i] == 0) &amp;&amp; f[k] == f[i] + 1) { k = i; break; } } } return res; }}; 390. 消除游戏 1234567class Solution {public: int lastRemaining(int n) { if (n == 1) return 1; return 2 * (n / 2 + 1 - lastRemaining(n / 2)); }}; 446. 等差数列划分 II - 子序列 LeetCode 446. 等差数列划分 II - 子序列 - AcWing 12345678910111213141516171819202122class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; a) { typedef long long LL; int n = a.size(); // 由于每个数可能都会在不同等差数列中，需要用哈希表来存 vector&lt;unordered_map&lt;LL, int&gt;&gt; f(n); // f[i][j] 表示 考虑以第 i 个数结尾 公差为j的等差数列的个数 int res = 0; for (int i = 0; i &lt; n; i ++) for (int k = 0; k &lt; i; k ++) { LL j = (LL)a[i] - a[k]; auto it = f[k].find(j); // 查找a[k]结尾公差为j的等差数列的个数 int t = 0; if (it != f[k].end()) { t = it-&gt;second; res += t; } f[i][j] += t + 1; } return res; }}; 472. 连接词 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: typedef unsigned long long ULL; unordered_set&lt;ULL&gt; hash; const int P = 131; vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) { // 初始化字符串哈希表 for (auto &amp;s: words) { ULL t = 0; for (auto &amp;c: s) { t = t * P + c; } hash.insert(t); } vector&lt;string&gt; res; for (auto &amp;s: words) if (check(s)) res.push_back(s); return res; } bool check(string str) { int n = str.size(); vector&lt;int&gt; f(n + 1, -1); // f[i] 表示 在i前面的连接词的个数 f[0] = 0; for (int i = 0; i &lt;= n; i ++) { if (f[i]== -1) continue; ULL cur = 0; for (int j = i + 1; j &lt;= n; j ++) { cur = cur * P + str[j - 1]; if (hash.count(cur)) { f[j] = max(f[j], f[i] + 1); } } if (f[n] &gt;= 2) return true; } return false; }}; 583. 两个字符串的删除操作 123456789101112131415161718class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 0; i &lt;= n; i ++) f[i][0] = 1; for (int j = 0; j &lt;= m; j ++) f[0][j] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i][j - 1], f[i - 1][j]); if (word1[i - 1] == word2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } int maxn = f[n][m] - 1; return n + m - 2 * maxn; }}; 629. K个逆序对数组 LeetCode 629. K个逆序对数组 - AcWing 123456789101112131415161718class Solution {public: const int MOD = 1e9 + 7; int kInversePairs(int n, int k) { // f[i][j] 表示 所有由数字 1 ~ i 组成的含有 j 个 逆序对的数组个数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1, 0)); f[1][0] = 1; for (int i = 2; i &lt;= n; i ++) { long long s = 0; for (int j = 0; j &lt;= k; j ++) { s += f[i - 1][j]; if (j &gt;= i) s -= f[i - 1][j - i]; f[i][j] = s % MOD; } } return (f[n][k] + MOD) % MOD; } }; 673. 最长递增子序列的个数 123456789101112131415161718192021class Solution {public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n), g(n); // f 表示 以i结尾的最长上升子序列长度，g 表示 以 i 结尾的最长上升子序列的个数 int maxl = 0, cnt = 0; // maxl是最长子序列长度，cnt是子序列个数 for (int i = 0; i &lt; n; i ++) { f[i] = g[i] = 1; for (int j = 0; j &lt; i; j ++) { if (nums[j] &lt; nums[i]) { if (f[i] &lt; f[j] + 1) f[i] = f[j] + 1, g[i] = g[j]; else if (f[i] == f[j] + 1) g[i] += g[j]; } } if (maxl &lt; f[i]) maxl = f[i], cnt = g[i]; else if (maxl == f[i]) cnt += g[i]; } return cnt; }}; 689. 三个无重叠子数组的最大和 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; s(n, 0); int sum = 0; for (int i = 0; i &lt; n; i ++) { sum += nums[i]; if (i &gt;= k) sum -= nums[i - k]; if (i &gt;= k - 1) s[i - k + 1] = sum; } vector&lt;int&gt; left(n, 0), right(n, 0); int maxIndex = 0; for (int i = 0; i &lt; n; i ++) { if (s[maxIndex] &lt; s[i]) maxIndex = i; left[i] = maxIndex; } maxIndex = n - 1; for (int i = n - 1; i &gt;= 0; i --) { if (s[maxIndex] &lt;= s[i]) maxIndex = i; right[i] = maxIndex; } vector&lt;int&gt; res(3, -1); for (int i = k; i &lt; n - k; i ++) { if (res[0] == -1 || s[res[0]] + s[res[1]] + s[res[2]] &lt; s[i] + s[left[i - k]] + s[right[i + k]]) { res[0] = left[i - k]; res[1] = i; res[2] = right[i + k]; } } return res; }}; 740. 删除并获得点数 1234567891011121314151617181920class Solution {public: const int N = 1e4 + 10; int deleteAndEarn(vector&lt;int&gt;&amp; nums) { // f[i][j] 表示是否删除 j 数 的 最大点数 int n = nums.size(); int maxn = 0; vector&lt;int&gt; cnt(N); for(auto x: nums) { cnt[x] ++; maxn = max(maxn, x); } vector&lt;vector&lt;int&gt;&gt; f(maxn + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= maxn; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = max(f[i][1], f[i - 1][0] + cnt[i] * i); } return max(f[maxn][0], f[maxn][1]); }}; 978. 最长湍流子数组 12345678910111213141516171819// 优化了空间class Solution {public: int maxTurbulenceSize(vector&lt;int&gt;&amp; arr) { int n = arr.size(); // f[i][0/1]表示 以i结尾的数组 元素状态为j的最大湍流子数组长度 vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(2, 0)); int ans = 1; f[0][0] = f[0][1] = 1; for (int i = 1; i &lt; n; i ++) { for (int j = 0; j &lt; 2; j ++) f[i % 2][j] = 1; if (arr[i - 1] &lt; arr[i]) f[i % 2][0] = f[(i - 1) % 2][1] + 1; if (arr[i - 1] &gt; arr[i]) f[i % 2][1] = f[(i - 1) % 2][0] + 1; for (int j = 0; j &lt; 2; j ++) ans = max(ans, f[i % 2][j]); } return ans; }}; 1035. 不相交的线 123456789101112131415161718class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int n = nums1.size(), m = nums2.size(); // f[i][j] 表示 考虑 前 i 个 数字，前 j 个数字组成最大公共子序列长度 // 最长公共子序列 是考虑的情况是不一定包含第i个字符的 // 例如，我们通常考虑f[i - 1][j]为前i - 1，j个数字的最长子序列，但这里不一定包含第j个，只是可能，所以 f[i - 1][j] 包含 f[i - 1][j - 1]; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (nums1[i - 1] == nums2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1143. 最长公共子序列 12345678910111213141516class Solution {public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (text1[i - 1] == text2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1218. 最长定差子序列 1234567891011121314151617181920212223class Solution {public: // 注意覆盖问题：hash.insert遇到一样的键不会覆盖 // 由于 arr长度 为 1e5，不能用两层循环，使用哈希表进行优化 int longestSubsequence(vector&lt;int&gt;&amp; arr, int diff) { int n = arr.size(); // f[i][j] 表示 前i个数，第i个数选或不选的最长定差子序列长度 vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][1] = 1; unordered_map&lt;int, int&gt; hash; hash[arr[0]] = 0; for (int i = 1; i &lt; n; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = 1; int prev = arr[i] - diff; if (hash.count(prev)) { f[i][1] = max(f[i][1], f[hash[prev]][1] + 1); } hash[arr[i]] = i; } return max(f[n - 1][0], f[n - 1][1]); }}; 1473. 粉刷房子 III 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: const int INF = 0x3f3f3f3f; int minCost(vector&lt;int&gt;&amp; houses, vector&lt;vector&lt;int&gt;&gt;&amp; cost, int n, int m, int t) { // f[i][j][k] 表示 考慮前i个房子，第i个房子粉刷为j，分区数量为k的所有方案中的最小总花费 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(t + 1, 0))); for (int i = 0; i &lt;= n; i ++) for (int j = 0; j &lt;= m; j ++) f[i][j][0] = INF; for (int i = 1; i &lt;= n; i ++) { int color = houses[i - 1]; // 当前房子的颜色 for (int j = 1; j &lt;= m; j ++) { for (int k = 1; k &lt;= t; k ++) { if (k &gt; i) { // 如果分区数量大于房子数，不合法 f[i][j][k] = INF; continue; } if (color != 0) { // 当前房子已经染色 if (color == j) { // 只有与当前颜色相同才能被转移 int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp); // 与前面颜色相同的情况 } else { f[i][j][k] = INF; } } else { // 当前房子未被染色 int u = cost[i - 1][j - 1]; int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp) + u; // 与前面颜色相同的情况 } } } } int ans = INF; for (int i = 1; i &lt;= m; i ++) ans = min(ans, f[n][i][t]); return ans == INF ? -1: ans; }}; 1713. 得到子序列的最少操作次数 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: /* target 6 4 8 1 3 2 arr 4 7 6 2 3 8 6 1 list 1 0 5 4 2 0 3 */ int minOperations(vector&lt;int&gt;&amp; t, vector&lt;int&gt;&amp; a) { int n = t.size(), m = a.size(); unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; n; i ++) hash.insert({t[i], i}); // 建立 target 和 arr 的映射关系 vector&lt;int&gt; list; for (auto x: a) { // 由于target各元素不相同，list中保存了arr与target相同元素的下标，并且递增，故可转化为LIS问题 if (hash.count(x)) list.push_back(hash[x]); } int cnt = list.size(); // q[i] 表示 长度为i的上升子序列 中末尾元素最小的数 vector&lt;int&gt; q(cnt + 1, 0); // 使用LIS的贪心+二分的方法求解，复杂度为nlog(n) // 个人感觉这种优化方式主要是维护一个单调队列，每次加入新的元素，要和之前加入的对比， // 找到比自己小的最后一个数，那么它就可以代替这之前的那个数，因为它更小，更好维护递增序列， // 例如 1 3 5 ，加入1个4（规定长度3），那肯定4替换掉5更好 int len = 0; for (int i = 0; i &lt; cnt; i ++) { int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; list[i]) l = mid; else r = mid - 1; } q[r + 1] = list[i]; if (r + 1 &gt; len) len ++; } return n - len; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E5%BA%8F%E5%88%97DP/"},{"title":"线性DP","text":"10. 正则表达式匹配12345678910111213141516171819202122232425class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(), m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; // dp状态表示：dp[i][j] s以i结尾的子串与p以j结尾的子串是否匹配 vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; // 下一个是*，当前 字符不能单独使用，跳过 if (i - 1 &gt;= 0 &amp;&amp; p[j] != '*') { dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); // 对应了p[j]为普通字符和'.'两种情况 } else if (p[j] == '*') { // 字符为'*' dp[i][j] = (j - 2 &gt;= 0 &amp;&amp; dp[i][j - 2]) || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')); } } return dp[n][m]; }}; 44. 通配符匹配1234567891011121314151617181920class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(); int m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (p[j] != '*') { dp[i][j] = i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (p[j] == s[i] || p[j] == '?'); } else { dp[i][j] = dp[i][j - 1] || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j]); } } return dp[n][m]; }}; 45. 跳跃游戏 II123456789101112class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n); for (int i = 1, j = 0; i &lt; n; i ++) { while (j + nums[j] &lt; i) j ++; dp[i] = dp[j] + 1; } return dp[n - 1]; }}; 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string ss) { int n = ss.size(); string s = &quot; &quot; + ss; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; i ++) { int a = s[i] - '0', b = (s[i - 1] - '0') * 10 + (s[i] - '0'); if (a &gt;= 1 &amp;&amp; a &lt;= 9) dp[i] = dp[i - 1]; if (b &gt;= 10 &amp;&amp; b &lt;= 26) dp[i] += dp[i - 2]; } return dp[n]; }}; 115. 不同的子序列1234567891011121314151617181920class Solution {public: int numDistinct(string ss, string tt) { int n = ss.size(), m = tt.size(); string s = &quot; &quot; + ss; string t = &quot; &quot; + tt; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); // f[i][j] 表示 0~i，0~j的字符串匹配个数 for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { // 不匹配s[i] dp[i][j] = dp[i - 1][j]; if (s[i] == t[j]) { // 匹配s[i] dp[i][j] = (0LL + dp[i][j] + dp[i - 1][j - 1]) % INT_MAX; } } return dp[n][m]; }}; 119. 杨辉三角 II123456789101112131415class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; dp(rowIndex + 1); dp[0] = 1; for (int i = 1; i &lt;= rowIndex; i ++) for (int j = i; j &gt;= 0; j --) { if (j - 1 &gt;= 0) dp[j] += dp[j - 1]; if (dp[j] == 0) dp[j] = 1; } vector&lt;int&gt; res; for (int i = 0; i &lt; rowIndex + 1; i ++) res.push_back(dp[i]); return res; }}; 213. 打家劫舍 II1234567891011121314151617181920212223class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 1) return nums[0]; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0)); // 不选第1间, 0不选，1选 for (int i = 1; i &lt; n; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res1 = max(dp[n - 1][0], dp[n - 1][1]); dp[0][1] = nums[0], dp[0][0] = 0; for (int i = 1; i &lt; n - 1; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res2 = max(dp[n - 2][0], dp[n - 2][1]); return max(res1, res2); }}; 403. 青蛙过河1234567891011121314151617181920class Solution {public: bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); if (stones[1] != 1) return false; // dp[i][j]表示跳到位置i步长为j是否可以 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); dp[1][1] = true; for (int i = 2; i &lt; n; i ++) for (int j = 1; j &lt; i; j ++) { int k = stones[i] - stones[j]; // 步长 if(k &lt;= j + 1) { dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; } } for (int i = 1; i &lt; n; i ++) if (dp[n - 1][i]) return true; return false; }}; 576. 出界的路径数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: const int MOD = (int) 1e9 + 7; int n, m, maxn; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int findPaths(int _m, int _n, int _maxMove, int r, int c) { n = _m, m = _n, maxn = _maxMove; vector&lt;vector&lt;int&gt;&gt; dp(n * m, vector&lt;int&gt;(maxn + 1, 0)); // 初始化边缘 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j ++) { if (i == 0) add(i, j, dp); if (j == 0) add(i, j, dp); if (i == n - 1) add(i, j, dp); if (j == m - 1) add(i, j, dp); } // f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1] for (int k = 1; k &lt;= maxn; k ++) { for (int idx = 0; idx &lt; m * n; idx ++) { vector&lt;int&gt; info(2, 0); info = parseIdx(idx); int x = info[0], y = info[1]; for (int i = 0; i &lt; 4; i ++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; int nidx = getIdx(nx, ny); dp[idx][k] += dp[nidx][k - 1]; dp[idx][k] %= MOD; } } } return dp[getIdx(r, c)][maxn]; } void add(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;dp) { for (int k = 1; k &lt;= maxn; k ++) { dp[getIdx(x, y)][k] ++; } } int getIdx(int x, int y) { return x * m + y; } vector&lt;int&gt; parseIdx(int idx) { return vector&lt;int&gt;{idx / m, idx % m}; }}; 639. 解码方法 II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution {public: const int MOD = (int) 1e9 + 7; // i 表示当前遍历字符下标，j表示前一个字符下标 // f[i] 表示 以 s[i] 结尾的字符串，共有多少种解码方法 /* s[i] == '*'： s[i]可以单独组成一个，f[i] += f[i - 1] * 9 可以和前面的字符组成： 若s[j] == 1，那么 f[i] += f[i - 2] * 9 (11 - 19) 若s[j] == 2，那么 f[i] += f[i - 2] * 6 (21 - 26) 若s[j] == *，那么 f[i] += f[i - 2] * 15 s[i] != '*'，s[i]为数字时： s[j] 为 '*'： s[i] == 0，f[i] += f[i - 2] * 2; （10，20） s[i] != 0： f[i] = f[i - 1] (1 - 9) 1 &lt;= s[i] &lt;= 6 f[i] += f[i - 2] * 2 （11 - 16，21 - 26） 7 &lt;= s[i] &lt;= 9 f[i] += f[i - 2] * 1 （17 - 19） s[j] != '*'： s[i] == 0，f[i] = f[i - 2] (10, 20) s[i] != 0： f[i] = f[i - 1] (1 - 9) s[j] == 1，f[i] = f[i - 2]; (11 - 19) s[j] == 2 且 1 &lt;= s[i] &lt;= 6 ，f[i] = f[i - 2]; (21 - 26) */ int numDecodings(string s) { int n = s.size(); vector&lt;long&gt; f(n, 0); // 注意这里要long f[0] = s[0] == '*' ? 9 : (s[0] != '0' ? 1 : 0); for (int i = 1; i &lt; n; i ++) { char c = s[i], prev = s[i - 1]; if (c == '*') { f[i] += f[i - 1] * 9; if (prev == '*') f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 15; else { int u = prev - '0'; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 9; else if (u == 2) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 6; } } else { int t = c - '0'; if (prev == '*') { if (t == 0) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; else { f[i] += f[i - 1]; if (t &gt;= 1 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; if (t &gt;= 7 &amp;&amp; t &lt;= 9) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { int u = prev - '0'; if (t == 0) { if (u == 1 || u == 2) { f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { f[i] = f[i - 1]; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); if (u == 2 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } } f[i] %= MOD; } return (int) f[n - 1]; }}; 650. 只有两个键的键盘1234567891011121314151617181920// f[i][j]表示经过最后一次操作，记事本上有i个字符，粘贴板上有j个字符的最小操作次数class Solution {public: const int MAX_INT = 0x3f3f3f3f; int minSteps(int n) { vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, MAX_INT)); dp[1][0] = 0, dp[1][1] = 1; for (int i = 2; i &lt;= n; i ++) { int minN = MAX_INT; for (int j = 0; j &lt;= i / 2; j ++) { dp[i][j] = dp[i - j][j] + 1; // paste minN = min(minN, dp[i][j]); } dp[i][i] = minN + 1; // copy all } int res = MAX_INT; for (int i = 0; i &lt;= n; i ++) res = min(res, dp[n][i]); return res; }}; 678. 有效的括号字符串1234567891011121314151617181920212223class Solution {public: bool checkValidString(string s) { int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(n + 1, 0)); dp[0][0] = true; for (int i = 1; i &lt;= n; i ++) { char c = s[i - 1]; for (int j = 0; j &lt;= i; j ++) { if (c == '(') { if (j - 1 &gt;= 0) dp[i][j] = dp[i - 1][j - 1]; } else if (c == ')') { if (j + 1 &lt;= i) dp[i][j] = dp[i - 1][j + 1]; } else { dp[i][j] = dp[i - 1][j]; if (j - 1 &gt;= 0) dp[i][j] = dp[i][j] | dp[i - 1][j - 1]; if (j + 1 &lt;= i) dp[i][j] = dp[i][j] | dp[i - 1][j + 1]; } } } return dp[n][0]; }}; 1220. 统计元音字母序列的数目12345678910111213141516171819202122232425262728293031class Solution {public: const int MOD = 1e9 + 7; // dp[i][j] 表示 长度为i的字符串，结尾为j的字符串 的 个数 int countVowelPermutation(int n) { vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt;(5, 0)); for (int i = 0; i &lt; 5; i ++) dp[0][i] = 1; for (int i = 1; i &lt; n; i ++) { // 每个元音 'a' 后面都只能跟着 'e' dp[i][1] += dp[i - 1][0]; // 每个元音 'e' 后面只能跟着 'a' 或者是 'i' dp[i][0] += dp[i - 1][1]; dp[i][2] += dp[i - 1][1]; // 每个元音 'i' 后面 不能 再跟着另一个 'i' dp[i][0] += dp[i - 1][2]; dp[i][1] += dp[i - 1][2]; dp[i][3] += dp[i - 1][2]; dp[i][4] += dp[i - 1][2]; // 每个元音 'o' 后面只能跟着 'i' 或者是 'u' dp[i][2] += dp[i - 1][3]; dp[i][4] += dp[i - 1][3]; // 每个元音 'u' 后面只能跟着 'a' dp[i][0] += dp[i - 1][4]; for (int j = 0; j &lt; 5; j ++) dp[i][j] %= MOD; } long res = 0; for (int i = 0; i &lt; 5; i ++) res += dp[n - 1][i]; return (int) (res % MOD); }}; 1751. 最多可以参加的会议数目 II1234567891011121314151617181920212223242526272829303132333435class Solution {public: static bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) { // 升序排序 return a[1] &lt;= b[1]; } int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; events, int k) { int n = events.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k + 1, 0)); sort(events.begin(), events.end(), cmp); for (int i = 0; i &lt; n; i ++) printf(&quot;[%d %d %d]&quot;, events[i][0], events[i][1], events[i][2]); for (int i = 1; i &lt;= n; i ++) { auto p = events[i - 1]; int s = p[0], e = p[1], v = p[2]; int last = 0; for (int t = i - 1; t &gt;= 1; t --) { auto l = events[t - 1]; if (s &gt; l[1]) { last = t; // 更新为不冲突的事件下标 break; } } for (int j = 1; j &lt;= k; j ++) { dp[i][j] = max(dp[i - 1][j], dp[last][j - 1] + v); // 选与不选 } } return dp[n][k]; }}; 1787. 使所有区间的异或结果为零12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: /* 易知，将nums排列为一个二维数组（每行为k个），问题将转化为： 使得每列相等，且最终首行异或值为0的更改元素数 定义 f[i][xor]为考虑前i列，且首行前i列异或值的xor的更改元素数 由于需要知道i - 1列的最小更改元素数，使之转态转移，所以需要一个状态数组prev 另外，使用 map记录每一列数字对应的个数 cnt记录每一列数字总数 所以，分析状态转移方程 当在第0列时： f[0][xor] = f[0][xor] + cnt - map[xor] 当在其他列时，需要考虑从前一列转移的状态： 另外，还有 考虑整列修改： f[i][xor] = f[i - 1][xor] + cnt; 考虑部分修改： f[i][xor] = f[i - 1][xor ^ cur] + cnt - map[cur]; */ const int maxVal = INT_MAX / 2; const int maxHalf = 1 &lt;&lt; 10; int minChanges(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(maxHalf, maxVal)); vector&lt;int&gt; prev(k, maxVal); for (int i = 0; i &lt; k; i ++) { // 遍历每一列 int cnt = 0; unordered_map&lt;int, int&gt; map; for (int j = i; j &lt; n; j += k) { map[nums[j]] ++; cnt ++; } if (i == 0) { // 第0列 for (int x = 0; x &lt; maxHalf; x ++) { dp[0][x] = min(dp[0][x], cnt - map[x]); prev[0] = min(prev[0], dp[0][x]); } } else { // 其他列 for (int x = 0; x &lt; maxHalf; x ++) { dp[i][x] = prev[i - 1] + cnt; for (auto &amp;it: map) { dp[i][x] = min(dp[i][x], dp[i - 1][x ^ it.first] + cnt - it.second); } prev[i] = min(prev[i], dp[i][x]); } } } return dp[k - 1][0]; }}; 剑指 Offer 42. 连续子数组的最大和1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; int ans = dp[0]; for (int i = 1; i &lt; n; i ++) { dp[i] = max(nums[i], dp[i - 1] + nums[i]); ans = max(ans, dp[i]); } return ans; }}; LCP 07. 传递信息12345678910111213class Solution {public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) { vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(15, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= k; i ++) for(auto &amp;r: relation) { int a = r[0], b = r[1]; dp[i][b] += dp[i - 1][a]; } return dp[k][n - 1]; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7DP/"},{"title":"第71周双周赛","text":"5984. 拆分数位后四位数字的最小和123456789101112131415161718192021222324class Solution {public: int minimumSum(int num) { vector&lt;int&gt; vec; int t = num; while (t) { vec.push_back(t % 10); t /= 10; } sort(vec.begin(), vec.end()); int zero = count(vec.begin(), vec.end(), 0); if (zero == 3) { return vec[3]; } else if (zero == 2) { return vec[2] + vec[3]; } else if (zero == 1) { if (vec[2] &gt; vec[3]) return vec[1] * 10 + vec[3] + vec[2]; return vec[1] * 10 + vec[2] + vec[3]; } else { return vec[0] * 10 + vec[2] + vec[1] * 10 + vec[3]; } return 0; }}; 5985. 根据给定数字划分数组1234567891011121314151617class Solution {public: vector&lt;int&gt; pivotArray(vector&lt;int&gt;&amp; nums, int pivot) { vector&lt;int&gt; vec1; for (auto num: nums) if (num &lt; pivot) vec1.push_back(num); vector&lt;int&gt; vec2; for (auto num: nums) if (num &gt; pivot) vec2.push_back(num); int tot = count(nums.begin(), nums.end(), pivot); vector&lt;int&gt; res; for (auto i: vec1) res.push_back(i); for (int i = 0; i &lt; tot; i ++) res.push_back(pivot); for (auto i: vec2) res.push_back(i); return res; }}; 5986. 设置时间的最少代价123456789101112131415161718192021222324252627282930313233class Solution {public: /* 分类讨论 因为秒数的范围[0,99], 分两种场景讨论: a. mins = target / 60, secs = target % 60; b. mins = target / 60 - 1, secs = target % 60 + 60; 将mins*100+secs转为字符串进行处理, 求出花费的时间即可; */ int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) { int mins = targetSeconds / 60, secs = targetSeconds % 60; int ans1 = calTime(startAt, moveCost, pushCost, mins, secs); int ans2 = calTime(startAt, moveCost, pushCost, mins - 1, secs + 60); return min(ans1, ans2); } int calTime(int startAt, int moveCost, int pushCost, int mins, int secs) { if (mins &lt; 0 || mins &gt; 99 || secs &gt; 99) { return INT_MAX; } string s = to_string(mins * 100 + secs); int ans = 0; for (int i = 0; i &lt; s.size(); i ++) { if (s[i] - '0' == startAt) { ans += pushCost; } else { ans += pushCost + moveCost; } startAt = s[i] - '0'; } return ans; }}; 5987. 删除元素后和的最小差值1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: /* 枚举i为分界点，维护0-i内长度为n / 3 的最小值，i + 1 - n - 1内长度为n / 3的最大值 */ long long minimumDifference(vector&lt;int&gt;&amp; nums) { int n = nums.size(), k = n / 3; vector&lt;long long&gt; s1(n, 0); priority_queue&lt;int&gt; small; // 大根堆，维护0 - i内的最小值 for (int i = 0; i &lt; 2 * k; i ++) { s1[i] = (i &gt; 0) ? s1[i - 1] : 0; small.push(nums[i]); s1[i] += nums[i]; if (small.size() &gt; k) { s1[i] -= small.top(); small.pop(); } } vector&lt;long long&gt; s2(n, 0); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; big; // 小根堆，维护 i + 1 - n - 1内的最大值 for (int i = n - 2; i &gt;= k - 1; i --) { // 注意这里是n - 2的原因是，下面计算答案是从 k - 1 ~ 2 *k - 1，如果为n-1，会多算一个数进来 // 例如 1 2 3 4 5 6 ，n-2会使得下标为1的位置s[1] 表示 后4个数中最大值，n-1则表示5个数了 s2[i] = s2[i + 1]; big.push(nums[i + 1]); s2[i] += nums[i + 1]; if (big.size() &gt; k) { s2[i] -= big.top(); big.pop(); } } long long res = 1e15; for (int i = k - 1; i &lt; 2 * k; i ++) { res = min(res, s1[i] - s2[i]); } return res; }};","link":"/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC71%E5%91%A8%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第279场周赛","text":"6000. 对奇偶下标分别排序123456789101112131415161718class Solution {public: vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; vec1, vec2; for (int i = 0; i &lt; nums.size(); i ++) { if (i % 2 == 0) vec1.push_back(nums[i]); // 偶数 else vec2.push_back(nums[i]); // 奇数 } sort(vec1.begin(), vec1.end()); sort(vec2.begin(), vec2.end(), greater&lt;int&gt;()); vector&lt;int&gt; res; for (int i = 0, j = 0, k = 0; i &lt; nums.size(); i ++) { if (i % 2 == 0) res.push_back(vec1[j ++]); else res.push_back(vec2[k ++]); } return res; }}; 6001. 重排数字的最小值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;int&gt; getNum(long long num) { vector&lt;int&gt; a; while(num) { a.push_back(num % 10); num /= 10; } return a; } long long smallestNumber(long long num) { long long res = 0; if (num &gt; 0) { auto a = getNum(num); sort(a.begin(), a.end()); int i = 0, n =a.size(), k = 0; bool flag = true; vector&lt;int&gt; vec; for (int i = 0; i &lt; n; i ++) { if (a[i] != 0 &amp;&amp; flag){ k = i, flag = !flag; continue; } vec.push_back(a[i]); } res += a[k] * pow(10, n - 1); int cnt = vec.size() - 1; for (int i = 0; i &lt; vec.size(); i ++) { res += vec[i] * pow(10, cnt); cnt --; } } else { long long n1 = -num; auto a = getNum(n1); sort(a.begin(), a.end(), greater&lt;int&gt;()); int cnt = a.size() - 1; for (int i = 0; i &lt; a.size(); i ++) { res += a[i] * pow(10, cnt); cnt --; } res = -res; } return res; }}; 6002. 设计位集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Bitset {public: string bst, fbst; int cnt; bool flipped; // 判断是否翻转 Bitset(int size) { bst = string(size, '0'); fbst = string(size, '1'); cnt = 0; flipped = false; } void fix(int idx) { if (!flipped) { if (bst[idx] == '0') cnt ++; bst[idx] = '1'; fbst[idx] = '0'; } else { if (bst[idx] == '1') cnt ++; // 如果翻转了，则是fbit，那么翻转前是1，翻转后是0，fix设置fbit，则加1 bst[idx] = '0'; fbst[idx] = '1'; } } void unfix(int idx) { if (!flipped) { if (bst[idx] == '1') cnt --; bst[idx] = '0'; fbst[idx] = '1'; } else { if (bst[idx] == '0') cnt --; bst[idx] = '1'; fbst[idx] = '0'; } } void flip() { flipped = !flipped; cnt = bst.size() - cnt; } bool all() { return cnt == bst.size(); } bool one() { return cnt &gt; 0; } int count() { return cnt; } string toString() { if (!flipped) return bst; else return fbst; }};/** * Your Bitset object will be instantiated and called as such: * Bitset* obj = new Bitset(size); * obj-&gt;fix(idx); * obj-&gt;unfix(idx); * obj-&gt;flip(); * bool param_4 = obj-&gt;all(); * bool param_5 = obj-&gt;one(); * int param_6 = obj-&gt;count(); * string param_7 = obj-&gt;toString(); */ 6003. 移除所有载有违禁货物车厢所需的最少时间前后缀分解 + DP - 移除所有载有违禁货物车厢所需的最少时间 1234567891011121314151617181920212223242526class Solution {public: /* 考虑左半部分的最少时间。 当s[i] == '0' pre[i] = pre[i - 1] 当s[i] == '1' pre[i] = min(pre[i - 1] + 2, i + 1) 考虑右半部分的最少时间 s[i] == '0' , suf[i] = suf[i + 1] s[i] == '1' , suf[i] = min(suf[i + 1] + 2, n - i) */ int minimumTime(string s) { int n = s.length(); vector&lt;int&gt; suf(n + 1, 0); // 移除后i个载有违禁货物车所需的最少单位时间数 for (int i = n - 1; i &gt;= 0; i --) { suf[i] = s[i] == '0' ? suf[i + 1] : min(suf[i + 1] + 2, n - i); } // 枚举分割点 int pre = 0, ans = suf[0]; // pre使用滚动数组优化 for (int i = 0; i &lt; n; i ++) { if (s[i] == '1') pre = min(pre + 2, i + 1); ans = min(ans, pre + suf[i]); } return ans; }};","link":"/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC279%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"Java类的加载机制","text":"1 概述​ 首先，先看如下的Java代码执行流程图 ​ 类的加载是指图中：字节码进入Java虚拟机后的一系列过程。具体是：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 ​ 简单来说，类的加载过程（从加载到虚拟机内存到卸出）：包括了加载，验证，准备，解析，初始化，使用，卸载。 ​ 其他的过程顺序都是确定的，除了解析，它在某些情况下可以在初始化阶段后开始。注意：这里的顺序指的是按顺序开始，但之后执行与完成可能不是顺序的，这些阶段通常是交叉执行的。 2 类的加载过程2.1 加载​ 在这一阶段，虚拟机通常需要完成三件事情： 1）通过类的全限定名（包名+类名），获取到该类的.class文件的二进制字节流 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口 简单来说，就如下图 ​ 下面对再稍微细说下这三阶段 加载二进制数据到内存 ​ 这一阶段并没有说明从哪里获取以及怎么获取，这是交给开发人员自定义的，一般的读取方式有以下 从ZIP包中获取，或者JAR包（很常见现在），WAR包等 从网络获取，例如Applet 运行时计算生成，使用动态代理技术 …… 映射jvm能够识别的结构 ​ 将映射后可以被虚拟机识别的格式存储在方法区中，这种数据存储格式是由虚拟机自行定义 在内存中生成class文件 ​ 在Java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口 2.2 验证​ 该阶段是连接阶段的第一步，这是要确保前面加载进来的字节流包含的数据符合要求，不会危害到虚拟机的安全 ​ 一般有以下四个阶段的检验过程 文件格式检验 ​ 字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。例如魔数开头是否正确，版本号是否在范围内，常量池是否有不支持的常量等 元数据验证 ​ 对描述信息进行语义分析，确保描述的信息符合Java语言规范的要求。例如该类是否有父类，是否继承了不允许被继承的类，如果不是抽象类，是否实现了该父类或接口要求实现的所有方法。 字节码验证 ​ 进行数据流和控制流分析（对类的方法体进行校验分析）。例如保证操作数栈的数据类型和指令代码序列能够配合工作，跳转指令不会跳转到方法体以外的字节码指令上，保证方法体类型转化有效。 符号引用验证 ​ 这会发生在虚拟机符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段发生。 ​ 这里符号引用是指任何形式的字面量，这与内存布局无关，引用的目标不一定加载到内存中，例如，引用了org.simple.people，那么则使用org.simple.people来表示该类的地址。而直接引用是则可以是指向目标的指针，相对偏移量，句柄等，该引用的目标必定存在于虚拟机内存中 ​ 通常这里要检查以下内容 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段 …. 2.3 准备​ 这一阶段将会为类变量分配内存并设置类变量初始值，这些内存都会在方法区中分配（JDK1.6）。注意，这里的类变量是指被static修饰的变量，实例变量将会在对象实例化随着对象分配到Java堆中。并且，初始值是指数据类型的零值 1public static int value = 123; ​ 这里，准备阶段后，初始值为0，不是123，将value赋值为123的操作在初始化阶段才会执行 ​ 但会存在特殊情况，如果某个变量是不可变的，例如上述变量定义为： 1public static final int value = 123; ​ 这样，准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123 2.4 解析​ 这一阶段将会将常量池内的符号引用替换为直接引用。符号引用的解析可以出现多次，虚拟机实现可能会对第一次解析的结果进行缓存，以便后续使用。 ​ 解析动作主要针对以下四类进行 类或接口的解析 字段解析 类方法解析 接口方法解析 ​ 由于这些篇幅过长，就不细说，具体查看《深入理解Java虚拟机》 2.5 初始化​ 这一阶段是通过程序制定的主观计划去初始化类变量和其他资源，从另一方面说，是执行类构造器&lt;clinit&gt;()方法的过程。这一方法运行的行为和细节如下： &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值操作和static{}块合并产生。 &lt;clinit&gt;()方法与类的构造函数不同，不需要显式调用父类构造器，父类的&lt;clinit&gt;()方法已经执行完毕 通过以上两点可知，父类定义的静态语句块要优于子类的变量赋值操作 &lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步 3 类加载器​ 通过对前面类加载过程的阐述，可以发现除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。类加载器提高了JVM的可扩展性，是Java语言流行一大原因。 3.1 双亲委派模型​ 绝大部分Java程序都会使用到以下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader） ​ 应用程序都是由这三类类加载器互相配合进行加载的，如果有必要，可以加入自定义的类加载器 ​ 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 ​ 双亲委派模型的工作流程： 一个类加载器收到类加载的请求，不会首先自己尝试加载该类 将该请求委派给父类加载器去完成，对于每个层次的类加载器都是如此 所有的加载请求最终都应该传送到顶层的启动类加载器中 只有当父加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载 ​ 使用该模型的好处有如下： Java类和它的类加载器一起具备一种带有优先级的层次关系 ​ 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。如果您有 上面的好处也从一定程度上防止了危险代码的植入 参考《深入理解Java虚拟机-第3版》 jvm类加载器，类加载机制详解，看这一篇就够了 - SegmentFault 思否 Java类加载机制（全套） - 掘金 (juejin.cn) Java虚拟机 - 符号引用和直接引用理解 - qlky - 博客园 (cnblogs.com) (99条消息) 符号引用和直接引用有什么区别_绅士jiejie的博客-CSDN博客_符号引用和直接引用的区别","link":"/2022/02/07/Java/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"Spring源码阅读（一）","text":"1 前言​ 阅读源码可以帮助提高debug能力以及更加熟悉该框架的原理与构建方式，学习大师的思维。本系列文章将会通过阅读Spring源码，尽力分析各个函数，类，接口等的实现方式与原理，来让自己更加深刻理解这一框架。 ​ 首先，我们要知道，Spring是一个生态体系，其中包含了Spring Framework, Spring Boot, Spring Cloud等，一般说的Spring源码是指Spring Framework中的。 ​ 而在Spring Framework中，又会有许多模块所组成 一共有以下20多个不同的模块 12345spring-aop spring-context-indexer spring-instrument spring-orm spring-webspring-aspects spring-context-support spring-jcl spring-oxm spring-webfluxspring-beans spring-core spring-jdbc spring-r2dbc spring-webmvcspring-context spring-expression spring-jms spring-test spring-websocketspring-messaging spring-tx ​ 而我们知道，Spring最核心的功能就是IOC和AOP，也是本次源码分析的重点 ​ 在图中，也就是Core Container中的模块和AOP、Aspects。接下来，说说大致作用： Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。 Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。 Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。 AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 大致了解了以后，将进入源码分析了 2 环境搭建新建一个maven项目以后，导入以下pom文件 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring_core&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; applicationContext.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;com.w1nd.spring.dao.Person&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;Bruis&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Person.java 123456789package com.w1nd.spring.dao;import lombok.Data;@Datapublic class Person { private Integer age; private String name;} 3 IoC过程​ IoC（控制反转）简单来说就是将创建Bean和注入Bean的权利赋予给了Spring容器，不用程序员自己去管理，在bean生成或初始化的时候，Spring容器就会将数据注入到bean中，又或者通过将对象的引用注入到对象数据域中的方式来注入对方法调用的依赖。 ​ 在Spring容器的设计中，有两个主要的容器机制： 实现BeanFactory接口的简单容器系列 ​ 实现了容器最基本的功能 ApplicationContext应用上下文 ​ 除了拥有BeanFactory的所有功能外，还支持特殊类型bean如上一节中的BeanFactoryPostProcessor和BeanPostProcessor的自动识别、资源加载、容器事件和监听器、国际化支持、单例bean自动初始化等。 对于这两个容器，DefaultListableBeanFactory是是Spring注册及加载bean的默认实现，我们可以直接使用该类来加载 123456789101112131415161718package com.w1nd.spring;import com.w1nd.spring.dao.Person;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); reader.loadBeanDefinitions(&quot;applicationContext.xml&quot;); Person person1 = (Person) beanFactory.getBean(&quot;person&quot;); System.out.println(person1); }} 但在下面演示中，为了更好的了解spring一系列衍生方案，使用ClassPathXmlApplicationContext来加载xml文件，演示程序如下 1234567891011121314package com.w1nd.spring;import com.w1nd.spring.dao.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain { public static void main(String[] args) { //使用spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person person = (Person)context.getBean(&quot;person&quot;); System.out.println(person); }} ​ 另外，我们来看DefaultListableBeanFactory和ClassPathXmlApplicationContext两个类的继承链图，这对于接下来的debug会更有帮助 ​ 建议将该图画下来，debug时对着用箭头标明，这样不会混乱 ​ 下面对上述演示程序debug 3.1 初始 加载ContextClosedEvent，以免后续出现问题 ClassPathXmlApplicationContext构造函数（ClassPathXmlApplicationContext.class） 12345678910111213141516171819202122public ClassPathXmlApplicationContext(String configLocation) throws BeansException { this(new String[] {configLocation}, true, null);}/* 使用给定的父类容器创建新的ClassPathXmlApplicationContext，然后从给定的XML文件加载定义， 加载所有bean定义并且创建所有的单例，在进一步配置上下文后调用refresh。换句话说xml文件的读取， bean的创建和实例化都是在refresh()方法中进行的，refresh()函数中包含了几乎所有的 ApplicationContext中提供的全部功能。*/public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); //设置配置路径 setConfigLocations(configLocations); if (refresh) { //refresh Spring容器 很重要，这个方法 refresh(); }} 设置配置路径（AbstractRefreshableConfigApplicationContext.class） 12345678910111213//给configLocations字符串数组设置值，支持多个配置文件已数组方式同时传入。public void setConfigLocations(@Nullable String... locations) { if (locations != null) { Assert.noNullElements(locations, &quot;Config locations must not be null&quot;); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) { this.configLocations[i] = resolvePath(locations[i]).trim(); } } else { this.configLocations = null; }} 3.2 refresh refresh函数（AbstractApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 简单来说，Spring容器的初始化是在refresh()方法来启动的，这个方法标志着IOC容器的正式启动。 具体来说，这里的启动包括了BeanDefinition和Resource的定位、载入和注册三个基本过程。*/@Overridepublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;); // 准备刷新容器（上下文环境） prepareRefresh(); // 通知子类刷新内部bean工厂，初始化BeanFactory并进行XML的解析读取 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 准备 bean 工厂以在此上下文中使用。 prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } }} ​ 鉴于该方法的重要性，下面对其函数名分目录分别讲解，每个函数会逐渐深入其子函数去分序号，部分不会讲的可能不太重要或仅知道该函数作用即可。往后，每个函数名后面会写明所在类，部分辅助函数和其他函数放在同个代码块说明，代码块的函数通常在同个类，如果不在，会在注释标明 3.3 prepareRefresh prepareRefresh（）（AbstractApplicationContext.class） 1234567891011121314151617181920212223242526272829303132333435363738/* 准备此上下文以进行刷新、设置其启动日期和活动标志以及执行任何属性源的初始化。*/protected void prepareRefresh() { // 切换到活动状态 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) { if (logger.isTraceEnabled()) { logger.trace(&quot;Refreshing &quot; + this); } else { logger.debug(&quot;Refreshing &quot; + getDisplayName()); } } // 初始化上下文环境中的任何占位符属性源。这里对于子类啥都不会干 initPropertySources(); // 验证所有标记为必需的属性都是可解析的： // 请参阅 ConfigurablePropertyResolvesetRequiredProperties getEnvironment().validateRequiredProperties(); // 存储预刷新 ApplicationListeners... if (this.earlyApplicationListeners == null) { this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); } else { // 将本地应用程序侦听器重置为预刷新状态。 this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); } // 允许收集早期应用程序事件，一旦多播器可用就发布... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();} 3.4 obtainFreshBeanFactory该方法的时序图 obtainFreshBeanFactory （AbstractApplicationContext.class） 1234567/* 告诉子类刷新内部 bean 工厂。会返回新的BeanFactory实例*/protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { refreshBeanFactory(); return getBeanFactory();} refreshBeanFactory（AbstractRefreshableApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 此实现执行此上下文的底层 bean 工厂的实际刷新，关闭先前的 bean 工厂（如果有）并为上下文生命周期的下一阶段初始化一个新的 bean 工厂。*/@Overrideprotected final void refreshBeanFactory() throws BeansException { // 如果有 Bean工厂，则关闭该工厂 if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // 创建一个新bean工厂，这里的DefaultListableBeanFactory就是前面的Spring核心类，这个类真的很重要！ DefaultListableBeanFactory beanFactory = createBeanFactory(); // 序列化指定ID，如果需要的话，让这个BeanFactory从ID反序列化掉BeanFactory对象 beanFactory.setSerializationId(getId()); // 自定义此上下文使用的内部 bean 工厂。为每次 refresh() 尝试调用。默认实现应用此上下文 // 的“allowBeanDefinitionOverriding”和“allowCircularReferences”设置（如果指定）。 // 可以在子类中重写以自定义任何DefaultListableBeanFactory 的设置。 customizeBeanFactory(beanFactory); // 加载bean定义信息，这一步实际上就从XML配置文件里的bean信息给读取到了Factory里了。 loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; } catch (IOException ex) { throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); }}/* 确定此上下文当前是否包含 bean 工厂，即至少已刷新一次且尚未关闭。*/ protected final boolean hasBeanFactory() { return (this.beanFactory != null);}/* 关闭BeanFactory实例*/@Overrideprotected final void closeBeanFactory() { DefaultListableBeanFactory beanFactory = this.beanFactory; if (beanFactory != null) { beanFactory.setSerializationId(null); this.beanFactory = null; }} ​ 上面图片，是loadBeanDefinitions（）方法运行完之后，eanFactory变量里面存放着一个ConcurrentHashMap变量，用于存放着person这个KV键值对，Key为person，Value为一个ArrayList的变量，里面存放着person的两个属性：age、name。下面接着深入该方法分析 loadBeanDefinitions（AbstractXmlApplicationContext.class） ​ BeanDefinition，顾名思义，用于定义bean信息的类，包含bean的class类型、构造参数、属性值等信息，每个bean对应一个BeanDefinition的实例。简化BeanDefinition仅包含bean的class类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 通过 XmlBeanDefinitionReader 加载 bean 定义。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 为给定的 BeanFactory 创建一个新的 XmlBeanDefinitionReader。 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 使用此上下文的资源加载环境配置 bean 定义阅读器。 beanDefinitionReader.setEnvironment(this.getEnvironment()); // 设置 ResourceLoader 以用于资源定位。 beanDefinitionReader.setResourceLoader(this); // 设置要用于解析的 SAX 实体解析器。默认情况下，将使用 ResourceEntityResolver。 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 允许子类提供阅读器的自定义初始化 initBeanDefinitionReader(beanDefinitionReader); // 实际加载 bean 定义。 loadBeanDefinitions(beanDefinitionReader);}/* AbstractApplicationContext.class 以可配置的形式返回此应用程序上下文的环境，允许进一步定制。 如果未指定，则将通过 createEnvironment() 初始化默认环境。*/@Overridepublic ConfigurableEnvironment getEnvironment() { if (this.environment == null) { this.environment = createEnvironment(); } return this.environment;}/* XmlBeanDefinitionReader.class*/public void setEntityResolver(@Nullable EntityResolver entityResolver) { this.entityResolver = entityResolver;}/* 初始化用于加载此上下文的 bean 定义的 bean 定义阅读器。默认实现为空。 可以在子类中被覆盖，例如用于关闭 XML 验证或使用不同的 XmlBeanDefinitionParser 实现。*/protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) { reader.setValidating(this.validating);} loadBeanDefinitions（AbstractXmlApplicationContext.class） ​ 注意这个和上个不一样，是重载 1234567891011121314/* 使用给定的 XmlBeanDefinitionReader 加载 bean 定义。 bean 工厂的生命周期由 refreshBeanFactory 方法处理；因此这个方法只是应该加载和或注册 bean 定义。*/protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); // &lt;-------是string路径会执行这个 }} loadBeanDefinitions（AbstractBeanDefinationReader.class） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, &quot;Location array must not be null&quot;); int count = 0; for (String location : locations) { count += loadBeanDefinitions(location); } return count;}/* 从指定的资源位置加载 bean 定义。位置也可以是位置模式， 前提是此 bean 定义读取器的 ResourceLoader 是 ResourcePatternResolver。*/public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException { ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) { throw new BeanDefinitionStoreException( &quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;); } if (resourceLoader instanceof ResourcePatternResolver) { // 资源模式匹配可用。 try { Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); // 从指定的 XML 文件加载 bean 定义。这里debug会进去XmlBeanDefinitionReader， int count = loadBeanDefinitions(resources); if (actualResources != null) { Collections.addAll(actualResources, resources); } if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;); } return count; } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); } } else { // 只能通过绝对 URL 加载单个资源。 Resource resource = resourceLoader.getResource(location); int count = loadBeanDefinitions(resource); if (actualResources != null) { actualResources.add(resource); } if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;); } return count; }} getResources（PathMatchingResourcePatternResolver.class） 12345678910111213141516171819202122232425262728@Overridepublic Resource[] getResources(String locationPattern) throws IOException { Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) { // 类路径资源（可能有多个同名资源） if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) { // 类路径资源模式 return findPathMatchingResources(locationPattern); } else { // 具有给定名称的所有类路径资源 return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); } } else { // 通常只在前缀后面查找一个模式，并且在Tomcat之后只有“* /”分隔符之后的“war：”协议。 int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(':') + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) { // 文件模式 return findPathMatchingResources(locationPattern); } else { // 具有给定名称的单个资源 return new Resource[] {getResourceLoader().getResource(locationPattern)}; } }} loadBeanDefinitions（XmlBeanDefinitionReader.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 从XML配置文件中获取bean定义信息*/public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); ... Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } ... try { InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //获取到读取xml配置文件的InputStream流后，进行BeanDefinitions的加载 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { ... } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }}/* 真正从xml配置文件中加载Bean定义信息*/protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { //获取xml的配置信息并封装为Document对象 Document doc = doLoadDocument(inputSource, resource); return this.registerBeanDefinitions(doc, resource); } catch (BeanDefinitionStoreException ex) { ... }} 以上的流程是在读取BeanDefinition信息，下面看如何将其注册 ​ registerBeanDefinitions（XmlBeanDefinitionReader.class） 123456789101112/* 注册包含在给定 DOM 文档中的 bean 定义*/public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 创建 BeanDefinitionDocumentReader 以用于从 XML 文档中实际读取 bean 定义 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 注册表中定义的 bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // 打开一个 DOM 文档；然后初始化在 &lt;beans&gt; 级别指定的默认设置；然后解析包含的 bean 定义。 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // &lt;----------- return getRegistry().getBeanDefinitionCount() - countBefore;} registerBeanDefinitions（DefaultBeanDefinitionDocumentReader.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* 注册并解析包含的 bean 定义。*/public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; doRegisterBeanDefinitions(doc.getDocumentElement());}/* 在给定的根 &lt;beans&gt; 元素中注册每个 bean 定义。*/protected void doRegisterBeanDefinitions(Element root) { BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 解析beanDefinitions信息，经过这个方法，beanFactory中就会保存从xml配置文件中解析而来的信息 parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;}/* 解析文档中根级别的元素：“import”、“alias”、“bean”*/protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析默认元素 parseDefaultElement(ele, delegate); } else { delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); }}/* 解析默认元素*/private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { // 读取到xml配置文件的&lt;bean&gt;节点 processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 递归 doRegisterBeanDefinitions(ele); }}/* 处理给定的 bean 元素，解析 bean 定义并将其注册到注册表。*/protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 解析提供的 &lt;bean&gt; 元素 if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); // 如果适用，通过命名空间处理程序装饰给定的 bean 定义。 try { // 注册最终的装饰实例。 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // 发送注册事件。 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} parseBeanDefinitionElement（BeanDefinitionParserDelegate.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);}/* 解析提供的 &lt;bean&gt; 元素。*/@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } //终于，这里要解析beanDefinition了 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null;}/* 解析 bean 定义本身，而不考虑名称或别名。如果在解析 bean 定义期间出现问题，则可能返回 null。*/@Nullablepublic AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // 创建BeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 通过构造器解析参数值 parseConstructorArgElements(ele, bd); // 通过property的value解析值吗，本文的程序xml就是通过property属性设置bean的值的，最终被这一方法所解析出来。 parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null;}// 解析给定 bean 元素的属性子元素。public void parsePropertyElements(Element beanEle, BeanDefinition bd) { NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { // 解析出参数值来，这里就真正的讲age的23，和name的bruis值解析出来并防止在一个组装的类里面存放着。 // 因为这里有两个bean，所以要循环调用两次parsePropertyElement()方法 parsePropertyElement((Element) node, bd); } }}// 解析属性元素public void parsePropertyElement(Element ele, BeanDefinition bd) { String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) { error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { if (bd.getPropertyValues().contains(propertyName)) { error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele); return; } Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); // 就是这一步，将K为age、name，值分别为23、bruis的KV对存放在了Spring容器里。 bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); }} 总结：该方法实际上实现了容器的初始化以及BeanDefinition的注册与加载，方便后续Bean的创建和加载 容器的初始化过程如下： 第一个过程是Resource定位过程。这个Resource定位过程指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一接口。这个定位过程类似于容器寻找数据的过程，就像使用水桶装水先要把水找到一样。 第二个过程是BeanDefinition的载入。这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。下面介绍这个数据结构的详细定义。具体来说，这个BeanDefinition实际上就是POJO对象在IOC容器的抽象，通过这个BeanDefinition定义的数据结构，使IOC能够方便地对POJO对象进行管理。 第三个过程是向IOC容器注册这些BeanDefinition的过程，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的。这个注册过程把载入过程中解析到的BeanDefinition向IOC容器进行注册。通过上面的分析，我们知道IOC内部将BeanDefinition注册到了ConcurrentHashMap中。 3.5 prepareBeanFactory prepareBeanFactory（AbstractApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 配置工厂的标准上下文特征，例如上下文的 ClassLoader 和后处理器*/protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 告诉内部 bean 工厂使用上下文的类加载器等。 beanFactory.setBeanClassLoader(getClassLoader()); if (!shouldIgnoreSpel) { beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); } beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 使用上下文回调配置 bean 工厂。 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class); // BeanFactory 接口未在普通工厂中注册为可解析类型。 // MessageSource 作为 bean 注册（并为自动装配找到）。 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 将用于检测内部 bean 的早期后处理器注册为 ApplicationListener。 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 检测 LoadTimeWeaver 并准备编织（如果找到）。 if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // 为类型匹配设置一个临时 ClassLoader。 beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册默认环境 bean。 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) { beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup()); }} 3.6 postProcessBeanFactory参考(99条消息) Spring和Spring Framework的理解_海TAO的博客-CSDN博客_springframework和spring JavaSourceCodeLearning/深入Spring源码系列（二）——深入Spring容器，通过源码阅读和时序图来彻底弄懂Spring容器（上）","link":"/2022/02/08/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"状态DP","slug":"状态DP","link":"/tags/%E7%8A%B6%E6%80%81DP/"},{"name":"背包DP","slug":"背包DP","link":"/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"序列DP","slug":"序列DP","link":"/tags/%E5%BA%8F%E5%88%97DP/"},{"name":"线性DP","slug":"线性DP","link":"/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"双周赛","slug":"双周赛","link":"/tags/%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"name":"周赛","slug":"周赛","link":"/tags/%E5%91%A8%E8%B5%9B/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring","slug":"框架/Spring","link":"/categories/%E6%A1%86%E6%9E%B6/Spring/"}]}