{"pages":[{"title":"","text":"About Me​ 一个菜狗","link":"/about/index.html"}],"posts":[{"title":"CMU15445：关系模型和关系代数","text":"1 数据库管理系统​ DBMS 是允许应用程序在数据库中存储和分析信息的软件。通用 DBMS 旨在允许定义、创建、查询、更新和管理数据库。 2 数据模型​ 数据模型（data model）是用于描述数据库中数据的概念的集合 ​ 模式（schema）是使用给定数据模型对特定数据集合的描述 ​ 数据模型通常有以下 （关系型）Relational （键值型）Key/Value （图表型）Graph （文档型）Document （列族）Column-family （数组或矩阵型）Array / Matrix （阶级式）Hierarchical （网络式）Network （多元式）Multi-Value 2.1 关系模型​ 结构性：数据库关系及其内容的定义 ​ 完整性：确保数据库的内容满足约束 ​ 可操作：关于如何访问和修改数据库内容的编程接口 ​ 关系是无序集合，包含表示实体的属性之间的关系。 ​ 元组是关系中的一组属性值（也称为域）。 值（通常）是原子/标量。 特殊值 NULL 是每个域的成员。 2.2 主键​ 关系的主键唯一标识单个元组。 ​ 如果表没有定义一个主键，一些 DBMS 会自动创建一个内部主键。自动生成唯一整数主键通常是有序且自动递增的。 2.3 外键​ 外键指定一个关系中的属性必须映射到另一个关系中的元组。 2.4 数据操作语言（DML）​ 从数据库中存储和检索信息的方法。一般有如下几种： ​ 检索和操作关系中的元组的基本操作。——基于集合代数 ​ 每个运算符将一个或多个关系作为其输入并输出一个新关系。 ——我们可以将运算符“链接”在一起以创建更复杂的运算 #### select ​ 从满足选择谓词的关系中选择元组的子集。 ​ 谓词充当过滤器，仅保留满足其限定要求的元组。可以使用连词/析取来组合多个谓词 projection 投射​ 使用仅包含指定属性的元组生成关系。 可以重新排列属性的顺序 可以操纵值 union​ 生成包含仅出现在一个或两个输入关系中的所有元组的关系。 Intersect 交集​ 生成一个只包含出现在两个输入关系中的元组的关系。 DIFFERENCE​ 生成一个只包含出现在第一个而不是第二个输入关系中的元组的关系 PRODUCT​ 从输入关系生成一个包含所有可能的元组组合的关系 JOIN​ 生成包含所有元组的关系，这些元组是两个元组（每个输入关系中的一个）与一个或多个属性的公共值的组合。 其他操作 ​ 这一部分让我想到了上数据库原理被写关系代数支配的日子= =","link":"/2022/03/22/CMU15445/CMU15445%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/"},{"title":"CMU15445：起航","text":"1 基本介绍​ CMU15445课程是关于数据库管理系统的设计和实现的。 注意DBS,DBMS,DB的区别：DB、DBS 和 DBMS 有什么区别 - 吴谦 - 博客园 (cnblogs.com) 主题包括 数据模型（关系、文档、键/值） 存储模型（n-ary、分解） 查询语言（SQL、存储过程） 存储架构（堆、日志结构） 索引设计（顺序保留树、哈希表） 事务处理（ACID、并发控制） 数据恢复（日志记录、检查点） 查询处理（连接、排序、聚合、优化） 并行架构（多核、分布式） ​ 我打算做2020版本，相对于2019，2020在索引设计上采用B+树，复杂度会更高，但我就是喜欢挑战困难的 ​ 官网地址：CMU 15-445/645 :: Intro to Database Systems (Fall 2020) 2 我为什么要做该课程​ 学习数据库的过程中，大多数接触的是MYSQL和Redis，看了很多书加文章，感觉对其已经有了清晰的认识，但是总感觉还停留在表层，例如运行一个sql，通常脑子只会浮现出结果，该走的索引。而没有过多去思考底层的实现，包括查询语句如何运行的，索引是怎么优化的，不同表之间是如何连接的等等。而作为一个大三学生，通过这个项目我想不仅可以让我对数据库本身有个更加深刻的认识，建立一个知识体系，也可以使其成为自己的一个项目经验写到简历上，而不是写一堆CRUD的项目QAQ。 ​ 预计该课程会使用差不多两个月的时间。","link":"/2022/03/22/CMU15445/CMU15445%EF%BC%9A%E8%B5%B7%E8%88%AA/"},{"title":"homework1：SQL","text":"1 Sqlite3基本介绍​ SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。 格式化输出 123sqlite&gt;.header onsqlite&gt;.mode columnsqlite&gt;.timer on 创建数据库 1sqlite3 DatabaseName.db 导出完整的数据库到一个文本文件 1sqlite3 testDB.db .dump &gt; testDB.sql 恢复 1sqlite3 testDB.db &lt; testDB.sql 附加数据库 1ATTACH DATABASE 'testDB.db' as 'TEST'; 显示附加数据库 12345sqlite&gt; .databaseseq name file--- --------------- ----------------------0 main /home/sqlite/testDB.db2 test /home/sqlite/testDB.db 数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。 我的理解是：附加在main上的数据库操作语句会作用在上面，附加数据库只是用于保存临时文件 分离数据库 123456789101112sqlite&gt;.databasesseq name file--- --------------- ----------------------0 main /home/sqlite/testDB.db2 test /home/sqlite/testDB.db3 currentDB /home/sqlite/testDB.dbsqlite&gt; DETACH DATABASE 'currentDB'; --- 分离语句sqlite&gt;.databasesseq name file--- --------------- ----------------------0 main /home/sqlite/testDB.db2 test /home/sqlite/testDB.db 2 环境配置2.1 下载sqlite3官网下载sqlite-autoconf-3071502 https://www.sqlite.org/download.html 12345$tar xvfz sqlite-autoconf-3071502.tar.gz$cd sqlite-autoconf-3071502$./configure --prefix=/usr/local$make$make install 2.2 下载作业数据库12345wget https://15445.courses.cs.cmu.edu/fall2020/files/musicbrainz-cmudb2020.db.gz$ md5sum musicbrainz-cmudb2020.db.gz # 检查是否正确安装a80fe4365a228d4096225068801771f8 musicbrainz-cmudb2020.db.gz$ gunzip musicbrainz-cmudb2020.db.gz # 解压$ sqlite3 musicbrainz-cmudb2020.db # 进入数据库 2.3 创建索引12345678910111213CREATE INDEX ix_artist_name ON artist (name);CREATE INDEX ix_artist_area ON artist (area);CREATE INDEX ix_artist_credit_name ON artist_credit_name (artist_credit);CREATE INDEX ix_artist_credit_id ON artist_credit (id);CREATE INDEX ix_artist_alias ON artist_alias(artist);CREATE INDEX ix_work_name ON work (name);CREATE INDEX ix_work_type ON work (type);CREATE INDEX ix_work_type_name ON work_type (name);CREATE INDEX ix_release_id ON release (id);CREATE INDEX ix_release_artist_credit ON release (artist_credit);CREATE INDEX ix_release_info_release ON release_info (release);CREATE INDEX ix_medium_release ON medium (release);CREATE INDEX ix_medium_format_id on medium_format (id); 3 作业3.1 Q1_SAMPLE​ 按类型升序排列所有类型的工作。 1select name from work_type order by name; 3.2 Q2_LONG_NAME​ 列出适用于每种类型的最长名称。 ​ 对于每种作品类型，查找名称最长的作品。在某些情况下，最长的名称可能会出现平局 - 在这种情况下，请返回所有名称。显示作品名称和对应的类型名称，并根据作品类型（升序）排序，并使用作品名称（升序）作为平局。 123456789101112SELECT work.name, work_type.name FROM work INNER JOIN ( -- 内连接中间表：每个类别中最长的最长长度 SELECT MAX( LENGTH( name ) ) AS maxLength, work.type AS type FROM work GROUP BY type ) AS newTable ON LENGTH( work.name ) = newTable.maxLength AND work.type = newTable.type INNER JOIN work_type ON work.type = work_type.id -- 内连接：按作品类型ORDER BY work.type ASC, work.name ASC; 3.3 Q3_OLD_MUSIC_NATIONS​ 列出拥有最多古典音乐艺术家（出生或开始于 1850 年之前）的前 10 个国家以及相关艺术家的数量。 ​ 打印 1850 年之前的国家和相关艺术家的数量。例如，俄罗斯|191。按艺术家人数降序排列。 1234567SELECT area.name, newTable.count AS count FROM area -- zINNER JOIN ( SELECT COUNT(1) AS count, area FROM artist WHERE begin_date_year &lt; 1850 GROUP BY area -- 找出每个地区的数量) AS newTable ON area.id = newTable.areaORDER BY count DESCLIMIT 10; 3.4 Q4_DUBBED_SMASH​ 列出数量排名前 10 的艺人名称 ​ 计算artist中每个艺术家在artist_alias中不同名称的数量，并仅列出来自英国并在 1950 年之后开始的前十名（不包括在内）。打印artist中的艺术家姓名和artist_alias中相应的不同艺术家姓名的数量。 1234567891011121314SELECT artist.name, COUNT( DISTINCT artist_alias.name ) AS count -- 可以一同使用 DISTINCT 和 COUNT 关键词，来计算非重复结果的数目。FROM artist INNER JOIN artist_alias ON artist.id = artist_alias.artist WHERE artist.begin_date_year &gt; 1950 AND area = 221 GROUP BY artist.id ORDER BY count DESC LIMIT 10 3.5 Q5_VINYL_LOVER​ 列出由英国乐队酷玩乐队以黑胶（vinyl）格式发行的不同版本的名称。 ​ 包括黑胶（vinyl）格式除 VinylDisc 之外的所有黑胶尺寸（vinyl dimensions）。按发布日期升序对发布名称进行排序。 123456789101112SELECT DISTINCT r1.name AS rnameFROM artist_credit_name a1 INNER JOIN artist_credit a2 ON a1.artist_credit = a2.id INNER JOIN &quot;release&quot; r1 ON a2.id = r1.artist_credit INNER JOIN release_info r2 ON r1.id = r2.&quot;release&quot; INNER JOIN medium m1 ON r1.id = m1.&quot;release&quot; INNER JOIN medium_format m2 ON m1.format = m2.idWHERE a1.name = 'Coldplay' AND m2.name like '%Vinyl'ORDER BY date_year, date_month, date_day; 3.6 Q6_OLD_IS_NOT_GOLD​ 哪个十年的官方发布数量最多？列出自 1900 年以来每十年的官方发布数量。如 1970s|57210。 ​ 打印所有十年和官方发布的数量。具有不同发行日期或国家/地区的发行版被视为不同发行版。通过构造如下所示的字符串，以更高级的格式打印相关的十年：1970s。根据官方发布的数量按降序排列十年，并使用十年（降序）作为决胜局。请记住排除日期为 NULL 的版本。 123456789101112Select decade, count(*) as cntfrom ( select (CAST((date_year / 10) as int) * 10) || 's' as decade -- 将每年转化为他所在的十年区间，这有点妙 from release inner join release_info on release.id = release_info.release where release.status = 1 and date_year &gt;= 1900 )Group by decadeOrder by cnt desc, decade desc; 3.7 Q7_RELEASE_PERCENTAGE​ 列出过去一年全球相应月份发布的所有版本的月份和百分比。显示如 2020.01|5.95。 ​ 一个月发布的百分比是当月发布的发布数量除以过去一年从 07/2019 到 07/2020 的发布总数，两者都包括在内。具有不同发行日期或国家/地区的发行版被视为不同发行版。使用 ROUND() 将百分比四舍五入到小数点后两位。按日期升序排序。 123456789101112131415161718192021222324252627282930313233with past_year_release (year, month) AS ( -- 过去一年发行所有的年/月 SELECT date_year, date_month FROM release_info r1 INNER JOIN &quot;release&quot; r2 ON r1.&quot;release&quot; = r2.id WHERE ( ( date_year = 2019 AND date_month &gt;= 7 ) OR ( date_year = 2020 AND date_month &lt;= 7 ) ))SELECT CAST(year AS varchar) || '.' || ( CASE WHEN month &lt; 10 THEN '0' -- 如果月份小于10，则要补个前缀0 ELSE '' END ) || CAST (month AS varchar) AS date, ROUND( COUNT(*) * 100.0 / ( -- 对每个月求对应的百分比 SELECT COUNT(*) FROM past_year_release ), 2 )FROM past_year_releaseGROUP BY dateORDER BY date; 3.8 Q8_COLLABORATE_ARTIST​ 列出与 Ariana Grande 合作过的艺术家数量。 ​ 仅打印艺术家总数。如果艺术家与 Ariana Grande 出现在同一个 Artist_credit 中，则该艺术家被视为合作者。答案应该包括 Ariana Grande 本人。 123456SELECT COUNT( DISTINCT artist ) FROM artist_credit_name WHERE artist_credit IN ( SELECT artist_credit FROM artist_credit_name WHERE name = 'Ariana Grande' ) 3.9 Q9_DRE_AND_EMINEM​ 列出 Dre 博士和 Eminem 以及其他最有成效的二人组（只要它们出现在同一个版本中）的排名、艺术家姓名以及合作发行的数量，它们都是在 1960 年之后开始的（不包括在内）。显示为 [rank]|Dr. Dre|Eminem|[发行数量]。 ​ 例如，如果您看到 A、B 和 C 的版本，它将促成三对二重奏：A|B|1、A|C|1 和 B|C|1。首先，您将按协同版本的数量计算这些DUOS的等级（与两个艺术家共享的Artist_Credit发布）进行排序，然后找到DRE和Eminem博士的等级。仅考虑英文版本。两位艺术家都应该是独奏艺术家。所有成对的名字都应该先有字母顺序较小的名字。使用艺术家姓名 (asc) 作为决胜局。 ​ 艺术家别名可以在任何地方使用。在进行聚合时，使用艺术家 ID 将确保您获得正确的结果。排名列表中的一个示例条目是 9|Benj Pasek|Justin Paul|27 ​ 3.10 Q10_AROUND_THE_WORLD​ 使用逗号分隔值连接披头士乐队的所有配音名称（如 “Beetles, fab four“）。 ​ 在artist_alias中找到艺术家“The Beatles”的所有配音名称，并按id（升序）排序。打印一个字符串，其中包含用逗号分隔的所有配音名称。 ​","link":"/2022/03/22/CMU15445/homework1%EF%BC%9ASQL/"},{"title":"使用JvisualVM排查OOM","text":"1 测试环境使用JDK1.8 12345678910111213141516171819202122package jvm.oom;import java.util.ArrayList;public class TestOOM { static class OOMObject { private String content; public OOMObject(String content) { this.content = content; } } public static void main(String[] args) { ArrayList&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); int a = 1; while (true) { list.add(new OOMObject(String.valueOf(a ++))); } }} 配置JVM参数： 1234-Xms2m // JVM启动时堆内存的初始化大小-Xmx4m // 设置堆内存最大值-XX:+HeapDumpOnOutOfMemoryError // 表示出现OOM异常后，生成堆快照hprof文件-XX:HeapDumpPath=d:\\jvmtest // 设置堆快照hprof文件存储的位置 2 运行1234567891011121314java.lang.OutOfMemoryError: Java heap spaceDumping heap to d:\\jvmtest ...Unable to create d:\\jvmtest: File existsException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at jvm.oom.TestOOM.main(TestOOM.java:18)Process finished with exit code 1 3 使用jvisualVM排查 使用CMD启动 ​ 装入生成的hprof文件 ​ 发现已经提示我们出现了OOM异常 ​ 发现是17行出现OOM ​ 查看ArrarList ​ 发现元素个数达到三万多，并且都是OOMObject对象 ​ 打开类视图，发现OOMObject对象确实占用了大量堆内存 通过以上分析，就可以大概知道是过多无法回收的OOMObject对象，导致了OOM 4 总结 生成堆转储快照dump文件（或者称hprof文件）； 利用相关工具分析堆转储快照 在线程快照（堆转储上的线程）中定位到发生OOM的线程和代码位置 综合分析线程快照里提示的本地变量信息及类视图中的实例占比，找出导致OOM的实体类型","link":"/2022/02/28/JVM/%E4%BD%BF%E7%94%A8JvisualVM%E6%8E%92%E6%9F%A5OOM/"},{"title":"CMU15545：高级SQL","text":"1 基本介绍​ 关系型语言通常是指用户只需要指定他们想要的答案，而不是如何计算它（例如排序，用户无需知道排序的具体细节，只需order by即可）。 ​ DBMS负责对查询进行有效评估。高端系统具有复杂的查询优化器，可以重写查询并搜索最佳执行策略。 ​ 关系型语言通常指如下： 数据操作语言（DML） 数据定义语言（DDL） 数据控制语言（DCL） 2 SQL高级特性样例表： 1 AGGREGATES（聚合）从元组包中返回单个值的函数： AVG(col)：返回平均 col 值 MIN(col)：返回最小 col 值 MAX(col)：返回最大 col 值 SUM(col)：返回 col 中值的总和 COUNT(col)：返回 col 的值的 # 个。 ​ 聚合函数（几乎）只能在 SELECT 输出列表中使用 2 Group By （分组）​ 将元组投影到子集中并针对每个子集计算聚合。 1234SELECT AVG(s.gpa), e.cidFROM enrolled AS e, student AS sWHERE e.sid = s.sidGROUP BY e.cid 注意：SELECT 输出子句中的非聚合值必须出现在 GROUP BY 子句中 例如下列就是错误的 3 Having​ 根据聚合计算过滤结果。类似于 GROUP BY 的 WHERE 子句 12345SELECT AVG(s.gpa) AS avg_gpa, e.cidFROM enrolled AS e, student AS sWHERE e.sid = s.sidGROUP BY e.cidHAVING AVG(s.gpa) &gt; 3.9; 4 有关string的操作​ LIKE 用于字符串匹配。字符串匹配运算符'%'匹配任何子字符串（包括空字符串）。'_' 匹配任意一个字符 12SELECT SUBSTRING(name,1,5) AS abbrv_nameFROM student WHERE sid = 53688 12SELECT * FROM student AS sWHERE UPPER(s.name) LIKE 'KAN%' 12SELECT name FROM studentWHERE login = CONCAT(LOWER(name), '@cs') 5 日期/时间操作​ 操作和修改 DATE/TIME 属性的操作。 6 输出控制order by limit 7 嵌套查询​ 包含其他查询的查询。它们通常难以优化。 12345SELECT name FROM studentWHERE sid IN (SELECT sid FROM enrolledWHERE cid = '15-445') ALL——必须满足子查询中所有行的表达式 ANY——必须满足子查询中至少一行的表达式。 IN——等价于’=ANY()’ EXISTS——至少返回一行 12345SELECT * FROM courseWHERE NOT EXISTS(SELECT * FROM enrolledWHERE course.cid = enrolled.cid)","link":"/2022/03/22/CMU15445/CMU15545%EF%BC%9A%E9%AB%98%E7%BA%A7SQL/"},{"title":"JDK8新特性","text":"1 Lambda表达式​ Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 以下是lambda表达式的重要特征: 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。 12345678910111213141516171819202122232425262728293031323334353637383940414243package jdk8;public class LambdaTest { public static void main(String[] args) { LambdaTest test = new LambdaTest(); // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; System.out.println(&quot;10 + 5 = &quot; + test.operate(10, 5, addition)); // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; System.out.println(&quot;10 - 5 = &quot; + test.operate(10, 5, subtraction)); // 加大括号 MathOperation multiplication = (int a, int b) -&gt; { return a * b; }; System.out.println(&quot;10 * 5 = &quot; + test.operate(10, 5, multiplication)); // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println(&quot;10 / 5 = &quot; + test.operate(10, 5, division)); // 不用括号 GreetingService greetingService = message -&gt; System.out.println(&quot;hello &quot; + message); // 用括号 GreetingService greetingService1 = (message) -&gt; System.out.println(&quot;hello &quot; + message); greetingService.sayMessage(&quot;world&quot;); greetingService1.sayMessage(&quot;world&quot;); } interface GreetingService { void sayMessage(String message); } interface MathOperation { int operation(int a, int b); } private int operate(int a, int b, MathOperation mathOperation) { return mathOperation.operation(a, b); }} 运行结果 2 方法引用​ 方法引用通过方法的名字来指向一个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243package jdk8;import java.util.Arrays;import java.util.List;import java.util.function.Supplier;public class MethodTest { public static void main(String[] args) { // 构造器引用 final Car car = Car.create( Car::new ); final List&lt;Car&gt; cars = Arrays.asList(car); // 静态方法引用 cars.forEach(Car::collide); // 特定类的任意对象的方法引用 cars.forEach(Car::repair); // 特定对象的方法引用 final Car police = Car.create(Car::new); cars.forEach(police::follow); }}class Car { public Car() { System.out.println(&quot;hello car&quot;); } public static Car create(final Supplier&lt;Car&gt; supplier) { return supplier.get(); } public static void collide(final Car car) { System.out.println(&quot;Collied &quot; + car.toString()); } public void follow(final Car another) { System.out.println(&quot;Following the &quot; + another.toString()); } public void repair() { System.out.println(&quot;Repaired &quot; + this.toString()); }} 运行结果 3 函数式接口​ 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 123456789101112131415161718192021222324252627282930313233343536373839package jdk8;import javax.xml.transform.Source;import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class FunctionInterfaceTest { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); // Predicate&lt;Integer&gt; predicate = n -&gt; true System.out.println(&quot;输出所有数据：&quot;); // 传递参数 eval(list, n-&gt;true); // Predicate&lt;Integer&gt; predicate1 = n -&gt; n % 2 == 0 // n 是一个参数传递到 Predicate 接口的test方法 // 如果 n 大于 3 test方法返回true System.out.println(&quot;输出所有偶数：&quot;); eval(list, n-&gt; n%2 == 0); // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3; // n 是一个参数传递到 Predicate 接口的test方法 // 如果 n 大于 3 test 方法返回true System.out.println(&quot;输出大于3的所有数字：&quot;); eval(list, n-&gt; n &gt; 3); } public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) { for (Integer n : list) { if (predicate.test(n)) { System.out.print(n + &quot; &quot;); } } System.out.println(&quot;&quot;); }} 运行结果 4 默认方法​ 默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。 1234567891011121314151617181920212223242526272829303132333435package jdk8;public class DefaultMethod { public static void main(String[] args) { Vehicle vehicle = new Car(); vehicle.print(); } interface Vehicle { default void print() { System.out.println(&quot;我是一辆车&quot;); } static void blowHorn() { System.out.println(&quot;按喇叭！！！&quot;); } } interface FourWheeler { default void print() { System.out.println(&quot;我是一辆四轮车！&quot;); } } static class Car implements Vehicle, FourWheeler { @Override public void print() { Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); System.out.println(&quot;我是一辆汽车！&quot;); } }} 运行结果 5 Stream​ Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 12345678910111213141516171819202122232425262728293031package jdk8;import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.stream.Collectors;public class StreamTest { public static void main(String[] args) { List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;); long count = strings.stream().filter(string -&gt; string.isEmpty()).count(); System.out.println(&quot;空字符串数量为：&quot; + count); count = strings.stream().filter(string -&gt; string.length() == 3).count(); System.out.println(&quot;字符串长度为3的数量为：&quot; + count); List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选后的列表：&quot; + filtered); String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;,&quot;)); System.out.println(&quot;合并字符串：&quot; + mergedString); List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList()); System.out.println(&quot;Squares List：&quot; + squaresList); List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19); IntSummaryStatistics statistics = integers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(statistics); }} 运行结果 6 Optional​ Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 ​ Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 ​ Optional 类的引入很好的解决空指针异常。 1234567891011121314151617181920212223242526272829package jdk8;import java.util.Optional;public class OptionalTest { public static void main(String[] args) { OptionalTest optionalTest = new OptionalTest(); Integer value1 = null; Integer value2 = new Integer(10); // Optional.ofNullable - 允许传递为 null 参数 Optional&lt;Integer&gt; a = Optional.ofNullable(value1); // Optional.of - 允许传递的参数是null，抛出异常NullPointerException Optional&lt;Integer&gt; b = Optional.of(value2); System.out.println(optionalTest.sum(a, b)); } public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) { // Optional.isPresent - 判断值是否存在 System.out.println(&quot;第一个参数值存在：&quot; + a.isPresent()); System.out.println(&quot;第二个参数值存在：&quot; + b.isPresent()); // Optional.orElse - 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); // Optional.get - 获取值，值需要存在 Integer value2 = b.get(); return value1 + value2; }} 运行结果 参考Java 8 新特性 | 菜鸟教程 (runoob.com)","link":"/2022/03/09/Java/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"Java类的加载机制","text":"1 概述​ 首先，先看如下的Java代码执行流程图 ​ 类的加载是指图中：字节码进入Java虚拟机后的一系列过程。具体是：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 ​ 简单来说，类的加载过程（从加载到虚拟机内存到卸出）：包括了加载，验证，准备，解析，初始化，使用，卸载。 ​ 其他的过程顺序都是确定的，除了解析，它在某些情况下可以在初始化阶段后开始。注意：这里的顺序指的是按顺序开始，但之后执行与完成可能不是顺序的，这些阶段通常是交叉执行的。 2 类的加载过程2.1 加载​ 在这一阶段，虚拟机通常需要完成三件事情： 1）通过类的全限定名（包名+类名），获取到该类的.class文件的二进制字节流 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口 简单来说，就如下图 ​ 下面对再稍微细说下这三阶段 加载二进制数据到内存 ​ 这一阶段并没有说明从哪里获取以及怎么获取，这是交给开发人员自定义的，一般的读取方式有以下 从ZIP包中获取，或者JAR包（很常见现在），WAR包等 从网络获取，例如Applet 运行时计算生成，使用动态代理技术 …… 映射jvm能够识别的结构 ​ 将映射后可以被虚拟机识别的格式存储在方法区中，这种数据存储格式是由虚拟机自行定义 在内存中生成class文件 ​ 在Java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口 2.2 验证​ 该阶段是连接阶段的第一步，这是要确保前面加载进来的字节流包含的数据符合要求，不会危害到虚拟机的安全 ​ 一般有以下四个阶段的检验过程 文件格式检验 ​ 字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。例如魔数开头是否正确，版本号是否在范围内，常量池是否有不支持的常量等 元数据验证 ​ 对描述信息进行语义分析，确保描述的信息符合Java语言规范的要求。例如该类是否有父类，是否继承了不允许被继承的类，如果不是抽象类，是否实现了该父类或接口要求实现的所有方法。 字节码验证 ​ 进行数据流和控制流分析（对类的方法体进行校验分析）。例如保证操作数栈的数据类型和指令代码序列能够配合工作，跳转指令不会跳转到方法体以外的字节码指令上，保证方法体类型转化有效。 符号引用验证 ​ 这会发生在虚拟机符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段发生。 ​ 这里符号引用是指任何形式的字面量，这与内存布局无关，引用的目标不一定加载到内存中，例如，引用了org.simple.people，那么则使用org.simple.people来表示该类的地址。而直接引用是则可以是指向目标的指针，相对偏移量，句柄等，该引用的目标必定存在于虚拟机内存中 ​ 通常这里要检查以下内容 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段 …. 2.3 准备​ 这一阶段将会为类变量分配内存并设置类变量初始值，这些内存都会在方法区中分配（JDK1.6）。注意，这里的类变量是指被static修饰的变量，实例变量将会在对象实例化随着对象分配到Java堆中。并且，初始值是指数据类型的零值 1public static int value = 123; ​ 这里，准备阶段后，初始值为0，不是123，将value赋值为123的操作在初始化阶段才会执行 ​ 但会存在特殊情况，如果某个变量是不可变的，例如上述变量定义为： 1public static final int value = 123; ​ 这样，准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123 2.4 解析​ 这一阶段将会将常量池内的符号引用替换为直接引用。符号引用的解析可以出现多次，虚拟机实现可能会对第一次解析的结果进行缓存，以便后续使用。 ​ 解析动作主要针对以下四类进行 类或接口的解析 字段解析 类方法解析 接口方法解析 ​ 由于这些篇幅过长，就不细说，具体查看《深入理解Java虚拟机》 2.5 初始化​ 这一阶段是通过程序制定的主观计划去初始化类变量和其他资源，从另一方面说，是执行类构造器&lt;clinit&gt;()方法的过程。这一方法运行的行为和细节如下： &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值操作和static{}块合并产生。 &lt;clinit&gt;()方法与类的构造函数不同，不需要显式调用父类构造器，父类的&lt;clinit&gt;()方法已经执行完毕 通过以上两点可知，父类定义的静态语句块要优于子类的变量赋值操作 &lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步 3 类加载器​ 通过对前面类加载过程的阐述，可以发现除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。类加载器提高了JVM的可扩展性，是Java语言流行一大原因。 3.1 双亲委派模型​ 绝大部分Java程序都会使用到以下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader） ​ 应用程序都是由这三类类加载器互相配合进行加载的，如果有必要，可以加入自定义的类加载器 ​ 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 ​ 双亲委派模型的工作流程： 一个类加载器收到类加载的请求，不会首先自己尝试加载该类 将该请求委派给父类加载器去完成，对于每个层次的类加载器都是如此 所有的加载请求最终都应该传送到顶层的启动类加载器中 只有当父加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载 ​ 使用该模型的好处有如下： Java类和它的类加载器一起具备一种带有优先级的层次关系 ​ 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。如果您有 上面的好处也从一定程度上防止了危险代码的植入 参考《深入理解Java虚拟机-第3版》 jvm类加载器，类加载机制详解，看这一篇就够了 - SegmentFault 思否 Java类加载机制（全套） - 掘金 (juejin.cn) Java虚拟机 - 符号引用和直接引用理解 - qlky - 博客园 (cnblogs.com) (99条消息) 符号引用和直接引用有什么区别_绅士jiejie的博客-CSDN博客_符号引用和直接引用的区别","link":"/2022/02/07/Java/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"I&#x2F;O多路复用详解","text":"1 前要知识1.1 文件I/O​ 文件I/O分类，常见的有 缓冲与⾮缓冲 I/O 直接与⾮直接 I/O 阻塞与⾮阻塞 I/O VS 同步与异步 I/O 缓冲与⾮缓冲 I/O ​ ⽂件操作的标准库是可以实现数据的缓存，那么根据「是否利⽤标准库缓冲」，可以把⽂件 I/O 分为缓冲I/O 和⾮缓冲 I/O： 缓冲 I/O，利⽤的是标准库的缓存实现⽂件的加速访问，⽽标准库再通过系统调⽤访问⽂件。 ⾮缓冲 I/O，直接通过系统调⽤访问⽂件，不经过标准库缓存。 直接与⾮直接 I/O ​ 根据是「否利⽤操作系统的缓存」，可以把⽂件 I/O 分为直接 I/O 与⾮直接 I/O： 直接 I/O，不会发⽣内核缓存和⽤户程序之间数据复制，⽽是直接经过⽂件系统访问磁盘。 ⾮直接 I/O，读操作时，数据从内核缓存中拷⻉给⽤户程序，写操作时，数据从⽤户程序拷⻉给内核缓存，再由内核决定什么时候写⼊数据到磁盘。 阻塞与⾮阻塞 I/O VS 同步与异步 I/O ​ 阻塞等待的是「内核数据准备好」和「数据从内核态拷⻉到⽤户态」这两个过程 ​ ​ ⾮阻塞 I/O，⾮阻塞的 read 请求在数据未准备好的情况下⽴即返回，可以继续往下执⾏，此时应⽤程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应⽤程序缓冲区， read 调⽤才可以得到结果 ​ ​ 同步I/O就是指「内核数据准备好」和「数据从内核态拷⻉到⽤户态」这两个过程都需要等待。 ​ 异步I/O 是「内核数据准备好」和「数据从内核态拷⻉到⽤户态」这两个过程都不⽤等待。 1.2 I/O模型​ 来看看Linux中提供的5种I/O处理模型 阻塞IO ​ 阻塞IO意味着当我们发起一次IO操作后应用程序一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，例如read和write。 非阻塞IO ​ 非阻塞IO是指每次应用程序询问内核是否有数据准备好。如果就绪，就进行拷贝操作；如果未就绪，就不阻塞程序，内核直接返回未就绪的返回值，等待用户程序下一个轮询。 I/O多路复用 ​ 发送方向接收方请求后，不等待响应，可以继续其他工作。 接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 ​ 这里复用的是指复用一个或几个线程，用一个或一组线程处理多个IO操作，减少系统开销小，不必创建和维护过多的进程/线程。 信号驱动I/O ​ 信号驱动I/O是利用信号机制，让内核告知应用程序文件描述符的相关事件。 异步非阻塞I/O ​ 发送方向接收方请求后，不等待响应，可以继续其他工作。 接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。 当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。 ​ 需要说明的是，⽆论是阻塞 I/O、⾮阻塞 I/O，还是基于⾮阻塞 I/O 的多路复⽤都是同步调⽤。因为它们在 read调⽤时，内核将数据从内核空间拷⻉到应⽤程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。 2 I/O多路复用：select/poll/epoll​ I/O多路复用其实就是使用一个进程来维护多个Socket。 ​ ⼀个进程虽然任⼀时刻只能处理⼀个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1秒内就可以处理上千个请求，把时间拉⻓来看，多个请求复⽤了⼀个进程，这就是多路复⽤，这种思想很类似⼀个 CPU 并发多个进程，所以也叫做时分多路复⽤。 ​ select/poll/epoll 内核提供给⽤户态的多路复⽤系统调⽤，进程可以通过⼀个系统调⽤函数从内核中获取多个事件。 2.1 select​ select 实现多路复⽤的⽅式是，将已连接的 Socket 都放到⼀个⽂件描述符集合，然后调⽤ select 函数将⽂件描述符集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历⽂件描述符集合的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个⽂件描述符集合拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，然后再对其处理。 ​ 所以，对于 select 这种⽅式，需要进⾏ 2 次「遍历」⽂件描述符集合，⼀次是在内核态⾥，⼀个次是在⽤户态⾥ ，⽽且还会发⽣ 2 次「拷⻉」⽂件描述符集合，先从⽤户空间传⼊内核空间，由内核修改后，再传出到⽤户空间中。 ​ select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。 2.2 poll​ poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。但是 poll 和 select 并没有太⼤的本质区别，都是使⽤「线性结构」存储进程关注的 Socket 集合，因此都需要遍历⽂件描述符集合来找到可读或可写的Socket，时间复杂度为O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。 2.3 epoll​ epoll 通过两个⽅⾯，很好解决了 select/poll 的问题。 ​ 第⼀点，epoll 在内核⾥使⽤红⿊树来跟踪进程所有待检测的⽂件描述字，把需要监控的 socket 通过epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，减少了内核和⽤户空间⼤量的数据拷⻉和内存分配。 ​ 第⼆点， epoll 使⽤事件驱动的机制，内核⾥维护了⼀个链表来记录就绪事件，当某个 socket 有事件发⽣时，通过回调函数内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤epoll_wait()函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。 ​ 从下图你可以看到 epoll 相关的接⼝作⽤： ​ ​ epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，epoll 被称为解决 C10K问题 ​ 要注意的是，epoll使⽤的并不是共享内存的⽅式，即⽤户态和内核态都指向了就绪链表，所以就避免了内存拷⻉消耗。 ​ epoll ⽀持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和⽔平触发（level-triggered，LT）。 使⽤边缘触发模式时，当被监控的 Socket 描述符上有可读事件发⽣时，服务器端只会从 epoll_wait中苏醒⼀次，即使进程没有调⽤ read 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保证⼀次性将内核缓冲区的数据读取完； 使⽤⽔平触发模式时，当被监控的 Socket 上有可读事件发⽣时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被** read 函数读完才结束，⽬的是告诉我们有数据需要读取； 3 总结​ select 和 poll 并没有本质区别，它们内部都是使⽤「线性结构」来存储进程关注的 Socket 集合。 ​ 在使⽤的时候，⾸先需要把关注的 Socket 集合通过 select/poll 系统调⽤从⽤户态拷⻉到内核态，然后由内核检测事件，当有⽹络事件产⽣时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷⻉到⽤户态，⽤户态还要继续遍历整个 Socket 集合找到可读/可写的 Socket，然后对其处理。 ​ 很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越⼤，Socket 集合的遍历和拷⻉会带来很⼤的开销，因此也很难应对 C10K。 ​ epoll 是解决 C10K 问题的利器，通过两个⽅⾯解决了 select/poll 的问题。 epoll 在内核⾥使⽤「红⿊树」来关注进程所有待检测的 Socket，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是 O(logn)，通过对这棵⿊红树的管理，不需要像 select/poll 在每次操作时都传⼊整个 Socket 集合，减少了内核和⽤户空间⼤量的数据拷⻉和内存分配。 epoll 使⽤事件驱动的机制，内核⾥维护了⼀个「链表」来记录就绪事件，只将有事件发⽣的 Socket集合传递给应⽤程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和⽆事件的 Socket ），⼤⼤提⾼了检测的效率。 ​ ⽽且，epoll ⽀持边缘触发和⽔平触发的⽅式，⽽ select/poll 只⽀持⽔平触发，⼀般⽽⾔，边缘触发的⽅式会⽐⽔平触发的效率⾼。 参考一文看懂IO多路复用 - 知乎 (zhihu.com) 图解系统-亮白风格-小林coding-v1.0.pdf","link":"/2022/02/21/Linux/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/"},{"title":"第283场周赛","text":"6016. Excel 表中某个范围内的单元格 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021class Solution {public: vector&lt;string&gt; cellsInRange(string s) { char s1 = s[0], s2 = s[3]; char n1 = s[1], n2 = s[4]; int n = s2 - s1, m = n2 - n1; vector&lt;string&gt; res; for (int i = 0; i &lt;= n; i ++) { char t = n1; for (int j = 0; j &lt;= m; j ++) { string s = &quot;&quot;; s.append(1, s1); s.append(1, t); t ++; res.push_back(s); } s1 ++; } return res; }}; 6017. 向数组中追加 K 个整数 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920class Solution {public: long long minimalKSum(vector&lt;int&gt;&amp; nums, int k) { nums.push_back(0); nums.push_back(2e9); sort(nums.begin(), nums.end()); long long res = 0; for (int i = 1; i &lt; nums.size(); i ++) { int fill = nums[i] - nums[i - 1] - 1; // 要填充的数 if (fill &lt; 0) continue; if (fill &gt;= k) { res += (long long) (nums[i - 1] + 1 + nums[i - 1] + k) * k / 2; break; } res += (long long) (nums[i - 1] + nums[i]) * fill / 2; k -= fill; } return res; }}; 6018. 根据描述创建二叉树 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* createBinaryTree(vector&lt;vector&lt;int&gt;&gt;&amp; descriptions) { unordered_map&lt;int, TreeNode*&gt; map; set&lt;int&gt; childs; for (auto vec: descriptions) { int pVal = vec[0], cVal = vec[1]; bool juge = vec[2] == 1 ? true : false; auto pNode = map[pVal]; if (pNode == nullptr) { pNode = new TreeNode(pVal); map[pVal] = pNode; } auto cNode = map[cVal]; if (cNode == nullptr) { cNode = new TreeNode(cVal); map[cVal] = cNode; } childs.insert(cVal); if (juge) { pNode-&gt;left = cNode; } else { pNode-&gt;right = cNode; } } // for (auto i: childs) cout &lt;&lt; i &lt;&lt; endl; TreeNode* root = nullptr; for (auto vec: descriptions) { if (childs.count(vec[0])) continue; else { root = map[vec[0]]; break; } } return root; }}; 6019. 替换数组中的非互质数 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; replaceNonCoprimes(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; vec{nums[0]}; for (int i = 1; i &lt; nums.size(); i ++) { vec.push_back(nums[i]); while (vec.size() &gt; 1) { int x = vec.back(), y = vec[vec.size() - 2]; int t = gcd(x, y); if (t == 1) break; vec.pop_back(); vec.back() *= x / t; } } return vec; } int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); }};","link":"/2022/03/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC283%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"第279场周赛","text":"6000. 对奇偶下标分别排序123456789101112131415161718class Solution {public: vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; vec1, vec2; for (int i = 0; i &lt; nums.size(); i ++) { if (i % 2 == 0) vec1.push_back(nums[i]); // 偶数 else vec2.push_back(nums[i]); // 奇数 } sort(vec1.begin(), vec1.end()); sort(vec2.begin(), vec2.end(), greater&lt;int&gt;()); vector&lt;int&gt; res; for (int i = 0, j = 0, k = 0; i &lt; nums.size(); i ++) { if (i % 2 == 0) res.push_back(vec1[j ++]); else res.push_back(vec2[k ++]); } return res; }}; 6001. 重排数字的最小值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;int&gt; getNum(long long num) { vector&lt;int&gt; a; while(num) { a.push_back(num % 10); num /= 10; } return a; } long long smallestNumber(long long num) { long long res = 0; if (num &gt; 0) { auto a = getNum(num); sort(a.begin(), a.end()); int i = 0, n =a.size(), k = 0; bool flag = true; vector&lt;int&gt; vec; for (int i = 0; i &lt; n; i ++) { if (a[i] != 0 &amp;&amp; flag){ k = i, flag = !flag; continue; } vec.push_back(a[i]); } res += a[k] * pow(10, n - 1); int cnt = vec.size() - 1; for (int i = 0; i &lt; vec.size(); i ++) { res += vec[i] * pow(10, cnt); cnt --; } } else { long long n1 = -num; auto a = getNum(n1); sort(a.begin(), a.end(), greater&lt;int&gt;()); int cnt = a.size() - 1; for (int i = 0; i &lt; a.size(); i ++) { res += a[i] * pow(10, cnt); cnt --; } res = -res; } return res; }}; 6002. 设计位集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Bitset {public: string bst, fbst; int cnt; bool flipped; // 判断是否翻转 Bitset(int size) { bst = string(size, '0'); fbst = string(size, '1'); cnt = 0; flipped = false; } void fix(int idx) { if (!flipped) { if (bst[idx] == '0') cnt ++; bst[idx] = '1'; fbst[idx] = '0'; } else { if (bst[idx] == '1') cnt ++; // 如果翻转了，则是fbit，那么翻转前是1，翻转后是0，fix设置fbit，则加1 bst[idx] = '0'; fbst[idx] = '1'; } } void unfix(int idx) { if (!flipped) { if (bst[idx] == '1') cnt --; bst[idx] = '0'; fbst[idx] = '1'; } else { if (bst[idx] == '0') cnt --; bst[idx] = '1'; fbst[idx] = '0'; } } void flip() { flipped = !flipped; cnt = bst.size() - cnt; } bool all() { return cnt == bst.size(); } bool one() { return cnt &gt; 0; } int count() { return cnt; } string toString() { if (!flipped) return bst; else return fbst; }};/** * Your Bitset object will be instantiated and called as such: * Bitset* obj = new Bitset(size); * obj-&gt;fix(idx); * obj-&gt;unfix(idx); * obj-&gt;flip(); * bool param_4 = obj-&gt;all(); * bool param_5 = obj-&gt;one(); * int param_6 = obj-&gt;count(); * string param_7 = obj-&gt;toString(); */ 6003. 移除所有载有违禁货物车厢所需的最少时间前后缀分解 + DP - 移除所有载有违禁货物车厢所需的最少时间 1234567891011121314151617181920212223242526class Solution {public: /* 考虑左半部分的最少时间。 当s[i] == '0' pre[i] = pre[i - 1] 当s[i] == '1' pre[i] = min(pre[i - 1] + 2, i + 1) 考虑右半部分的最少时间 s[i] == '0' , suf[i] = suf[i + 1] s[i] == '1' , suf[i] = min(suf[i + 1] + 2, n - i) */ int minimumTime(string s) { int n = s.length(); vector&lt;int&gt; suf(n + 1, 0); // 移除后i个载有违禁货物车所需的最少单位时间数 for (int i = n - 1; i &gt;= 0; i --) { suf[i] = s[i] == '0' ? suf[i + 1] : min(suf[i + 1] + 2, n - i); } // 枚举分割点 int pre = 0, ans = suf[0]; // pre使用滚动数组优化 for (int i = 0; i &lt; n; i ++) { if (s[i] == '1') pre = min(pre + 2, i + 1); ans = min(ans, pre + suf[i]); } return ans; }};","link":"/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC279%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"第284场周赛","text":"6031. 找出数组中的所有 K 近邻下标 - 力扣（LeetCode） (leetcode-cn.com) 12345678910111213141516171819class Solution {public: vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) { vector&lt;int&gt; idxs; for (int i = 0; i &lt; nums.size(); i ++) if (nums[i] == key) idxs.push_back(i); vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i ++) { for (auto idx: idxs) { if (abs(i - idx) &lt;= k) { res.push_back(i); break; } } } return res; }}; 5203. 统计可以提取的工件 - 力扣（LeetCode） (leetcode-cn.com) 12345678910111213141516171819class Solution { typedef pair&lt;int, int&gt; pii; bool check(vector&lt;int&gt; &amp;vec, set&lt;pii&gt; &amp;st) { for (int i = vec[0]; i &lt;= vec[2]; i++) for (int j = vec[1]; j &lt;= vec[3]; j++) if (!st.count(pii(i, j))) return false; return true; }public: int digArtifacts(int n, vector&lt;vector&lt;int&gt;&gt;&amp; artifacts, vector&lt;vector&lt;int&gt;&gt;&amp; dig) { set&lt;pii&gt; st; for (auto &amp;vec : dig) st.insert(pii(vec[0], vec[1])); int ans = 0; for (auto &amp;vec : artifacts) if (check(vec, st)) ans++; return ans; }}; 5227. K 次操作后最大化顶端元素 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021/*如果 nums.length=1，那么如果 k 是偶数，那么栈里存在nums[0]；如果 k 是奇数，那么栈里一定没有任何元素，返回 -1−1。否则，栈顶元素可以是：nums 的前 k−1 个数的最大值；nums 的第 k+1 个数（如果有，此时出栈前 kk 个数即可）；注意，nums 的第 k 个数永远不会出现在栈顶。*/class Solution {public: int maximumTop(vector&lt;int&gt;&amp; nums, int k) { if (nums.size() == 1 &amp;&amp; k &amp; 1) return -1; int mx = 0; for (int i = 0; i &lt; nums.size() &amp;&amp; i + 1 &lt; k; i ++) { mx = max(mx, nums[i]); } if (k &lt; nums.size()) { mx = max(mx, nums[k]); } return mx; }}; 6032. 得到要求路径的最小带权子图 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: typedef pair&lt;int, int&gt; PII; typedef pair&lt;long long, int&gt; PLLI; long long minimumWeight(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int src1, int src2, int dest) { vector&lt;PII&gt; grid[n], fgrid[n]; for (auto &amp;e: edges) { grid[e[0]].emplace_back(e[1], e[2]); fgrid[e[1]].emplace_back(e[0], e[2]); } vector&lt;long long&gt; dist1(n, 1e15), dist2(n, 1e15), dist3(n, 1e15); dijkstra(src1, grid, dist1); dijkstra(src2, grid, dist2); dijkstra(dest, fgrid, dist3); long long res = 1e15; for (int i = 0; i &lt; n; i ++) { res = min(res, dist1[i] + dist2[i] + dist3[i]); } if (res &gt; 1e12) { return -1; } return res; } void dijkstra(int s, vector&lt;PII&gt; grid[], vector&lt;long long&gt; &amp;dist) { priority_queue&lt;PLLI, vector&lt;PLLI&gt;, greater&lt;PLLI&gt;&gt; q; dist[s] = 0; q.emplace(0, s); while (q.size()) { auto [cost, node] = q.top(); q.pop(); if (cost &gt; dist[node]) continue; for (auto [ne, w]: grid[node]) { if (cost + w &lt; dist[ne]) { dist[ne] = cost + w; q.emplace(cost + w, ne); } } } }};","link":"/2022/03/13/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC284%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"第72场双周赛","text":"5996. 统计数组中相等且可以被整除的数对 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); int res = 0; for (int i = 0; i &lt; n; i ++) for (int j = i + 1; j &lt; n; j ++) { if (nums[i] == nums[j]) { if (((i * j) % k) == 0) res ++; } } return res; }}; 5997. 找到和为给定整数的三个连续整数 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314class Solution {public: vector&lt;long long&gt; sumOfThree(long long num) { long long mid = num / 3; long left = mid - 1, right = mid + 1; vector&lt;long long&gt; res; if (mid + left + right == num) { res.push_back(left); res.push_back(mid); res.push_back(right); } return res; }}; 5998. 拆分成最多数目的偶整数之和 - 力扣（LeetCode） (leetcode-cn.com) 12345678910111213141516class Solution {public: vector&lt;long long&gt; maximumEvenSplit(long long finalSum) { if (finalSum % 2 == 1) return vector&lt;long long&gt;{}; vector&lt;long long&gt; res; long long i = 2; while (finalSum &gt;= i) { res.push_back(i); finalSum -= i; i += 2; } res[res.size() - 1] += finalSum; return res; }};","link":"/2022/02/20/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC72%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第285场周赛","text":"6027. 统计数组中峰和谷的数量 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718class Solution {public: int countHillValley(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; vec; for (int i = 0; i &lt; n; i ++) { while (i + 1 &lt; n &amp;&amp; nums[i] == nums[i + 1]) i ++; vec.push_back(nums[i]); } int res = 0; // for (auto num: vec) cout &lt;&lt; num &lt;&lt; endl; for (int i = 1; i &lt; vec.size() - 1; i ++) { if (vec[i - 1] &gt; vec[i] &amp;&amp; vec[i + 1] &gt; vec[i]) res ++; if (vec[i - 1] &lt; vec[i] &amp;&amp; vec[i] &gt; vec[i + 1]) res ++; } return res; }}; 6028. 统计道路上的碰撞次数 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617class Solution {public: int countCollisions(string directions) { int ans = 0; bool flag = false; for (int i = 0; i &lt; directions.size(); i ++) { if (directions[i] == 'R' || directions[i] == 'S') flag = true; else if (flag) ans ++; } flag = false; for (int i = directions.size() - 1; i &gt;= 0; i --) { if (directions[i] == 'L' || directions[i] == 'S') flag = true; else if (flag) ans ++; } return ans; }}; 6029. 射箭比赛中的最大得分 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; maximumBobPoints(int numArrows, vector&lt;int&gt;&amp; aliceArrows) { int n = aliceArrows.size(); vector&lt;int&gt; ans(n, 0); int maxScore = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++) { int score = 0, arrows = 0;; vector&lt;int&gt; bobArrows(n, 0); for (int j = 0; j &lt; n; j ++) { if (((i &gt;&gt; j) &amp; 1) == 1) { score += j; arrows += aliceArrows[j] + 1; bobArrows[j] = aliceArrows[j] + 1; } } if (arrows &gt; numArrows) continue; if (score &gt; maxScore) { maxScore = score; bobArrows[0] += (numArrows - arrows); ans = bobArrows; } } return ans; }}; 6030. 由单个字符重复的最长子字符串 - 力扣（LeetCode） (leetcode-cn.com) 要用线段树，不太会","link":"/2022/03/20/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC285%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"第71周双周赛","text":"5984. 拆分数位后四位数字的最小和123456789101112131415161718192021222324class Solution {public: int minimumSum(int num) { vector&lt;int&gt; vec; int t = num; while (t) { vec.push_back(t % 10); t /= 10; } sort(vec.begin(), vec.end()); int zero = count(vec.begin(), vec.end(), 0); if (zero == 3) { return vec[3]; } else if (zero == 2) { return vec[2] + vec[3]; } else if (zero == 1) { if (vec[2] &gt; vec[3]) return vec[1] * 10 + vec[3] + vec[2]; return vec[1] * 10 + vec[2] + vec[3]; } else { return vec[0] * 10 + vec[2] + vec[1] * 10 + vec[3]; } return 0; }}; 5985. 根据给定数字划分数组1234567891011121314151617class Solution {public: vector&lt;int&gt; pivotArray(vector&lt;int&gt;&amp; nums, int pivot) { vector&lt;int&gt; vec1; for (auto num: nums) if (num &lt; pivot) vec1.push_back(num); vector&lt;int&gt; vec2; for (auto num: nums) if (num &gt; pivot) vec2.push_back(num); int tot = count(nums.begin(), nums.end(), pivot); vector&lt;int&gt; res; for (auto i: vec1) res.push_back(i); for (int i = 0; i &lt; tot; i ++) res.push_back(pivot); for (auto i: vec2) res.push_back(i); return res; }}; 5986. 设置时间的最少代价123456789101112131415161718192021222324252627282930313233class Solution {public: /* 分类讨论 因为秒数的范围[0,99], 分两种场景讨论: a. mins = target / 60, secs = target % 60; b. mins = target / 60 - 1, secs = target % 60 + 60; 将mins*100+secs转为字符串进行处理, 求出花费的时间即可; */ int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) { int mins = targetSeconds / 60, secs = targetSeconds % 60; int ans1 = calTime(startAt, moveCost, pushCost, mins, secs); int ans2 = calTime(startAt, moveCost, pushCost, mins - 1, secs + 60); return min(ans1, ans2); } int calTime(int startAt, int moveCost, int pushCost, int mins, int secs) { if (mins &lt; 0 || mins &gt; 99 || secs &gt; 99) { return INT_MAX; } string s = to_string(mins * 100 + secs); int ans = 0; for (int i = 0; i &lt; s.size(); i ++) { if (s[i] - '0' == startAt) { ans += pushCost; } else { ans += pushCost + moveCost; } startAt = s[i] - '0'; } return ans; }}; 5987. 删除元素后和的最小差值1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: /* 枚举i为分界点，维护0-i内长度为n / 3 的最小值，i + 1 - n - 1内长度为n / 3的最大值 */ long long minimumDifference(vector&lt;int&gt;&amp; nums) { int n = nums.size(), k = n / 3; vector&lt;long long&gt; s1(n, 0); priority_queue&lt;int&gt; small; // 大根堆，维护0 - i内的最小值 for (int i = 0; i &lt; 2 * k; i ++) { s1[i] = (i &gt; 0) ? s1[i - 1] : 0; small.push(nums[i]); s1[i] += nums[i]; if (small.size() &gt; k) { s1[i] -= small.top(); small.pop(); } } vector&lt;long long&gt; s2(n, 0); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; big; // 小根堆，维护 i + 1 - n - 1内的最大值 for (int i = n - 2; i &gt;= k - 1; i --) { // 注意这里是n - 2的原因是，下面计算答案是从 k - 1 ~ 2 *k - 1，如果为n-1，会多算一个数进来 // 例如 1 2 3 4 5 6 ，n-2会使得下标为1的位置s[1] 表示 后4个数中最大值，n-1则表示5个数了 s2[i] = s2[i + 1]; big.push(nums[i + 1]); s2[i] += nums[i + 1]; if (big.size() &gt; k) { s2[i] -= big.top(); big.pop(); } } long long res = 1e15; for (int i = k - 1; i &lt; 2 * k; i ++) { res = min(res, s1[i] - s2[i]); } return res; }};","link":"/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC71%E5%91%A8%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"Redis基础数据类型","text":"1 SDS1.1 结构体​ 以下结构体表示一个SDS值： 12345678struct sdshdr { // 记录buf数组中已使用的字节数量 int len; // 记录buf数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];} 1.2 结构图 1.3与c字符串的区别 可以常数复杂度获取字符串长度 ​ c中获取字符串长度的方式是通过线性遍历，而SDS由于存储已使用的字节数量，可以通过常数复杂度获取 杜绝缓冲区溢出 ​ 例如，c的字符串在使用strcat为原字符串添加字符串时，如果未分配有效空间，很可能造成缓冲区溢出。而SDS的API会检查空间是否满足修改所需的要求。 减少修改字符串时带来的内存重分配次数 ​ c中字符串在执行拼接操作时，如果空间不足，需要通过内存重分配来扩张空间大小，如果忘了则会发生缓冲区溢出 ​ 如果执行截断操作，程序就要释放不再使用的空间，如果忘了则会发生内存泄漏 ​ 以上两种操作，如果频繁地发生，是会对性能造成影响的。 ​ 由此，SDS通过空间预分配和惰性空间释放两种策略来进行优化 空间预分配 ​ 当SDS在分配空间时，如果SDS长度小于1M，则会分配原来长度len同样大小的未使用空间（还得+1，空字符）；如果SDS大于1M，则会分配1M未使用空间+1。这样使得内存分配次数从N次降低到最多N次 惰性空间释放 ​ 当SDS在释放空间时，不会进行空间回收，而是使用free属性将字节数量记录下来，方便将来使用 二进制安全 ​ 由于c中不能包含空字符（会被当成结尾），限制了不能保存像图片，音频，视频这样的二进制数据。但SDS由于通过len来判断字符串是否结束，从而不会发生这种问题。 兼容部分C字符串函数 2 链表2.1 结构体1234567891011/* 节点*/typedef struct listNode { // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value;} listNode; 1234567891011121314151617/* 链表*/typedef struct list { // 表头结点 listNode *head; // 表尾节点 listNode *tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup) (void *ptr); // 节点值释放函数 void (*free) (void *ptr); // 节点值对比函数 int (*match) (void *ptr, void *key);} list; 2.2 结构图 3 字典​ 字典底层使用哈希表，一个哈希表可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对 3.1 结构体12345678910111213/* 哈希表节点*/typedef struct dictEntry { void *key; // 键 union { // 值，可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数 void *val; uint64_tu64; int64_ts64; } v; // 指向下个哈希表节点，形成链表 struct dictEntry *next;} dictEntry; 1234567891011121314/* 哈希表*/typedef struct dictht { // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于size-1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used;} dictht; 1234567891011121314/* 字典*/typedef struct dict { // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash索引 // 当rehash不在进行时，值为-1 int trehashidx;} dict; 3.2 结构图 4 跳跃表​ 一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 ​ 支持平均O（logN），最坏O（N）复杂度的节点查找 4.1 结构体123456789101112131415typedef struct zskiplistNode { // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; } level[]; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj;} zskiplistNode; 12345678typedef struct zskiplist { // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level;} zskiplist; 4.2 结构图 5 整数集合​ 用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。 5.1 结构体12345678typedef struct intset { // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[];} intset; 5.2 结构图 6 压缩列表6.1 构成 列表 节点 previous_entry_length ​ 记录了压缩列表中前一个节点的长度。 encoding ​ 记录了节点的content属性所保存数据的类型以及长度 content ​ 保存节点的值，节点值可以是一个字节数组或者整数 7 对象​ Redis并没有直接使用上述数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。 7.1 结构体12345678910typedef struct redisObject { // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; // ...} robj; 7.2 字符串对象 7.3 列表对象​ 列表对象的编码可以是ziplist或者linkedlist。 ziplist linkedlist 运用场景​ 比如twitter的关注列表、粉丝列表等都可以用Redis的list结构来实现，再比如有的应用使用Redis的list类型实现一个简单的轻量级消息队列，生产者push，消费者pop/bpop。 7.4 哈希对象​ 哈希对象的编码可以是ziplist或者hashtable。 ziplist hashtable 运用场景​ 假设有多个用户及对应的用户信息，可以用来存储以用户ID为key，将用户信息序列化为比如json格式做为value进行保存。 7.5 集合对象​ 集合对象的编码可以是intset或者hashtable。 intest hashtabl 运用场景​ 在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 7.6 有序集合对象​ 有序集合的编码可以是ziplist或者skiplist。 ziplist skiplist 运用场景​ 比如用户的积分排行榜需求就可以通过有序集合实现。也可以通过Sorted Set实现有优先级或按权重的队列。","link":"/2022/03/10/Redis/Redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"netty入门（二）","text":"1 netty工作原理 流程 Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写 BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 Selector , 用于监听绑定在其上的 Socket 的网络通讯 NioEventLoopGroup(BossGroup、WorkerGroup) 可以有多个线程, 即可以含有多个 NioEventLoop 每个Boss 的 NioEventLoop 循环执行的步骤有3步 轮询accept 事件 处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到 Worker 的 NIOEventLoop 上的 Selector 处理任务队列的任务 ， 即 runAllTasks 每个 Worker 的 NIOEventLoop 循环执行的步骤 轮询read, write 事件 处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理 处理任务队列的任务 ， 即 runAllTasks 每个Worker NIOEventLoop 处理业务时，会使用 Pipeline(管道), Pipeline 中包含了 Channel , 即通过 Pipeline 可以获取到对应通道, 管道中维护了很多的处理器。管道可以使用 Netty 提供的，也可以自定义 2 快速入门实现 Netty 服务器在 6666 端口监听，客户端能发送消息给服务器 “hello, 服务器~” 服务器可以回复消息给客户端 “hello, 客户端~” 依赖 123456&lt;!--netty依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.52.Final&lt;/version&gt;&lt;/dependency&gt; 服务端NettyServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package netty.test;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer { public static void main(String[] args) { /** * 创建BossGroup和 WorkerGroup * 1. 创建两个线程组BossGroup和 WorkerGroup * 2. BossGroup只处理请求 * 3. WorkerGroup 处理真正客户端的业务 * 4. 运行时，这两个都是无限循环 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { // 创建服务端启动对象，并配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); // 链式编程 bootstrap.group(bossGroup, workerGroup) // 设置两个线程组 .channel(NioServerSocketChannel.class) //使用NioServerSocketChannel作为服务器的通道实现 .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列等待连接的个数 .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置连续保持活动连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { // 给workerGroup的NioEventLoop对应的管道设置处理器 /** * 创建一个通道初始化对象 * 给workerGroup对应的管道设置处理器 * @param socketChannel * @throws Exception */ @Override protected void initChannel(SocketChannel socketChannel) throws Exception { socketChannel.pipeline() // 获得这个socketChannel对应的pipeline .addLast(new NettyServerHandler()); } }); System.out.println(&quot;服务器准备好...&quot;); // 绑定一个端口，并且同步，生成一个ChannelFuture对象 // 这里就已经启动了服务器 ChannelFuture channelFuture = bootstrap.bind(6666).sync(); // 对关闭通道进行监听 // 这里只是监听，只有关闭通道才进行处理，不是直接关闭通道 channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { e.printStackTrace(); } finally { bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } }} 自定义Netty服务端处理器：NettyServerHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package netty.test;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import java.nio.charset.Charset;public class NettyServerHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { System.out.println(&quot;[server]：ctx&quot; + ctx); /** * 将 msg 转换成 ByteBuffer * 说明 : * 1. 注意这个是 ByteBuf ，是 io.netty.buffer 包下的，不是 NIO 下的 Buffer * 2. ByteBuf 比 Buffer 的性能更高一点 */ ByteBuf buf = (ByteBuf) msg; // 把 buf 转成 UTF8 格式的字符串 System.out.println(&quot;客户端发送的msg：&quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;客户端地址：&quot; + ctx.channel().remoteAddress()); } /** * 数据读取完毕后，返回消息给客户端 * @param ctx * @throws Exception */ @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { /** * 把数据写入缓冲区，并刷新缓冲区 * 一般来说，需要对这个发送的消息进行编码 */ ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello，客户端&quot;, CharsetUtil.UTF_8)); } /** * 处理异常 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { // 关闭通道 ctx.channel().close(); }} 客户端NettyClient 12345678910111213141516171819202122232425262728293031323334353637package netty.test;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class NettyClient { public static void main(String[] args) { // 客户端需要一个事件循环组 NioEventLoopGroup group = new NioEventLoopGroup(); try { // 客户端启动对象——Bootstrap，不是服务端的ServerBootstrap Bootstrap bootstrap = new Bootstrap(); // 设置相关参数 bootstrap.group(group) .channel(NioSocketChannel.class) // 设置客户端通道的实现类 .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { socketChannel.pipeline().addLast(new NettyClientHandler()); } }); System.out.println(&quot;客户端准备好了...&quot;); // 启动客户端连接服务器端 ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 6666).sync(); // 对关闭通道进行监听 channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { e.printStackTrace(); } finally { group.shutdownGracefully(); } }} 客户端处理器NettyClientHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445package netty.test;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;public class NettyClientHandler extends ChannelInboundHandlerAdapter { /** * 当通道准备就绪时，就会触发该方法，就可以发信息了 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { System.out.println(&quot;[client]：ctx&quot; + ctx); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello, Server&quot;, CharsetUtil.UTF_8)); } /** * 当通道有读取事件时，会触发 * @param ctx * @param msg * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器发送的msg：&quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址：&quot; + ctx.channel().remoteAddress()); } /** * 异常处理 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.channel().close(); }} 3 分析3.1 BossGroup 和 WorkGroup 怎么确定自己有多少个 NIOEventLoop 通过源码发现含有的子线程数默认为CPU核数*2 ​ 我的CPU核数为8，所以有16个进程，每个进程的类型都是NioEventLoop 3.2 WorkerGroup是如何分配这些进程的设置BossGroup进程数和WorkerGroup进程数 重复运行5次客户端可发现 所以，WorkerGroup分配的逻辑是按顺序分配的 3.3 BossGroup和WorkerGroup中的Selector和TaskQueue​ 3.4 CTX上下文，Channel，Pipeline之间关系 CTX pipeline Pipeline 三者关系图","link":"/2022/03/13/netty/netty%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"LC中经典数据结构题集","text":"1206. 设计跳表——对链表的二分优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Skiplist {public: struct Node { // 向右向下指针 Node *right, *down; int val; Node(Node *right, Node *down, int val): right(right), down(down), val(val) {} }*head; const static int MAX_LEVEL = 32; vector&lt;Node*&gt; pathList; Skiplist() { head = new Node(NULL, NULL, -1); pathList.reserve(MAX_LEVEL); } bool search(int target) { Node *p = head; while (p) { // 左右寻找目标区间 while (p-&gt;right &amp;&amp; p-&gt;right-&gt;val &lt; target) { p = p-&gt;right; } // 没找到目标值，则继续往下走 if (!p-&gt;right || p-&gt;right-&gt;val &gt; target) { p = p-&gt;down; } else { //找到目标值，结束 return true; } } return false; } void add(int num) { //从上至下记录搜索路径 pathList.clear(); Node *p = head; // 从上到下去搜索 次小于num的 数字，等于就是另外一种实现里的 prevs while (p) { // 向右找到次小于num的p while(p-&gt;right &amp;&amp; p-&gt;right-&gt;val &lt; num) { p = p-&gt;right; } pathList.push_back(p); p = p-&gt;down; } bool insertUp = true; Node *downNode = NULL; // 从下至上搜索路径回溯，50%概率 // 这里实现是会保证不会超过当前的层数的，然后靠头结点去额外加层， 即每次新增一层 while(insertUp &amp;&amp; pathList.size() &gt; 0) { Node *insert = pathList.back(); pathList.pop_back(); // add 新节点 insert-&gt;right = new Node(insert-&gt;right, downNode, num); // 把新结点赋值为downNode downNode = insert-&gt;right; // 50% insertUp = (rand() &amp; 1) == 0; } // 新增一层 if (insertUp) { head = new Node(new Node(NULL, downNode, num), head, -1); } } bool erase(int num) { Node *p = head; bool seen = false; while (p) { // 当前层向右找到次小的点 while (p-&gt;right &amp;&amp; p-&gt;right-&gt;val &lt; num) { p = p-&gt;right; } // 无效点，或者 太大， 则到下一层去 if (!p-&gt;right || p-&gt;right-&gt;val &gt; num) { p = p-&gt;down; } else { // 搜索到目标结点，进行删除操作，结果记录为true // 继续往下层搜索，删除一组目标结点 seen = true; p-&gt;right = p-&gt;right-&gt;right; p = p-&gt;down; } } return seen; }};/** * Your Skiplist object will be instantiated and called as such: * Skiplist* obj = new Skiplist(); * bool param_1 = obj-&gt;search(target); * obj-&gt;add(num); * bool param_3 = obj-&gt;erase(num); */ 460. LFU 缓存——双链表+双哈希表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class LFUCache {public: struct Node { Node *left, *right; int key, val; Node (int _key, int _val) { key = _key, val = _val; left = right = NULL; } }; struct Block { Block *left, *right; Node *head, *tail; int cnt; Block(int _cnt) { cnt = _cnt; left = right = NULL; head = new Node(-1, -1), tail = new Node(-1, -1); head-&gt;right = tail, tail-&gt;left = head; } ~Block() { delete head; delete tail; } void insert(Node *p) { p-&gt;right = head-&gt;right; head-&gt;right-&gt;left = p; head-&gt;right = p; p-&gt;left = head; } void remove(Node *p) { p-&gt;right-&gt;left = p-&gt;left; p-&gt;left-&gt;right = p-&gt;right; } bool empty() { return head-&gt;right == tail; } }*head, *tail; int n; unordered_map&lt;int, Node*&gt; hash_node; unordered_map&lt;int, Block*&gt; hash_block; LFUCache(int capacity) { n = capacity; head = new Block(0), tail = new Block(INT_MAX); head-&gt;right = tail, tail-&gt;left = head; } void insert(Block *p) { auto cur = new Block(p-&gt;cnt + 1); cur-&gt;right = p-&gt;right; p-&gt;right-&gt;left = cur; cur-&gt;left = p; p-&gt;right = cur; } void remove(Block *p) { p-&gt;right-&gt;left = p-&gt;left; p-&gt;left-&gt;right = p-&gt;right; delete p; } int get(int key) { if (hash_block.count(key) == 0) return -1; auto block = hash_block[key]; auto node = hash_node[key]; block-&gt;remove(node); if (block-&gt;right-&gt;cnt != block-&gt;cnt + 1) insert(block); block-&gt;right-&gt;insert(node); hash_block[key] = block-&gt;right; if (block-&gt;empty()) remove(block); return node-&gt;val; } void put(int key, int value) { if (!n) return ; if (hash_block.count(key)) { auto node = hash_node[key]; node-&gt;val = value; get(key); } else { if (hash_block.size() == n) { auto p = head-&gt;right-&gt;tail-&gt;left; head-&gt;right-&gt;remove(p); if (head-&gt;right-&gt;empty()) remove(head-&gt;right); hash_block.erase(p-&gt;key); hash_node.erase(p-&gt;key); delete p; } auto p = new Node(key, value); if (head-&gt;right-&gt;cnt &gt; 1) insert(head); head-&gt;right-&gt;insert(p); hash_block[key] = head-&gt;right; hash_node[key] = p; } }};/** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 146. LRU 缓存——链表+哈希表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class LRUCache {public: struct Node { int key, val; Node *next, *prev; Node(int _key, int _val): key(_key), val(_val), next(nullptr), prev(nullptr) {}; } *L, *R; unordered_map&lt;int, Node*&gt; hash; int n; LRUCache(int capacity) { n = capacity; L = new Node(-1, -1), R = new Node(-1, -1); L-&gt;next = R, R-&gt;prev = L; } void insert_node(Node *p) { p-&gt;next = L-&gt;next, L-&gt;next-&gt;prev = p, p-&gt;prev = L, L-&gt;next = p; } void delete_node(Node *p) { p-&gt;next-&gt;prev = p-&gt;prev, p-&gt;prev-&gt;next = p-&gt;next; } int get(int key) { if (hash.count(key)) { auto p = hash[key]; delete_node(p); insert_node(p); return p-&gt;val; } else { return -1; } } void put(int key, int value) { if (hash.count(key)) { auto p = hash[key]; delete_node(p); p-&gt;val = value; insert_node(p); } else { if (n == hash.size()) { auto q = R-&gt;prev; delete_node(q); hash.erase(q-&gt;key); } auto p = new Node(key, value); hash[key] = p; insert_node(p); } }};/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","link":"/2022/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LC%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E9%9B%86/"},{"title":"春招面经记录","text":"Pure字节暑期二面飞书办公","link":"/2022/03/11/%E6%9D%82%E7%83%A9/%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/"},{"title":"精选博文（转载）","text":"JavaJAVA中BIO、NIO、AIO的分析理解-阿里云开发者社区 (aliyun.com) JVM JMM概述_牧竹子-CSDN博客_jmm JVM_12 JMM内存模型_兴趣使然的草帽路飞-CSDN博客 MYSQLMySQL explain 应用详解(吐血整理🤩) - SegmentFault 思否 实战彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表） - 云+社区 - 腾讯云 (tencent.com) 面试近期面试总结：秒杀设计、AQS 、synchronized相关问题_兴趣使然的草帽路飞-CSDN博客_aqs面试题","link":"/2022/02/23/%E6%9D%82%E7%83%A9/%E7%B2%BE%E9%80%89%E5%8D%9A%E6%96%87%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"},{"title":"蔚来一面面经","text":"面试 自我介绍 RPC（无语了= =，我更想面试官问第一个项目的） http和tcp区别（？确定不是udp吗） tcp三次握手，为什么不是两次四次 为什么要分OSI的7层，TCP的4层，有什么意义吗 为什么需要DNS？ 设计模式（为什么要，熟悉哪些，设计模式有哪些原则，该原则保证了什么。。） java springboot的作用？spring和springboot的区别？ spring如何加载配置文件的 spring bean的生命周期（还问了个为什么要了解这个？？？我内心：八股上说的） 线程，为什么要引入，有啥作用 mysql事务隔离级别，解决了什么问题 笔试 抢红包，要求均匀 发问 啥时候下一次通知 可以转正吗 对我有啥建议","link":"/2022/03/11/%E6%9D%82%E7%83%A9/%E8%94%9A%E6%9D%A5%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"},{"title":"阿里支付宝营销平台一面","text":"自我介绍 为什么第一志愿没有通过 项目介绍 项目表结构怎么样 如果redis宕机，导致扣减失败了怎么办 redis还能用在哪些场景中？ 多线程有用到吗？讲下线程池的参数 如何实现最终一致性的？ http状态码 口述两个队列实现一个栈 设计模式（抽象工厂） 单例模式的四种实现方式 有张表，字段为a，b，c，创建联合索引abc，问 where b = 3 and a &gt; 2 and c = 2会走索引吗？走了哪些 事务隔离级别 数据库特性 RPC和http的区别 netty是怎么用的呢 软问题。。。 笔试 ​ 火车站的最优排班。例如有10个火车进出站时间为【1，2】【3，4】【4，5】【6，7】【4，7】【1，7】【8，9】【9，10】【10，11】【11，12】 ​ 如果有别的火车在站中，则其他的不能进站。求出怎么让更多的火车在站中 ​ 没写出来。。想歪了，其实DFS就行，先按进站时间排序，然后每次固定一个火车在站，递归其他火车在站中的情况，最后取最优解即可。 总结 还是会紧张，还被面试官说了QAQ，被软问题问得有些懵了 最后问面试官建议时，得到了以下回复：1，不要忽视毛概，马克思这些课，学校开设就有他的意义，认真学学可以提高沟通能力和奖学金。2，提高软实力，和别人合作时要给其他人参与感，一起讨论，即使最后结果还是自己的答案。3，多刷题。","link":"/2022/03/22/%E6%9D%82%E7%83%A9/%E9%98%BF%E9%87%8C%E6%94%AF%E4%BB%98%E5%AE%9D%E8%90%A5%E9%94%80%E5%B9%B3%E5%8F%B0%E4%B8%80%E9%9D%A2/"},{"title":"阿里天猫国际一面凉经","text":"笔试 long 100/1000 手写单例 面试 自我介绍 基础知识和java的学习分配 c++和java区别 java为什么还搞自己的内存分配，有什么优势呢？ 上下文切换是如何记住状态的？ java中是如何识别重载，重写方法的? 你平常咋学习的 说下熟悉的源码 https和http区别 介绍下项目 说一下熟悉模块的设计 如何防止超卖 mysql索引为什么快 索引走几次io 知道java多态吗？java底层是怎么找到重载方法的? Java及JVM是如何识别重载、重写方法的? - 云+社区 - 腾讯云 (tencent.com) 总结失败总结 面试比较紧张，可能是第一次面试的缘故，但归根结底还是自己心里没底，很多知识掌握的不牢靠 不够重视基础，太过于依赖所谓的“八股文”了，以为网上面经+八股合集=基础，但其实基础更多体现在日积月累的代码编写当中，例如单例模式，如果光背光看别人代码，不自己去实现面试时也可能因为紧张写错 项目理解的不够，虽然项目是从网上找的，自己也跟着敲了一遍，但没有形成一个整体的思维架构 要多问为什么，面试被问到多态，只答了重载和重写，但被问到如何定位重载方法时，就不知道了，所以平时在学习时要多想，不要总是带有一种模糊的概念","link":"/2022/03/05/%E6%9D%82%E7%83%A9/%E9%98%BF%E9%87%8C%E5%A4%A9%E7%8C%AB%E5%9B%BD%E9%99%85%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/"},{"title":"dubbo从入门到实战","text":"1 互联网系统架构演变​ 随着互联网的发展，网站应用规模不断壮大，由此系统架构也在不断演变，下图是一张经典的演变过程图： 单一应用架构 ​ 优点：当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本 ​ 缺点：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护 ​ 此时：用于简化增删改查工作量的数据访问框架（ORM）是关键 垂直应用架构 ​ 优点：解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率 ​ 缺点：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。 ​ 此时：用于加速前端页面开发的Web框架（MVC）是关键 分布式应用架构（RPC） ​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心 ​ 此时：用于提高业务复用及整合的分布式服务框架（RPC）是关键 流动计算架构（SOA） ​ 随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架 ​ 此时，用于提高机器利用率**资源调度和治理中心(SOA)**是关键。 2 什么是Dubbo​ Dubbo是一个微服务开发框架，提供了RPC通信与微服务治理两大关键能力。它提供了远程过程调用的能力，使得远程调用像本地调用一样方便 ​ Dubbo提供的基础能力包括： 服务发现 流式通信 负载均衡 流量治理 集群容错 服务降级 … 3 Dubbo总体架构​ 以下是官网的一张图 节点 说明 Consumer 需要调用远程服务的服务消费方 Registry 注册中心 Provider 服务提供方 Container 服务运行的容器 Monitor 监控中心 ​ 通过上图，可以知道服务发现整体流程如下： 服务提供者Provider启动然后向注册中心注册自己所能提供的服务。 消费者Consumer启动向注册中心订阅所需的服务。 然后注册中心返回服务提供者地址列表给消费者Consumer，如果有变更，注册中心将基于长连接推送变更数据给消费者Consumer。 消费者Consumer就可以负载均衡选择一个Provier直接调用。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4 快速入门​ 新建两个Maven项目，JDK版本1.8，Dubbo版本2.7，一个消费者，一个提供者 引入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;groupId&gt;com.tiza.leo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo_001_p&lt;/artifactId&gt; &lt;!--引入依赖--&gt; &lt;dependencies&gt; &lt;!-- core context beans spring三件套--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo 2.5.3--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper zkclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 提供端代码 UserService 12345678package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} UserServiceImpl 12345678910111213package com.w1nd.dubbo.service;public class UserServiceImpl implements UserService { public String findName(String name) { System.out.println(&quot;姓名:&quot; +name); return &quot;hello: &quot;+name; } public void addUser(String username) { System.out.println(&quot;添加用户,用户名为: &quot;+username); }} spring-dubbo.xml（重要） 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过duboo发布服务 --&gt; &lt;dubbo:application name=&quot;dubbo_001_p&quot;&gt;&lt;/dubbo:application&gt; &lt;!--将服务注册到指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--指定服务的协议 和 使用端口号 注意此处服务端使用客户端无需使用 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt; &lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--注册服务到注册中心--&gt; &lt;dubbo:service interface=&quot;com.w1nd.dubbo.service.UserService&quot; ref=&quot;userService&quot; timeout=&quot;4000&quot;&gt; &lt;!--定义超时时间方二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:service&gt; &lt;!--服务提供者--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.w1nd.dubbo.service.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 测试代码 1234567891011121314151617package com.w1nd.dubbo.publish;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;import static org.junit.Assert.*;public class PublishServiceTest { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); System.out.println(&quot;服务提供者,开始提供服务.....&quot;); System.in.read(); }} 消费端代码 UserService 1234567package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} spring-dubbo.xml（重要） 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过dubbo消费服务--&gt; &lt;dubbo:application name=&quot;dubbo_001_c&quot;/&gt; &lt;!--指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--关闭所有服务的启动时检查 (没有提供者时报错)：--&gt; &lt;dubbo:consumer timeout=&quot;5000&quot; &gt;&lt;/dubbo:consumer&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--调用服务--&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.w1nd.dubbo.service.UserService&quot; timeout=&quot;4000&quot; &gt; &lt;!--定义超时时间方式二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:reference&gt; &lt;/beans&gt; 测试代码 12345678910111213141516package com.w1nd.dubbo.invoke;import com.w1nd.dubbo.service.UserService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class InvokeServiceTest { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.addUser(&quot;w1nd&quot;); /* String serverReturn = userService.findName(&quot;GouSheng&quot;); System.out.println(&quot;get message from server message is &quot; + serverReturn);*/ }} 5 集群​ 不同消费者的使用端口号设置不一样，即可。 dubbo_cluster_001_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_002_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_003_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20883&quot;&gt;&lt;/dubbo:protocol&gt; 参考(96条消息) 朋友国企干了5年java，居然不知道Dubbo是做什么呢？我真信了！_敖丙-CSDN博客 Dubbo3 简介 | Apache Dubbo","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/dubbo%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"},{"title":"zookeeper基本使用与集群搭建","text":"1. ZK简介​ 一个分布式的，开放源码的分布式应用程序协调服务。 2. ZK数据模型2.1 模型结构​ 2.2 模型的特点 每个子目录如/node1都被称作一个znode（节点）。这个znode是它所在的路径唯一标识 znode可以有子节点目录，并且每个znode可以存储数据 znode是有有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据 znode是可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端 3. 节点的分类3.1 持久节点（PERSISTENT）​ 指在节点创建后，就一直存在，知道有删除操作来主动删除这个节点–会因为创建该节点的客户端会话失效而消失 3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）​ 这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 3.3 临时节点（EPHEMERAL）​ 和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）​ 具有临时节点特点额外的特性是，每个父节点会为他的第一级子节点维护一份时序。这点和刚才提到的持久顺序节点类似 4. 安装4.1 linux系统安装 安装JDK 12tar -zxvf jdk-8u171-linux-x64.tar.gz mv ./jdk1.8.0_171/ /usr/java/ 12vim /etc/profilesource /etc/profile 安装ZK 1tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz 1cd conf/ 由于zk默认加载的是zoo.cfg，所以需要改名 1mv zoo_sample.cfg zoo.cfg 由于zookeeper加载要将节点加载到磁盘，所以需要预先新建一个磁盘目录 1mkdir /tmp/zookeeper 启动ZK 1234567[root@localhost bin]# ./zkServer.sh start /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg ZooKeeper JMX enabled by defaultUsing config: /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfgStarting zookeeper ... STARTED# 查看是否启动jps ​ QuorumPeerMain就是zk 连接ZK 1./zkCli.sh -server 192.168.9.3:2181 如果是本机，-server后可不加 5. 配置文件说明 tickTime：集群节点心跳时间， initLimit：初始化集群时集群节点同步超时时间20s syncLimit：集群在运行过程中，同步数据超时时间为10s（这里5是指5次心跳） dataDir：默认数据存储位置 clientPort：zk服务监听端口号 maxClientCnxns：线程池线程数量 6. 客户端基本指令 查看节点 1ls / # 根节点 创建节点 12345create path data # 创建一个节点，并给节点绑定数据（默认是持久性节点）- create path data # 持久节点- create -s path data # 持久性顺序节点- create -e path data # 临时性节点- create -e -s path data # 临时顺序节点 quit：会直接导致会话断开，会话失效，其他ctrl+c会导致触发倒计时 注：临时节点上不能创建任何节点 查看节点状态 1stat /node1 cZxid：创建事务ID ctime：创建时间 mZxid：修改ID mtime：修改时间 pZxid：父结点版本号 cversion：创建版本号 dataVersion：数据版本号 aclVersion： ephemerslOwner：是否是临时节点 dataLength：存储数据长度 numChildren：子节点数量 获得节点上绑定的数据信息 1get /node1 删除节点 1delete /node1 只能删除没有子节点的节点，如果有子节点，则无法删除 若想删除有子节点的，则需要deleteall 7. watch节点监听机制监听分为节点目录监听和节点数据监听 目录监听是监听节点目录的变化 数据监听是监听当前节点数据的变化 两种监听都是一次性的，也就是发现一个修改，下次修改则不会触发监听机制 目录监听 1ls -w /node 再次创建，无触发 数据监听 1get -w /node 8. Java操作ZK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.w1nd.test;import org.I0Itec.zkclient.IZkChildListener;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import org.I0Itec.zkclient.serialize.SerializableSerializer;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.data.Stat;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.List;public class TestZKClient { private ZkClient zkClient; // 1. 在zk创建节点 @Test public void testCreateNode() { // 1. 持久节点 zkClient.create(&quot;/node1&quot;, &quot;xiaochen&quot;, CreateMode.PERSISTENT); // 2. 持久顺序节点 zkClient.create(&quot;/node1/names&quot;, &quot;zhangsan&quot;, CreateMode.PERSISTENT_SEQUENTIAL); // 3. 临时节点 zkClient.create(&quot;/node1/lists&quot;, &quot;xiaoxiao&quot;, CreateMode.EPHEMERAL); // 4. 临时顺序节点 zkClient.create(&quot;/node1/lists1&quot;, &quot;xiaoming&quot;, CreateMode.EPHEMERAL_SEQUENTIAL); } // 2. 删除节点 @Test public void testDeleteNode() { // 删除没有子节点的节点，返回值：是否成功 boolean delete = zkClient.delete(&quot;/node1&quot;); // 递归删除节点信息，返回值：是否删除成功 boolean b = zkClient.deleteRecursive(&quot;/node1&quot;); } // 3. 查询当前节点下所有子节点 @Test public void testFindNodes() { // 获取指定路径的节点信息 List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;); for (String child : children) { System.out.println(child); } } // 4. 查看某个节点数据，注意：通过java客户端操作需要保证节点存储的数据和节点时序列化方式一致 // shell中的数据序列化方式和java中的不一致 @Test public void testFindNodeData() { Object readData = zkClient.readData(&quot;/node3&quot;); System.out.println(readData); } // 5. 查看节点状态信息 @Test public void testFindNodeDataAndStat() { Stat stat = new Stat(); Object readData = zkClient.readData(&quot;/node1&quot;, stat); System.out.println(readData); System.out.println(stat); } // 6. 修改节点数据 @Test public void testWriteData() { // User user = new User(); // user.setId(1); // zkClient.writeData(&quot;/node1&quot;, user); } // 监听节点数据的变化 @Test public void testOnNodeDataChange() throws IOException { zkClient.subscribeDataChanges(&quot;/node1&quot;, new IZkDataListener() { // 当节点数据变化时触发对应这个方法 @Override public void handleDataChange(String s, Object o) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); System.out.println(&quot;当前节点变化后数据：&quot; + o); } // 当前节点删除时触发这个方法 @Override public void handleDataDeleted(String s) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); } }); System.in.read(); // 阻塞当前监听 } // 监听节点目录的变化 @Test public void testOnNodesChange() throws IOException { zkClient.subscribeChildChanges(&quot;/node1&quot;, new IZkChildListener() { // 当节点的发生变化时，会自动调用这个方法 // 参数1：父节点名称 // 参数2：父节点中的所有子节点名称 @Override public void handleChildChange(String s, List&lt;String&gt; list) throws Exception { System.out.println(&quot;父节点名称：&quot; + s); System.out.println(&quot;发生变更后孩子节点名称：&quot;); for (String name: list) { System.out.println(name); } } }); System.in.read(); // 阻塞当前监听 } @Before public void before() { // 参数1：Server服务器ip地址 // 参数2：会话超时时间 // 参数3：连接超时时间 // 参数4：序列化方式 zkClient = new ZkClient(&quot;192.168.9.3:2181&quot;, 60000 * 30, 60000, new SerializableSerializer()); } @After // 释放资源 public void after() { zkClient.close(); } // 获取连接 public static void main(String[] args) { }} 9. ZK集群9.1 集群（cluster）​ 集群是指同一种软件服务的多个节点同时提供服务 ​ 集群解决了什么问题？ 单节点的并发访问的压力问题 单节点故障问题 9.2 集群架构 9.3 集群搭建 在~目录下新建三个文件夹 1mkdir zkdata1 zkdata2 zkdata3 建立myid文件 1touch zkdata1/myid zkdata2/myid zkdata3/myid 为每个zk指定id 123echo &quot;1&quot; &gt;&gt; zkdata1/myid echo &quot;2&quot; &gt;&gt; zkdata2/myid echo &quot;3&quot; &gt;&gt; zkdata3/myid 添加配置文件 12345678910111213vim zkdata1/zoo.cfgvim zkdata2/zoo.cfgvim zkdata3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/root/zkdata1clientPort=3001server.1=196.168.9.3:3002:3003server.2=192.158.9.3:4002:4003server.3=192.168.9.3:5002:5003 相关操作 12345678# 启动./bin/zkServer.sh start /root/zkdata1/zoo.cfg./bin/zkServer.sh start /root/zkdata2/zoo.cfg./bin/zkServer.sh start /root/zkdata3/zoo.cfg# 查看状态./bin/zkServer.sh status /root/zkdata1/zoo.cfg# 停止./bin/zkServer.sh stop /root/zkdata1/zoo.cfg","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"美团3-12笔试","text":"T1​ 输入n个数字，判断每个数字满足以下两个条件之一：是11的倍数数位里面1的个数大于等于2，如果满足输入yes，否则输出no 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;bool check(int x) { if (x % 11 == 0) return true; else { int cnt = 0; while (x) { int t = x % 10; if (t == 1) cnt ++; x /= 10; } return cnt &gt;= 2; }}int main() { int n; scanf(&quot;%d&quot;, &amp;n); while (n --) { int x; scanf(&quot;%d&quot;, &amp;x); if (check(x)) printf(&quot;yes\\n&quot;); else printf(&quot;no\\n&quot;); } return 0;} T2​ 输入n(0&lt;n&lt;1000)个数字，每个数字可能是1或者是-1，问连续的序列的乘积是正数的数有多少个？ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;/** * 为了使序列的乘积为正数，那么-1的个数一定要是偶数个，所以我们将输入的-1转换为1，输入的1转换为0 * 然后就可以利用前缀和先预处理然后O(1)地求出每段的-1的个数啦。 * @return */int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; sum(n + 1, 0); for (int i = 0; i &lt; n; ++i) { int x; cin &gt;&gt; x; if (x == -1) x = 1; else x = 0; sum[i] = sum[i - 1] + x; } int ans = 0; for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; i; ++j) { int tmp = sum[i] - sum[j]; if (tmp % 2 == 0) ans ++; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} T3​ n个顾客点餐，每个顾客可以点两份餐，数据保证点的餐的种类在1-m，但是饭店现在只可以提供一份1-m种类的餐各一份。 ​ 问最多可以满足多少位顾客的点餐需求。（0&lt;n&lt;20) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;void dfs(int u, int sum);using namespace std;const int N = 25, M = 45;int q[N][2], cnt;int st[N], full[M];int res = 0;int n, m;int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; q[i][0] &gt;&gt; q[i][1]; for (int i = 1; i &lt;= m; ++i) full[i] = 1; cnt = m / 2; // 最多可以满意的顾客数 dfs(0, 0); cout &lt;&lt; res &lt;&lt; endl;}// 当前顾客号，已选人数void dfs(int u, int sum) { if (sum &lt;= cnt) res = max(res, sum); else return; for (int i = u; i &lt; n; ++i) { int x1 = q[i][0], x2 = q[i][1]; if (full[x1] == 0 || full[x2] == 0) continue; full[x1] --, full[x2] --; sum ++; dfs(u + 1, sum); sum --; full[x1] ++, full[x2] ++; }} T4​ n个房间（0&lt;n&lt;=10)，初始的时候A在第一个房间，现在有一个游戏，游戏时长为m（0&lt;m&lt;=10000)秒，给出m 秒每秒的炸弹所在的房间，A需要在每秒避开这些炸弹，也就是A不能在有炸弹的房间。A可以在每秒后选择移动到n个房间中的一个，但是需要消耗1个能量，当然也可以不移动，问A最少需要消耗多少能量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by 86139 on 2022/3/12.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 10010;int dp[N][13];int q[N];/**2 42 1 1 22 */int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) { scanf(&quot;%d&quot;, &amp;q[i]); } // dp[i][j] 表示 第i秒在第j个房间的最小消耗 memset(dp, 0x3f, sizeof dp); dp[1][1] = 0; //第1秒肯定没有消耗 for (int i = 2; i &lt;= n; ++i) dp[1][i] = 1; for (int i = 2; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) if (q[i] != j) { // 第 i 秒肯定不能选a[i]这个房间 for (int k = 1; k &lt;= n; ++k) { if (j != k) dp[i][j] = min(dp[i][j], dp[i - 1][k] + 1); else dp[i][j] = min(dp[i][j], dp[i - 1][k]); } } int res = 1e9; for (int i = 1; i &lt;= n; ++i) { res = min(res, dp[m][i]); } printf(&quot;%d\\n&quot;, res);} T5​ 首先输入一个数n(0&lt;n&lt;100000)，表示树的结点的个数，然后输入n个数表示每个结点的颜色，0表示白色，1表示黑色。 接下来输入n个数，表示第i个结点的父节点，如果是0就表示这个结点时根节点。 ​ 然后，对于白色结点，如果他的子节点中存在一个黑色结点或者它是叶子结点，那么他就是好结点；对于黑色结点，如果它的所有子节点都是白色或者它是叶子结点，那么它就是好结点。 ​ 问，树里面白色好结点和黑色好结点的个数。","link":"/2022/03/15/%E7%AC%94%E8%AF%95/%E7%BE%8E%E5%9B%A23-12%E7%AC%94%E8%AF%95/"},{"title":"阿里3.14笔试","text":"T1题目大意：给出一个16进制的字符串，要求统计其二进制表示中1的个数len &lt;= 2*10^5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// Created by 86139 on 2022/3/14.//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;cmath&gt;using namespace std;/* * 0xeeeeedddddccccc11111 * 45 * */using namespace std;unordered_map&lt;char, int&gt; map;int main() { map['0'] = 0; map['1'] = 1; map['2'] = 1; map['3'] = 2; map['4'] = 1; map['5'] = 2; map['6'] = 2; map['7'] = 3; map['8'] = 1; map['9'] = 2; map['a'] = 2; map['b'] = 3; map['c'] = 2; map['d'] = 3; map['e'] = 3; map['f'] = 4; string s; cin &gt;&gt; s; int ans = 0; for (int i = 2; i &lt; s.size(); ++i) { cout &lt;&lt; s[i] &lt;&lt; ' '; ans += map[s[i]]; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} T2题目大意：给出大小为n ∗ m 的01矩阵，从每个0的位置上下左右看，问所有在位置上下左右看一共能看到多少个1.(视线是一条直线)n,m&lt;=1e3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Created by 86139 on 2022/3/14.//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 1010;int q[N][N], l[N][N], r[N][N], u[N][N], d[N][N];int n, m;/*2 40 1 0 01 0 1 0 * */int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) cin &gt;&gt; q[i][j]; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) { l[i][j] = l[i][j - 1] | q[i][j]; u[i][j] = u[i - 1][j] | q[i][j]; } for (int i = n; i &gt;= 1; --i) for (int j = m; j &gt;= 1; --j) { r[i][j] = r[i][j + 1] | q[i][j]; d[i][j] = d[i + 1][j] | q[i][j]; } int res = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { if (!q[i][j]) res += l[i][j] + r[i][j] + u[i][j] + d[i][j]; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} T3​ 题目大意：你有一个8*8的棋盘，每个格子上的棋有rgb三种状态，你在上面玩消消乐(可能不是?)，每次选一个格子，将它的连通块全部消掉。消掉之后还指定了一种方向让所有棋子向一个方向下落。还有一种填充棋子的方法，需要你模拟这个过程(输出每次消除的棋子个数)。opt &lt; = 10000 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//// Created by 86139 on 2022/3/14.///* *2rbbbrrrbggggbrbrrrrggbrrgbrgbrrrbgbgrrrgbgbgbrrbrggrggggbgbrgrgrbbrgggggbbgbbbrgbbgbrgbgbbgbbbrgbrgbgbbggbbgbbbrgbbgbbbrggrbbgrbbgrbbrgggrbrgbrrbrgbrgbrgrgbrgbrbrbbrbbbrbrrggrgggrbrgbgbrgggrbr1 5 w1 4 d *47 * */#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 10010;int n, m;int cnt;char g[15][15];string s[15];int v[15][15];int nw[15]; // 用于标记某行某列的元素适用情况int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};void dfs(int x, int y);int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= 8; ++i) for (int j = 1; j &lt;= 8; ++j) cin &gt;&gt; g[i][j]; for (int i = 1; i &lt;= 8; ++i) cin &gt;&gt; s[i]; while (n --) { int x, y; char op; cin &gt;&gt; x &gt;&gt; y &gt;&gt; op; for (int i = 1; i &lt;= 8; ++i) for (int j = 1; j &lt;= 8; ++j) v[i][j] = 0; cnt = 0; dfs(x, y); printf(&quot;%d\\n&quot;, cnt); if (op == 'w') { for (int j = 1; j &lt;= 8; ++j) { // 遍历每一列 vector&lt;char&gt; tmp; tmp.clear(); for (int i = 1; i &lt;= 8; ++i) if (!v[i][j]) tmp.push_back(g[i][j]); // 将该列未标记的元素添加到tmp for (int i = 0; i &lt; tmp.size(); ++i) g[i + 1][j] = tmp[i]; // 填充到上一列 for (int i = tmp.size() + 1; i &lt;= 8; ++i) g[i][j] = s[j][nw[j] ++]; // 填补下面的空格，s[j][nw[j]++]表示第j行的第nw[j]个元素 } } else if (op == 's') { for (int j = 1; j &lt;= 8; ++j) { vector&lt;char&gt; tmp; tmp.clear(); for (int i = 1; i &lt;= 8; ++i) if (!v[i][j]) tmp.push_back(g[i][j]); for (int i = 8, k = tmp.size() - 1; k &gt;= 0; --i, --k) g[i][j] = tmp[k]; for (int i = 8 - tmp.size(); j &gt;= 1; --j) g[i][j] = s[j][nw[j]++]; } } else if (op == 'a') { for (int i = 1; i &lt;= 8; ++i) { vector&lt;char&gt; tmp; tmp.clear(); for (int j = 1; j &lt;= 8; ++j) if (!v[i][j]) tmp.push_back(g[i][j]); for (int j = 0; j &lt; tmp.size(); ++j) g[i][j + 1] = tmp[j]; for (int j = tmp.size() + 1; j &lt;= 8; ++j) g[i][j] = s[i][nw[i]++]; } } else if (op == 'd') { for (int i = 1; i &lt;= 8; ++i) { vector&lt;char&gt; tmp; tmp.clear(); for (int j = 1; j &lt;= 8; ++j) if (!v[i][j]) tmp.push_back(g[i][j]); for (int j = 8, k = tmp.size() - 1; k &gt;= 0; --j, --k) g[i][j] = tmp[k]; for (int j = 8 - tmp.size(); j &gt;= 1 ; --j) g[i][j] = s[i][nw[i]++]; } } } return 0;}// 标记连通块void dfs(int x, int y) { v[x][y] = 1; cnt ++; for (int i = 0; i &lt; 4; ++i) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 1 || nx &gt; 8 || ny &lt; 1 || ny &gt; 8 || v[nx][ny] || g[x][y] != g[nx][ny]) continue; dfs(nx, ny); }}","link":"/2022/03/14/%E7%AC%94%E8%AF%95/%E9%98%BF%E9%87%8C3-14%E7%AC%94%E8%AF%95/"},{"title":"创建式：单例模式","text":"1 基本介绍​ 单例模式简单来说就是不用创建多个实例 ​ 单例模式有三个要点： 某个类只能有一个实例 它必须自行创建这个实例 必须自行向整个系统提供这个实例 ​ 这是最简单的设计模式，核心结构只有一个包含称为单例类的特殊类 ​ 下面就直接看看单例的几种实现方式把 2 设计分析2.1 饿汉式单例1234567891011121314151617181920212223242526package DesignPatterns.ShangGuiGu.singleton.type1;public class SingletonTest01 { public static void main(String[] args) { Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); }}// 饿汉式（静态变量）class Singleton { // 1. 构造器私有化 private Singleton() { } // 2. 本类内部创建对象实例 private final static Singleton instance = new Singleton(); // 3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; }} 2.2 懒汉式单例（线程不安全）1234567891011121314151617181920212223242526package DesignPatterns.ShangGuiGu.singleton.type3;public class SingletonTest03 { public static void main(String[] args) { Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); }}class Singleton { private static Singleton instance; private Singleton() {} // 提供一个静态的公有方法，当使用到该方法时，才去创建 instance // 即懒汉式 public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 2.3 懒汉式单例（线程安全DCL）✨123456789101112131415161718192021222324package DesignPatterns.ShangGuiGu.singleton.test.test3;/** * DCL */public class A { public static void main(String[] args) { B b1 = B.getSingleton(); B b2 = B.getSingleton(); System.out.println(b1 == b2); }}class B { private volatile static B b; public static B getSingleton() { if (b == null) { synchronized (B.class) { b = new B(); } } return b; }} ​ 其实可以直接在方法上加锁保证线程安全，但这样导致系统性能降低，使用双重检查锁机制更加适合。注意，这里要使用volatile关键字，volatile关键字会屏蔽Java虚拟机所做的一些代码优化。 2.4 IoDH✨123456789101112131415161718package DesignPatterns.ShangGuiGu.singleton;public class Singleton { private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } public static void main(String[] args) { Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println(s1 == s2); }} ​ 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 ​ 通过IoDH,既可以实现延迟加载，还可以保证线程安全，不影响系统性能，是最好的实现方式 3 总结优缺点分析 优点： 单例模式提供了对唯一实例的受控访问 节约系统资源 允许可变数目的实例 缺点： 没有抽象层，因此单例类的扩展有很大的困难 单例类的职责过重，在一定程度上违背了“单一职责原则” 如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 适用场景 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 4 场景使用4.1 Spring中的单例模式​ Spring的依赖注入（包括lazy-init方式）都是发生在 AbstractBeanFactory 的 getBean 里。 getBean 的 doGetBean 方法调用 getSingleton 进行bean的创建。lazy-init方式(lazy-init=“true”)，在用户向容器第一次索要bean时进行调用；非lazy-init方式(lazy-init=“false”)，在容器初始化时候进行调用。 ​ 同步线程安全的单例核心代码： 1234567891011121314151617181920212223242526272829303132333435public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { // 通过 Map 实现单例注册表 private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(64); public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) { Assert.notNull(beanName, &quot;'beanName' must not be null&quot;); synchronized (this.singletonObjects) { // 检查缓存中是否存在实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { // ...忽略代码 try { singletonObject = singletonFactory.getObject(); } catch (BeanCreationException ex) { // ...忽略代码 } finally { // ...忽略代码 } // 如果实例对象在不存在，我们注册到单例注册表中。 addSingleton(beanName, singletonObject); } return (singletonObject != NULL_OBJECT ? singletonObject : null); } } protected void addSingleton(String beanName, Object singletonObject) { synchronized (this.singletonObjects) { this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT)); } }} ​ Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap对象。 ​ 使用该方式的原因是方便继承。单例注册表的构造函数是protected，可以继承。 参考Java 静态内部类的加载时机 - は問わない - 博客园 (cnblogs.com) (28 封私信) 为什么Spring使用注册表来实现单例模式？ - 知乎 (zhihu.com)–木木甫回答","link":"/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"创建式：原型模式","text":"1 基本介绍​ 原型模式大概是：创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象 ​ 工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。 ​ 通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的 ​ 2 设计分析2.1 栗子​ 使用原型模式来实现工作周报的快速创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package DesignPatterns.JavaDesign.Prototype;public class Test { public static void main(String args[]) { WeeklyLog log_previous = new WeeklyLog(); //创建原型对象 log_previous.setName(&quot;张无忌&quot;); log_previous.setDate(&quot;第12周&quot;); log_previous.setContent(&quot;这周工作很忙，每天加班！&quot;); System.out.println(&quot;****周报****&quot;); System.out.println(&quot;周次：&quot; + log_previous.getDate()); System.out.println(&quot;姓名：&quot; + log_previous.getName()); System.out.println(&quot;内容：&quot; + log_previous.getContent()); System.out.println(&quot;--------------------------------&quot;); WeeklyLog log_new; log_new = log_previous.clone(); //调用克隆方法创建克隆对象 log_new.setDate(&quot;第13周&quot;); System.out.println(&quot;****周报****&quot;); System.out.println(&quot;周次：&quot; + log_new.getDate()); System.out.println(&quot;姓名：&quot; + log_new.getName()); System.out.println(&quot;内容：&quot; + log_new.getContent()); System.out.println(log_previous == log_new); System.out.println(log_previous.getDate() == log_new.getDate()); System.out.println(log_previous.getName() == log_new.getName()); System.out.println(log_previous.getContent() == log_new.getContent()); }}class WeeklyLog implements Cloneable { private String name; private String date; private String content; public void setName(String name) { this.name = name; } public void setDate(String date) { this.date = date; } public void setContent(String content) { this.content = content; } public String getName() { return (this.name); } public String getDate() {return (this.date); } public String getContent() { return (this.content); } //克隆方法clone()，此处使用Java语言提供的克隆机制 public WeeklyLog clone() { Object obj = null; try { obj = super.clone(); return (WeeklyLog)obj; }catch(CloneNotSupportedException e) { System.out.println(&quot;不支持复制！&quot;); return null; } }} 2.2 浅拷贝与深拷贝浅拷贝 ​ 在浅克隆中： 如果原型对象的成员变量是值类型，将复制一份给克隆对象； 如果原型对象的 成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。 深拷贝 ​ 在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象 2.3 原型管理器​ 原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。 ​ 下面模拟一个简单的公文管理器来介绍原型管理器的设计与实现 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package DesignPatterns.JavaDesign.Prototype;import java.util.Hashtable;public class Test1 { public static void main(String[] args) { //获取原型管理器对象 PrototypeManager pm = PrototypeManager.getPrototypeManager(); OfficialDocument doc1,doc2,doc3,doc4; doc1 = pm.getOfficialDocument(&quot;far&quot;); doc1.display(); doc2 = pm.getOfficialDocument(&quot;far&quot;); doc2.display(); System.out.println(doc1 == doc2); doc3 = pm.getOfficialDocument(&quot;srs&quot;); doc3.display(); doc4 = pm.getOfficialDocument(&quot;srs&quot;); doc4.display(); System.out.println(doc3 == doc4); }}//抽象公文接口，也可定义为抽象类，提供clone()方法的实现，将业务方法声明为抽象方法interface OfficialDocument extends Cloneable { public OfficialDocument clone(); public void display();}//可行性分析报告(Feasibility Analysis Report)类class FAR implements OfficialDocument { public OfficialDocument clone() { OfficialDocument far = null; try { far = (OfficialDocument) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(&quot;不支持复制！&quot;); } return far; } public void display() { System.out.println(&quot;《可行性分析报告》&quot;); }}//软件需求规格说明书(Software Requirements Specification)类class SRS implements OfficialDocument { public OfficialDocument clone() { OfficialDocument srs = null; try { srs = (OfficialDocument)super.clone(); }catch(CloneNotSupportedException e) { System.out.println(&quot;不支持复制！&quot;); } return srs; } public void display() { System.out.println(&quot;《软件需求规格说明书》&quot;); }}//原型管理器（使用饿汉式单例实现）class PrototypeManager { //定义一个Hashtable，用于存储原型对象 private Hashtable ht=new Hashtable(); private static PrototypeManager pm = new PrototypeManager(); //为Hashtable增加公文对象 private PrototypeManager() { ht.put(&quot;far&quot;,new FAR()); ht.put(&quot;srs&quot;,new SRS()); } //增加新的公文对象 public void addOfficialDocument(String key,OfficialDocument doc) { ht.put(key,doc); } //通过浅克隆获取新的公文对象 public OfficialDocument getOfficialDocument(String key) { return ((OfficialDocument)ht.get(key)).clone(); } public static PrototypeManager getPrototypeManager() { return pm; }} ​ 在PrototypeManager中定义了一个Hashtable类型的集合对象，使用“键值对”来存储原型对象，客户端可以通过Key（如“far”或“srs”）来获取对应原型对象的克隆对象。 3 总结优缺点分析 优点： 通过复制一个已有实例可以提高新实例的创建效率 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响 可以使用深克隆的方式保存对象的状态 缺点： 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则 实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 适用场景 创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态","link":"/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"创建式：工厂方法","text":"1 基本介绍​ 简单工厂方法模式由于每次引入新产品时，都需要通过传入参数的不同来创建不同的产品，这必定要修改工厂类的代码，违反了“开闭原则” ​ 从而出现了——工厂方法模式，就是解决该问题的 ​ 工厂方法中，不再提供统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂。 ​ 一般是定义一个用于创建对象的接口，让子类决定将哪一个类实例化。如下图 2 设计分析2.1 简单工厂设计​ 通过栗子来理解把，现在某公司要设计一个系统运行日志记录器，用户可以通过修改配置文件更改日志记录方式，那么如何设计记录器的初始化和更改日志记录方式将会是一大难点。使用简单工厂模式设计如下 ​ 这时候，LoggerFactory代码大概为这样： 12345678910111213141516171819202122//日志记录器工厂class LoggerFactory { // 静态工厂方法 public static Logger createLogger( string args){ if(args.equalsIgnoreCase ( &quot;db&quot;)) { //连接数据库﹐代码省略 //创建数据库日志记录器对象 Logger logger : new DatabaseLogger( );//初始化数据库日志记录器﹐代码省略 return logger; } else if(args.equalsignorecase( &quot;file&quot; )) { //创建日志文件 //创建文件日志记录器对象 Logger logger = new FileLogger ( );//初始化文件日志记录器﹐代码省略 return logger; } else { return null; } }} ​ 这样设计问题很大，包含大量的if...else...代码，维护和测试难度增大，并且系统扩展不灵活 2.2 工厂方法设计​ 使用工厂方法设计日志记录器，将会变成下面这样 ​ 代码大概如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package DesignPatterns.JavaDesign.FactoryMethod;// 编写如下客户端测试代码∶public class Test { public static void main(String args[]) { LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); //可引入配置文件实现 // factory = (LoggerFactory) XMLUtil.getBean(); logger = factory.createLogger(); logger.writeLog( ); }}// 日志记录器接口︰抽象产品interface Logger { public void writeLog();}// 数据库日志记录器︰具体产品class DatabaseLogger implements Logger { public void writeLog() { System.out.println(&quot;数据库日志记录。&quot;); }}// 文件日志记录器∶具体产品class FileLogger implements Logger { public void writeLog() { System.out.println( &quot;文件日志记录。&quot;); }}// 日志记录器工厂接口︰抽象工厂interface LoggerFactory { public Logger createLogger();}// 数据库日志记录器工厂类∶具体工厂class DatabaseLoggerFactory implements LoggerFactory { public Logger createLogger() { //连接数据库﹐代码省略//创建数据库日志记录器对象 Logger logger = new DatabaseLogger();//初始化数据库日志记录器﹐代码省略 return logger; }}// 文件日志记录器工厂类∶具体工厂class FileLoggerFactory implements LoggerFactory { public Logger createLogger() { //创建文件日志记录器对象 Logger logger = new FileLogger( );//创建文件·代码省略 return logger; }} 添加xml配置文件优化xml文件 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;DesignPatterns.JavaDesign.FactoryMethod.DatabaseLoggerFactory&lt;/className&gt;&lt;/config&gt; 读取xml工具类 123456789101112131415161718192021222324252627282930313233package DesignPatterns.JavaDesign.FactoryMethod;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;public class XMLUtil { // 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() { try { DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/resources/config.xml&quot;)); // 获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class&lt;?&gt; c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } }} 修改客户端代码 1234567891011// 编写如下客户端测试代码∶public class Test { public static void main(String args[]) { LoggerFactory factory; Logger logger; // factory = new FileLoggerFactory(); //可引入配置文件实现 factory = (LoggerFactory) XMLUtil.getBean(); logger = factory.createLogger(); logger.writeLog( ); }} 2.3 其他重载的工厂方法 ​ 通过多种方式初始化日志记录器，例如可以提供默认实现，传入文件路径，或将参数封装在一个Object类型的对象中 工厂方法的隐藏 ​ 有时候需要对工厂方法函数进行隐藏 ​ 修改后的代码大致如下 1234567891011121314151617//改为抽象类abstract class LoggerFactory { //在工厂类中直接调用日志记录器类的业务方法writeLog () public void writeLog () { Logger logger = this.createLogger( );logger.writeLog (); } public abstract Logger createLogger(); ...}class client { public static void main( String args[]){ LoggerFactory factory; factory = (LoggerFactory )XMLUtil.getBean( ); factory.writeLog( ); //直接使用工厂对象来调用产品对象的业务方法 }} 3 总结优缺点分析 优点： 工厂方法用来创建客户所需的产品，同时隐藏了哪种具体产品类被实例化这一细节，用户只需关心产品对应的工厂，甚至都无需知道具体产品类的类名 加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，只需要添加一个具体工厂和具体产品就可以了。提高了系统的可扩展性，符合可扩展性 缺点： 添加新产品时需要添加对应工厂类和产品，类的个数成对增长，在一定程度上增加了系统复杂度 引入了抽象层，增加了系统的抽象和理解难度。且实现可能要用到DOM，反射技术，增加系统实现难度 使用场景 客户端不需要知道具体产品类的类名，只需要知道对应的工厂即可 抽象工厂类通过其子类来指定创建哪个对象 4 场景使用4.1 Factory实例化Bean​ FactoryBean是Spring容器提供的一种可以扩展容器对象实例化逻辑的接口，不要与容器BeanFacoty相混淆 ​ FactoryBean，其主语是Bean,定语是Factory，也就是说，它本身与其他注册到容器的对象一样，只是一个Bean而已，只不过这里类型的Bean本身就是生产对象的工厂。 ​ 当使用该工厂Bean时需要实现三个方法 123456789101112/* 该方法返回该FactoryBean“生产”的对象。我们需要实现该方法以给出自己对象实例化逻辑 */public String getObject() throws Exception;/** 该方法仅返回getObject()方法所返回的对象的类型。如果预先无法确定,则返回null*/public Class&lt;?&gt; getObjectType();/* 该方法返回结果用于表明,getObject()“生产”的对象是否要以singleton(单例)形式存于容器中。如果以singleton形式存在,则返回true，否则返回false*/public boolean isSingleton(); 测试 12345678910111213141516171819202122232425262728293031323334353637package DesignPatterns.JavaDesign.FactoryMethod;import org.springframework.beans.factory.FactoryBean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); String bean = (String) context.getBean(&quot;bean&quot;); System.out.println(bean); }}class nameFactoryBean&lt;T&gt; implements FactoryBean&lt;String&gt; { //该方法返回该FactoryBean“生产”的对象 //我们需要实现该方法以给出自己对象实例化逻辑 @Override public String getObject() throws Exception { return new String(&quot;w1nd&quot;); } //该方法仅返回getObject()方法所返回的对象的类型 //如果预先无法确定,则返回null @Override public Class&lt;?&gt; getObjectType() { return null; } //该方法返回结果用于表明,getObject()“生产”的对象是否要以singleton(单例)形式存于容器中 //如果以singleton形式存在,则返回true，否则返回false @Override public boolean isSingleton() { return false; }} 配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- FactoryBean实例化Bean --&gt; &lt;bean id=&quot;bean&quot; class=&quot;DesignPatterns.JavaDesign.FactoryMethod.nameFactoryBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 参考《Java设计模式》——刘伟 (108条消息) 创建对象与使用对象——谈谈工厂的作用_刘伟技术博客-CSDN博客 (109条消息) Spring 工厂方法与FactoryBean(实例化Bean)_浅然的专栏-CSDN博客_spring 工厂bean","link":"/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"},{"title":"创建式：抽象工厂","text":"1 基本介绍​ 前面介绍过，工厂方法每个工厂只能生产一个产品，会导致系统存在大量的工厂类，增加系统的开销。此时，可以将一些相关的产品组成一个“产品族”，由同一个工厂来生产。这就是抽象工厂的基本思想。 ​ 也就是说，一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，可以生产电视机，冰箱，空调等。 引入两个概念 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 ​ 我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。 ​ 抽象工厂模式通常是用于创建不同产品等级结构的一个产品族中的所有对象 2 设计分析​ 开发一套界面皮肤库，皮肤库代码不打算公开，用户通过菜单选择皮肤，不同皮肤提供不同按钮，文本框等 2.1 工厂方法设计 ​ 可以发现，该设计存在如下问题 虽然增加类时不需要修改原有代码，可是要增加大量类，导致系统越来越庞大 每个组件都需要选择一个具体工厂，选择失误很容易导致界面显示混乱 2.2 抽象工厂设计 代码大概如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package DesignPatterns.JavaDesign.AbstractFactory;import DesignPatterns.JavaDesign.FactoryMethod.XMLUtil;public class Test { public static void main(String[] args) { //使用抽象层定义 SkinFactory factory; Button bt; TextField tf; ComboBox cb; // 可以改为使用配置文件 factory = new SummerSkinFactory(); bt = factory.createButton(); tf = factory.createTextField(); cb = factory.createComboBox(); bt.display(); tf.display(); cb.display(); }}/** * 按钮接口：抽象产品 */interface Button { public void display();}// Spring按钮类：具体产品class SpringButton implements Button { @Override public void display() { System.out.println(&quot;显示浅绿色按钮。&quot;); }}class SummerButton implements Button { @Override public void display() { System.out.println(&quot;显示浅蓝色按钮&quot;); }}/** * 文本框接口∶抽象产品 */interface TextField { public void display();}// Spring文本框类∶具体产品class SpringTextField implements TextField { public void display() { System.out .println( &quot;显示绿色边框文本框。&quot;); }}// Summer文本框类∶具体产品class SummerTextField implements TextField { public void display() { System.out .println ( &quot;显示蓝色边框文本框。&quot;); }}/** * 组合框接口∶抽象产品 */interface ComboBox { public void display( );}// Spring组合框类∶具体产品class SpringComboBox implements ComboBox { public void display() { System.out.println( &quot;显示绿色边框组合框。&quot;); }}// Summer组合框类︰具体产品class SummerComboBox implements ComboBox { public void display() { System.out.println ( &quot;显示蓝色边框组合框。&quot;); }}/** * 界面皮肤工厂接口∶抽象工厂 */interface SkinFactory { public Button createButton(); public TextField createTextField (); public ComboBox createComboBox();}// Spring皮肤工厂：具体工厂class SpringSkinFactory implements SkinFactory { public Button createButton( ) { return new SpringButton( ); } public TextField createTextField() { return new SpringTextField (); } public ComboBox createComboBox(){ return new SpringComboBox( ); }}// Summer皮肤工厂：具体工厂class SummerSkinFactory implements SkinFactory { public Button createButton() { return new SummerButton(); } public TextField createTextField() { return new SummerTextField(); } public ComboBox createComboBox() { return new SummerComboBox(); }} ​ 如果需要更改皮肤，只需修改配置文件即可。 3 总结优缺点分析 优点： 隔绝了具体类的生成 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点： 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。 适用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节 系统中有多于一个的产品族，而每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用 产品等级结构稳定 4 场景使用4.1 BeanFactory在Spring中的使用​ 在 Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是 BeanFactory 的子类。这样我们可以通过 IOC 容器来管理访问 Bean，根据不同的策略调用 getBean() 方法，从而获得具体对象。 ​ BeanFactory 接口的源码如下 12345678910111213141516public interface BeanFactory { String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name);} `BeanFactory`的子类主要有 `ClassPathXmlApplicationContext`、`XmlWebApplicationContext`、`StaticWebApplicationContext`、`StaticApplicationContext`。在 Spring 中，`DefaultListableBeanFactory`实现了所有工厂的公共逻辑。 参考《Java设计模式》——刘伟 (109条消息) 抽象工厂模式在spring源码中的应用_蒙奇D灬小武的博客-CSDN博客_抽象工厂模式在spring的应用","link":"/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"title":"创建式：建造者模式","text":"1 基本介绍​ 建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。 ​ 定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 ​ 建造者模式和抽象工厂模式的不同： 建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品 在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导Director类如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回 ​ 举个例子，如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。 2 设计分析​ 使用建造者模式来实现游戏角色的创建 ​ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package DesignPatterns.JavaDesign.Builder;import DesignPatterns.JavaDesign.FactoryMethod.XMLUtil;public class Test { public static void main(String[] args) { ActorBuilder ab; //针对抽象建造者编程 ab = new AngelBuilder(); //反射生成具体建造者对象 ActorController ac = new ActorController(); Actor actor; actor = ac.construct(ab); //通过指挥者创建完整的建造者对象 String type = actor.getType(); System.out.println(type + &quot;的外观：&quot;); System.out.println(&quot;性别：&quot; + actor.getSex()); System.out.println(&quot;面容：&quot; + actor.getFace()); System.out.println(&quot;服装：&quot; + actor.getCostume()); System.out.println(&quot;发型：&quot; + actor.getHairstyle()); }}class Actor { private String type; //角色类型 private String sex; //性别 private String face; //脸型 private String costume; //服装 private String hairstyle; //发型 public void setType(String type) { this.type = type; } public void setSex(String sex) { this.sex = sex; } public void setFace(String face) { this.face = face; } public void setCostume(String costume) { this.costume = costume; } public void setHairstyle(String hairstyle) { this.hairstyle = hairstyle; } public String getType() { return (this.type); } public String getSex() { return (this.sex); } public String getFace() { return (this.face); } public String getCostume() { return (this.costume); } public String getHairstyle() { return (this.hairstyle); }}//角色建造器：抽象建造者abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); //工厂方法，返回一个完整的游戏角色对象 public Actor createActor() { return actor; }}//英雄角色建造器：具体建造者class HeroBuilder extends ActorBuilder { public void buildType() { actor.setType(&quot;英雄&quot;); } public void buildSex() { actor.setSex(&quot;男&quot;); } public void buildFace() { actor.setFace(&quot;英俊&quot;); } public void buildCostume() { actor.setCostume(&quot;盔甲&quot;); } public void buildHairstyle() { actor.setHairstyle(&quot;飘逸&quot;); }}//天使角色建造器：具体建造者class AngelBuilder extends ActorBuilder { public void buildType() { actor.setType(&quot;天使&quot;); } public void buildSex() { actor.setSex(&quot;女&quot;); } public void buildFace() { actor.setFace(&quot;漂亮&quot;); } public void buildCostume() { actor.setCostume(&quot;白裙&quot;); } public void buildHairstyle() { actor.setHairstyle(&quot;披肩长发&quot;); }}//恶魔角色建造器：具体建造者class DevilBuilder extends ActorBuilder { public void buildType() { actor.setType(&quot;恶魔&quot;); } public void buildSex() { actor.setSex(&quot;妖&quot;); } public void buildFace() { actor.setFace(&quot;丑陋&quot;); } public void buildCostume() { actor.setCostume(&quot;黑衣&quot;); } public void buildHairstyle() { actor.setHairstyle(&quot;光头&quot;); }}//游戏角色创建控制器：指挥者class ActorController { //逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); actor = ab.createActor(); return actor; }} ​ 在建造者模式中，客户端只需实例化指挥者类，指挥者类针对抽象建造者编程，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品。 ​ 在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。 3 总结优缺点分析 优点： 将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者 可以更加精细地控制产品的创建过程 缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本 适用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性 需要生成的产品对象的属性相互依赖，需要指定其生成顺序 对象的创建过程独立于创建该对象的类 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品","link":"/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%BC%8F%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"结构式：代理模式","text":"","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"title":"结构式：外观模式","text":"1 基本介绍​ 外观模式是使用频率非常高的结构式设计模式。定义如下：为子系统中一组接口提供一个统一的入口，外部与其内部的通信通过一个统一的外观类进行。 2 代码框架1234567891011121314151617181920212223242526272829303132333435class SubSystemA { public void MethodA() { // 业务代码 }}class SubSystemB { public void MethodB() { // 业务代码 }}class SubSystemC { public void MethodC() { // 业务代码 }}class Facade { private SubSystemA obj1 = new SubSystemA(); private SubSystemB obj1 = new SubSystemB(); private SubSystemC obj1 = new SubSystemC(); public void Method() { obj.MethodA(); obj.MethodB(); obj.MethodC(); }}class Program { static void Main(string[] args) { Facade facade = new Facade(); facade.Method(); } } 3 设计分析3.1 栗子​ 开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。 ​ 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package DesignPatterns.JavaDesign.Facade;import sun.misc.BASE64Encoder;import javax.sound.sampled.AudioFormat;import java.io.*;import java.nio.charset.StandardCharsets;import java.util.Base64;public class Test { public static void main(String[] args) { EncryptFacade ef = new EncryptFacade(); ef.FileEncrypt(&quot;src.txt&quot;, &quot;des.txt&quot;); }}class FileReader { public String Read(String fileNameSrc) { System.out.println(&quot;读取文件，获取明文：&quot;); FileInputStream fs = null; StringBuilder sb = new StringBuilder(); try { fs = new FileInputStream(fileNameSrc); int data; while((data = fs.read())!= -1) { sb = sb.append((char)data); } fs.close(); System.out.println(sb); }catch(FileNotFoundException e) { System.out.println(&quot;文件不存在！&quot;); }catch(IOException e) { System.out.println(&quot;文件操作错误！&quot;); } return sb.toString(); }}class CipherMachine { public String Encrypt(String plainText) { System.out.println(&quot;数据加密，将明文转换为密文：&quot;); String es = &quot;&quot;; char[] chars = plainText.toCharArray(); for(char ch: chars) { String c = String.valueOf(ch % 7); es += c; } System.out.println(es); return es; }}class FileWriter { public void Write(String encryptStr,String fileNameDes) { System.out.println(&quot;保存密文，写入文件。&quot;); FileOutputStream fs = null; try { fs = new FileOutputStream(fileNameDes); byte[] str = encryptStr.getBytes(StandardCharsets.UTF_8); fs.write(str,0, str.length); fs.flush(); fs.close(); }catch(FileNotFoundException e) { System.out.println(&quot;文件不存在！&quot;); }catch(IOException e) { System.out.println(e.getMessage()); System.out.println(&quot;文件操作错误！&quot;); } }}class EncryptFacade { //维持对其他对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() { reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); } //调用其他对象的业务方法 public void FileEncrypt(String fileNameSrc, String fileNameDes) { String plainStr = reader.Read(fileNameSrc); String encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); } } 3.2 优化​ 如何在不修改客户端代码的前提下使用新的外观类呢？解决方法之一是：引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类 4 总结优缺点分析 优点： 对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易 实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 缺点 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则 适用场景 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式 客户端程序与多个子系统之间存在很大的依赖性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联 系，而通过外观类建立联系，降低层之间的耦合度","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"title":"结构式：组合模式","text":"1 基本介绍​ 组合模式为：组合多个对象形成树形结构以表示具有”整体——部分“关系的层次结构。 ​ 组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。 ​ 在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。 ​ 该模式的关键在于定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。 ​ 同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构 2 设计分析2.1 栗子​ 杀毒软件框架设计，客户可以一致地对待文件和文件夹 代码大概如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package DesignPatterns.JavaDesign.Composite;import java.util.ArrayList;public class Test { public static void main(String[] args) { //针对抽象构件编程 AbstractFile file1, file2, file3, file4, file5, folder1, folder2, folder3, folder4; folder1 = new Folder(&quot;Sunny的资料&quot;); folder2 = new Folder(&quot;图像文件&quot;); folder3 = new Folder(&quot;文本文件&quot;); folder4 = new Folder(&quot;视频文件&quot;); file1 = new ImageFile(&quot;小龙女.jpg&quot;); file2 = new ImageFile(&quot;张无忌.gif&quot;); file3 = new TextFile(&quot;九阴真经.txt&quot;); file4 = new TextFile(&quot;葵花宝典.doc&quot;); file5 = new VideoFile(&quot;笑傲江湖.rmvb&quot;); folder2.add(file1); folder2.add(file2); folder3.add(file3); folder3.add(file4); folder4.add(file5); folder1.add(folder2); folder1.add(folder3); folder1.add(folder4); //从“Sunny的资料”节点开始进行杀毒操作 folder1.killVirus(); }}//抽象文件类：抽象构件abstract class AbstractFile { public abstract void add(AbstractFile file); public abstract void remove(AbstractFile file); public abstract AbstractFile getChild(int i); public abstract void killVirus();}//图像文件类：叶子构件class ImageFile extends AbstractFile { private String name; public ImageFile(String name) { this.name = name; } public void add(AbstractFile file) { System.out.println(&quot;对不起，不支持该方法！&quot;); } public void remove(AbstractFile file) { System.out.println(&quot;对不起，不支持该方法！&quot;); } public AbstractFile getChild(int i) { System.out.println(&quot;对不起，不支持该方法！&quot;); return null; } public void killVirus() { //模拟杀毒 System.out.println(&quot;----对图像文件'&quot; + name + &quot;'进行杀毒&quot;); }}//文本文件类：叶子构件class TextFile extends AbstractFile { private String name; public TextFile(String name) { this.name = name; } public void add(AbstractFile file) { System.out.println(&quot;对不起，不支持该方法！&quot;); } public void remove(AbstractFile file) { System.out.println(&quot;对不起，不支持该方法！&quot;); } public AbstractFile getChild(int i) { System.out.println(&quot;对不起，不支持该方法！&quot;); return null; } public void killVirus() { //模拟杀毒 System.out.println(&quot;----对文本文件'&quot; + name + &quot;'进行杀毒&quot;); }}//视频文件类：叶子构件class VideoFile extends AbstractFile { private String name; public VideoFile(String name) { this.name = name; } public void add(AbstractFile file) { System.out.println(&quot;对不起，不支持该方法！&quot;); } public void remove(AbstractFile file) { System.out.println(&quot;对不起，不支持该方法！&quot;); } public AbstractFile getChild(int i) { System.out.println(&quot;对不起，不支持该方法！&quot;); return null; } public void killVirus() { //模拟杀毒 System.out.println(&quot;----对视频文件'&quot; + name + &quot;'进行杀毒&quot;); }}//文件夹类：容器构件class Folder extends AbstractFile { //定义集合fileList，用于存储AbstractFile类型的成员 private ArrayList&lt;AbstractFile&gt; fileList = new ArrayList&lt;AbstractFile&gt;(); private String name; public Folder(String name) { this.name = name; } public void add(AbstractFile file) { fileList.add(file); } public void remove(AbstractFile file) { fileList.remove(file); } public AbstractFile getChild(int i) { return (AbstractFile) fileList.get(i); } public void killVirus() { System.out.println(&quot;****对文件夹'&quot; + name + &quot;'进行杀毒&quot;); //模拟杀毒 // 递归调用成员构件的killVirus()方法 for (Object obj : fileList) { ((AbstractFile) obj).killVirus(); } }} 2.2 原来方案的问题​ 由于在AbstractFile中声明了大量用于管理和访问成员构件的方法，例如add()、remove()等方法，我们不得不在新增的文件类中实现这些方法，提供对应的错误提示和异常处理 ​ 解决方案1：将叶子构件的add()、remove()等方法的实现代码移至AbstractFile类中，由AbstractFile提供统一的默认实现 ​ 解决方案2：除此之外，还有一种解决方法是在抽象构件AbstractFile中不声明任何用于访问和管理成员构件的方法 ​ 根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式 2.3 透明组合模式​ 透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法，这样做的好处是确保所有的构件类都有相同的接口。 ​ 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。 2.4 安全组合模式​ 安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法 ​ 安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高，在Java AWT中使用的组合模式就是安全组合模式。 3 总结优缺点分析 优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则” 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 缺点 ​ 在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂 适用场景 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们 在一个使用面向对象语言开发的系统中需要处理一个树形结构 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"行为式：模板方法模式","text":"1 基本介绍​ 定义如下：定义一个操作中算法的框架，而将一些步骤延迟到子类中。 ​ 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 ​ 模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。 2 代码框架12345678910111213141516171819202122232425abstract class AbstractClass { //模板方法 public void TemplateMethod() { PrimitiveOperation1(); PrimitiveOperation2(); PrimitiveOperation3(); } //基本方法—具体方法 public void PrimitiveOperation1() { //实现代码 } //基本方法—抽象方法 public abstract void PrimitiveOperation2(); //基本方法—钩子方法 public virtual void PrimitiveOperation3() {} }class ConcreteClass extends AbstractClass { public override void PrimitiveOperation2() { //实现代码 } public override void PrimitiveOperation3() { //实现代码 }} 3 设计分析开发一个利息计算模块 ​ 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package DesignPatterns.JavaDesign.Template;import java.io.Console;public class Test { public static void main(String[] args) { Account account; account = new CurrentAccount(); account.Handle(&quot;张无忌&quot;, &quot;123456&quot;); }}abstract class Account { //基本方法——具体方法 public Boolean Validate(String account, String password) { System.out.println(&quot;账号：&quot; + account); System.out.println(&quot;密码：&quot; + password); //模拟登录 if (account.equals(&quot;张无忌&quot;) &amp;&amp; password.equals(&quot;123456&quot;)) { return true; } else { return false; } } //基本方法——抽象方法 public abstract void CalculateInterest(); //基本方法——具体方法 public void Display() { System.out.println(&quot;显示利息！&quot;); } //模板方法 public void Handle(String account, String password) { if (!Validate(account,password)) { System.out.println(&quot;账户或密码错误！&quot;); return; } CalculateInterest(); Display(); }}class CurrentAccount extends Account { //覆盖父类的抽象基本方法 public void CalculateInterest() { System.out.println(&quot;按活期利率计算利息！&quot;); }}class SavingAccount extends Account { //覆盖父类的抽象基本方法 public void CalculateInterest() { System.out.println(&quot;按定期利率计算利息！&quot;); }} 4 总结优缺点分析 优点： 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序 代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则 缺点： 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象 适用场景 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现的场景 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制e","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"title":"结构式：适配器模式","text":"1 基本介绍​ 适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那个类可以一起工作，其别名为包装类。 ​ 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种 在对象适配器模式中，适配器与适配者之间是关联关系； 在类适配器模式中，适配器与适配者之间是继承（或实现）关系 ​ 一般来说，对象适配器使用频率更高 2 设计分析​ 使用适配器模式重用算法库中的算法 2.1 栗子 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package DesignPatterns.JavaDesign.Adapter;import com.tencentcloudapi.cdn.v20180606.models.Sort;import java.util.Collections;public class Test { public static void main(String[] args) { ScoreOperation operation; // 针对抽象目标接口编程 operation = new OperationAdapter(); // 可使用配置文件 int scores[] = {84, 76, 58, 79, 91, 84, 66}; int result[]; int score; System.out.println(&quot;成绩排序结果&quot;); result = operation.sort(scores); for (int i : scores) { System.out.print(i + &quot; &quot;); } System.out.println(); System.out.println(&quot;查找成绩91：&quot;); score = operation.search(result, 91); if (score != -1) { System.out.println(&quot;找到成绩91&quot;); } else { System.out.println(&quot;没有找到成绩91&quot;); } }}// 抽象成绩操作类：目标接口interface ScoreOperation { public int[] sort(int array[]); //成绩排序 public int search(int array[], int key); //成绩排序}// 快速排序类：适配器class QuickSort { public int[] quickSort(int array[]) { sort(array, 0, array.length - 1); return array; } public void sort(int array[], int l, int r) { if (l &gt;= r) return ; int i = l - 1, j = r + 1; int mid = (l + r) / 2; int x = array[mid]; while (i &lt; j) { do i ++; while (array[i] &lt; x); do j --; while (array[j] &gt; x); if (i &lt; j) swap(array, i, j); } sort(array, l, j); sort(array, j + 1, r); } public void swap(int[] a, int i, int j) { int t = a[i]; a[i] = a[j]; a[j] = t; }}// 二分查找类：适配者class BinarySearch { public int binarySearch(int array[], int key) { int low = 0; int high = array.length - 1; while (low &lt;= high) { int mid = (low + high) / 2; if (array[mid] &lt; key) low = mid + 1; else if (array[mid] &gt; key) high = mid - 1; else return 1; } return -1; }}// 操作适配器：适配器class OperationAdapter implements ScoreOperation { private QuickSort sortObj; // 定义适配器QuickSort对象 private BinarySearch searchObj; // 定义适配器BinarySearch对象 public OperationAdapter() { sortObj = new QuickSort(); searchObj = new BinarySearch(); } @Override public int[] sort(int[] array) { return sortObj.quickSort(array); // 调用适配器类QuickSort的排序方法 } @Override public int search(int[] array, int key) { return searchObj.binarySearch(array, key); }} 2.2 类适配器​ 类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系。 一般适配器的代码大概长这样： 12345class Adapter extends Adaptee implemements Target { public void request() { specificRequest(); }} ​ 由于Java、C#等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器；此外，如果适配者Adapter为最终 （Final）类，也无法使用类适配器。 2.3 双向适配器​ 在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器 ​ 在实际开发中，很少使用双向适配器 2.4 缺省适配器​ 缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 3 总结优缺点分析 优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 缺点（对象适配器） 要在适配器中置换适配者类的某些方法比较麻烦 适用场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 4 场景使用4.1 Spring的Aop对适配器模式的使用​ AOP的大致流程是这样的：使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。 ​ Advice（通知）的类型有：BeforeAdvice、AfterReturningAdvice、ThreowSadvice的。 ​ 在每个类型Advice（通知）都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。 ​ Spring需要将每个Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换。下面我们看看具体的代码。 代码大致如下： MethodBeforeAdvice类：Adaptee 12345public interface MethodBeforeAdvice extends BeforeAdvice { void before(Method method, Object[] args, Object target) throws Throwable; } Adapter类接口： Target 1234567public interface AdvisorAdapter { boolean supportsAdvice(Advice advice); MethodInterceptor getInterceptor(Advisor advisor); } MethodBeforeAdviceAdapter类：Adapter 123456789101112class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable { public boolean supportsAdvice(Advice advice) { return (advice instanceof MethodBeforeAdvice); } public MethodInterceptor getInterceptor(Advisor advisor) { MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); } } DefaultAdvisorAdapterRegistry类：Client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable { private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;AdvisorAdapter&gt;(3); /** * Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters. */ public DefaultAdvisorAdapterRegistry() {//这里注册了适配器 registerAdvisorAdapter(new MethodBeforeAdviceAdapter()); registerAdvisorAdapter(new AfterReturningAdviceAdapter()); registerAdvisorAdapter(new ThrowsAdviceAdapter()); } public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException { if (adviceObject instanceof Advisor) { return (Advisor) adviceObject; } if (!(adviceObject instanceof Advice)) { throw new UnknownAdviceTypeException(adviceObject); } Advice advice = (Advice) adviceObject; if (advice instanceof MethodInterceptor) { // So well-known it doesn't even need an adapter. return new DefaultPointcutAdvisor(advice); } for (AdvisorAdapter adapter : this.adapters) { // Check that it is supported. if (adapter.supportsAdvice(advice)) {//这里调用了适配器的方法 return new DefaultPointcutAdvisor(advice); } } throw new UnknownAdviceTypeException(advice); } public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException { List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) { interceptors.add((MethodInterceptor) advice); } for (AdvisorAdapter adapter : this.adapters) { if (adapter.supportsAdvice(advice)) {//这里调用了适配器的方法 interceptors.add(adapter.getInterceptor(advisor)); } } if (interceptors.isEmpty()) { throw new UnknownAdviceTypeException(advisor.getAdvice()); } return interceptors.toArray(new MethodInterceptor[interceptors.size()]); } public void registerAdvisorAdapter(AdvisorAdapter adapter) { this.adapters.add(adapter); } }","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%BC%8F%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"行为式：策略模式","text":"1 基本介绍​ 定义为：定义一些独立的类来封装不同的算法，并让它们可以相互替换。 ​ Context是用适用算法的角色 2 代码框架123456789101112131415161718192021222324252627282930abstract class AbstractStrategy { public abstract void algorithm(); //声明抽象算法 }class ConcreteStrategyA extends AbstractStrategy { //算法的具体实现 public void algorithm() { //算法A } }class Context { private AbstractStrategy strategy; //维持一个对抽象策略类的引用 public void setStrategy(AbstractStrategy strategy) { this.strategy= strategy; } //调用策略类中的算法 public void algorithm() { strategy.algorithm(); } }// 客户端代码...Context context = new Context(); AbstractStrategy strategy; strategy = new ConcreteStrategyA(); //可在运行时指定类型 context.setStrategy(strategy); context.algorithm(); 3 设计分析​ 实现电影院打折方案 ​ 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package DesignPatterns.JavaDesign.Strategy;import DesignPatterns.JavaDesign.FactoryMethod.XMLUtil;public class Test { public static void main(String[] args) { MovieTicket mt = new MovieTicket(); double originalPrice = 60.0; double currentPrice; mt.setPrice(originalPrice); System.out.println(&quot;原始价为：&quot; + originalPrice); System.out.println(&quot;---------------------------------&quot;); Discount discount; discount = new ChildrenDiscount(); // &lt;-------可用xml优化 //读取配置文件并反射生成具体折扣对象 mt.setDiscount(discount); //注入折扣对象 currentPrice = mt.getPrice(); System.out.println(&quot;折后价为：&quot; + currentPrice); }}//电影票类：环境类class MovieTicket { private double price; private Discount discount; //维持一个对抽象折扣类的引用 public void setPrice(double price) { this.price = price; } //注入一个折扣类对象 public void setDiscount(Discount discount) { this.discount = discount; }public double getPrice() { //调用折扣类的折扣价计算方法 return discount.calculate(this.price); }}//折扣类：抽象策略类interface Discount { public double calculate(double price);}//学生票折扣类：具体策略类class StudentDiscount implements Discount { public double calculate(double price) { System.out.println(&quot;学生票：&quot;); return price * 0.8; }}//儿童票折扣类：具体策略类class ChildrenDiscount implements Discount { public double calculate(double price) { System.out.println(&quot;儿童票：&quot;); return price - 10; }}//VIP会员票折扣类：具体策略类class VIPDiscount implements Discount { public double calculate(double price) { System.out.println(&quot;VIP票：&quot;); System.out.println(&quot;增加积分！&quot;); return price * 0.5; }} 4 总结优缺点分析 优点： 符合“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为。 策略模式提供了管理相关的算法族的办法 策略模式提供了一种算法的复用机制 使用策略模式可以避免多重条件选择语句 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类 无法同时在客户端使用多个策略类 适用场景 一个系统需要动态地在几种算法中选择一种 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式的七大基本原则","text":"1 基本介绍 设计原则名称 定义 使用频率 单一职责原则 一个类只负责一个功能领域中的相应职责 ✨✨✨✨ 开闭原则 软件实体应对外扩展开放，而对修改关闭 ✨✨✨✨✨ 里氏代换原则 所有引用基类对象的地方都能够透明地使用其子类的对象 ✨✨✨✨✨ 依赖倒转原则 抽象不应该依赖于细节，细节应该依赖于抽象 ✨✨✨✨✨ 接口隔离原则 使用多个专门的接口，而不使用单一的总接口 ✨✨ 合成复用原则 尽量使用对象组合，而不是继承来达到复用的目的 ✨✨✨✨ 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用 ✨✨✨ 2 单一职责原则​ 从字面意思来看，就是一个类应该做到“专注”，如果一个类承担的职责越多，可复用性将会越小。 ​ 比如说，见下图 ​ 该类承担了，getConnection()方法用于连接数据库， findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。很明显，这样会导致耦合度过高。 ​ 改进后的图是这样的： DBUtil：负责连接数据库 CustomerDAO：负责操作数据库中的Customer表 CustomerDataChart：负责图表的生成和显示 3 开闭原则​ 这个原则简单来说就是：软件实体应该尽量在不修改原有代码的基础上进行扩展 ​ 软件实体可以是一个模块，一个由多个类组成的局部类或一个独立的类 ​ 该原则的好处在于：使得软件拥有更好的稳定性和延续性 ​ 举个栗子： ​ 一个系统需要展示不同的图表，它是按如下设计的 123456789...if (type.equals(&quot;pie&quot;)) { PieChart chart = new PieChart(); chart.display();} else if (type.equals(&quot;bar&quot;)) { BarChart chart = new BarChart(); chart.display();}... 可见上述代码和设计，如果后续要添加折线图，则还要新增判断逻辑。 修改如下： ​ 添加一个抽象图表类AbstractChart，当要显示某种图表时，则注入对应的对象即可。 4 里氏替换原则​ 该原则是指：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。 ​ 这样说感觉有点抽象，举个栗子：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物 ​ 里氏替换原则是实现开闭原则的重要方式，因为一般代码都是使用基类类型来对对象定义，在运行时确定其子类类型，用子类对象来替换父类对象。 ​ 该原则需要注意以下问题： 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法 尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现 ​ 举个发邮件的栗子 ​ 可以发现，无论是普通用户还是VIP，其实发邮件都是相同的，也就是这里会出现代码重复，为了减少代码重复，可以用改用则进行重构 ​ 重构后，增加一个抽象类 5 依赖倒转原则​ 依赖倒转原则是指：抽象不应该依赖细节，细节应该依赖于抽象。说人话就是，要面向接口/抽象类编程，而不是面向实现编程 ​ 这也就要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类。 ​ 因为使用抽象层进行编程，可以提高系统的灵活性，对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 ​ 常用的注入方式有三种：构造注入，设值注入，接口注入。 ​ 举个栗子来理解下 ​ 将存储在TXT或EXCEL文件中的客户信息存到数据库中，需要进行格式转换。 ​ 但是这有个问题，每次更改数据转化类，都需要修改CustomerDAO的源代码，系统扩展性较差。 ​ 重构方式如下： ​ 引入抽象数据转换类DataConvertor，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。 ​ 根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会 出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增 加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即 可，原有代码无须做任何修改，满足开闭原则。 ​ 可以发现，3，4，5三种原则是密切联系的，开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段。只是分析的角度不同而已。 6 接口隔离原则​ 该原则是指：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 ​ 简单来说，就是接口应该尽量细化，同时接口中的方法应该尽量少，每个接口只包含一个客户端所需的方法即可。 ​ 举个数据显示的栗子： ​ 具体意义就不解释了，函数名很清晰 ​ 可以发现，如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错等。。 ​ 重构后 ​ 重构后的接口粒度更细了，但要注意的是接口不能太小，如果太小会导致系 统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 7 合成复用原则​ 该原则的含义是：尽量使用对象组合，而不是继承来达到复用的目的。 ​ 简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在设计时： 使用组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少 其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则 继承的“危害” 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。 ​ 一般来说，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。&quot;Is-A&quot;是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而&quot;Has-A&quot;则不同，它表示某一个角色具有某一项责任。 ​ 再来看一个连接数据库栗子 ​ 该栗子是指，通过继承工具类的方式来连接MYSQL数据库，而如果系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。 ​ 重构后 ​ CustomerDAO和DBUtil之间的关系由继承关系变为关联关系。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖 DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。 8 迪米特原则​ 该原则是指：一个软件实体应当尽可能少地与其他实体发生相互作用。 ​ 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类： 当前对象本身 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 在将迪米特法则运用到系统设计中时，要注意下面的几点： 在类的划分上，应当尽量创建松 耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及； 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 举个栗子 ​ 一个业务窗口中有很多交互关系，可以发现这些关系十分复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。 ​ 重构后 ​ 引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码。","link":"/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"},{"title":"行为式：观察者模式","text":"1 基本介绍​ 观察者模式是使用频率最高的设计模式之一。 ​ 基本是：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 ​ 别名又称为发布-订阅模式，模型-视图模式，源-监听者模式 2 设计分析​ 使用观察者模式来进行多人联机对战游戏的设计 2.1 栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package DesignPatterns.JavaDesign.Observer;import java.util.ArrayList;public class Test { public static void main(String[] args) { // 定义观察目标对象 AllyControlCenter acc; acc = new ConcreteAllyControlCenter(&quot;金庸群侠&quot;); // 定义四个观察者对象 Observer player1, player2, player3, player4; player1 = new Player(&quot;杨过&quot;); acc.join(player1); player2 = new Player(&quot;令狐冲&quot;); acc.join(player2); player3 = new Player(&quot;张无忌&quot;); acc.join(player3); player4 = new Player(&quot;段誉&quot;); acc.join(player4); player1.beAttacked(acc); }}interface Observer { public String getName(); public void setName(String name); public void help(); // 声明支援盟友方法 public void beAttacked(AllyControlCenter acc); // 声明遭受攻击方法}// 战队成员类：具体观察者类class Player implements Observer { private String name; public Player(String name) { this.name = name; } @Override public String getName() { return name; } @Override public void setName(String name) { this.name = name; } // 支援盟友方法的实现 @Override public void help() { System.out.println(&quot;坚持住，&quot; + this.name + &quot;来救你&quot;); } // 遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法notifyObserver @Override public void beAttacked(AllyControlCenter acc) { System.out.println(this.name + &quot;被攻击&quot;); acc.notifyObserver(name); }}abstract class AllyControlCenter { protected String allyName; // 战队名称 protected ArrayList&lt;Observer&gt; players = new ArrayList&lt;Observer&gt;(); public String getAllyName() { return allyName; } public void setAllyName(String allyName) { this.allyName = allyName; } public void join(Observer obs) { System.out.println(obs.getName() + &quot;加入&quot; + this.allyName); players.add(obs); } // 注销方法 public void quit(Observer obs) { System.out.println(obs.getName() + &quot;退出&quot; + this.allyName); players.remove(obs); } // 声明抽象通知方法 public abstract void notifyObserver(String name);}// 具体战队控制中心类：具体目标类class ConcreteAllyControlCenter extends AllyControlCenter { public ConcreteAllyControlCenter(String allyName) { System.out.println(allyName + &quot;战队组建成功！&quot;); System.out.println(&quot;--------------------&quot;); this.allyName = allyName; } @Override public void notifyObserver(String name) { System.out.println(this.allyName + &quot;战队紧急通知，盟友&quot; + name); // 遍历观察者集合，调用每一个盟友的支援方法 for (Observer player : players) { if (!((Observer)player).getName().equalsIgnoreCase(name)) { ((Observer)player).help(); } } }} ​ 在本例中，实现了两次对象之间的联动，当一个游戏玩家Player对象的beAttacked()方法被调用时，将调用AllyControlCenter的notifyObserver()方法来进行处理，而在notifyObserver()方法中又将调用其他Player对象的help()方法。 Player.beAttacked() –&gt; AllyControlCenter.notifyObserver() –&gt;Player 3 总结优缺点分析 优点： 实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码 缺点： 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 4 场景使用4.1 Spring中ApplicationContext的使用​ ApplicationContext事件机制是观察者设计模式的实现，通过 ApplicationEvent类和 ApplicationListener 接口，可以实现 ApplicationContext事件处理。 如果容器中有一个 ApplicationListener Bean ，每当 ApplicationContext 发布 ApplicationEvent 时，ApplicationListener Bean 将自动被触发。这种事件机制都必须需要程序显示的触发。 ​ ApplicationContext事件监听 ​ 当ApplicationContext内的Bean对象初始化完成时，此时可以通过监听 ContextRefreshedEvent 得到通知 ​ 将对象添加到容器中 参考(111条消息) 设计模式之Spring中观察者模式_字节跳动的博客-CSDN博客_spring中的观察者模式","link":"/2022/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"从实现一个RPC来分析其原理及用途","text":"1 基本介绍1.1 什么是RPC​ RPC(Remote Procedure Call)——远程过程调用，是一种通过网络从远程计算机程序请求服务，而不需要了解底层网络技术的协议。 ​ 解决的问题是：让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。 1.2 RPC简要原理 服务消费方（client）调用以本地调用方式调用服务； client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； client stub找到服务地址，并将消息发送到服务端； server stub收到消息后进行解码； server stub根据解码结果调用本地的服务； 本地服务执行并将结果返回给server stub； server stub将返回结果打包成消息并发送至消费方； client stub接收到消息，并进行解码； 服务消费方得到最终结果。 1.3 为什么用RPC，而不用HTTP​ 首先，这两个并不是一种概念，RPC是一种设计，用于解决不同服务之间的调用问题，RPC实现一般会包含传输协议和序列化协议两个。 ​ 而HTTP是一种传输协议，RPC可以使用HTTP作为传输协议，也可以直接使用TCP，不同的协议对应不同的场景 ​ 通常，使用TCP的RPC效率比使用HTTP更高 传输效率 TCP，通常自定义上层协议，请求报文体积更小 HTTP，请求中会包含很多无用的内容 性能消耗 TCP，可以基于各种序列化框架进行，效率比较高 HTTP，大部分通过json实现，字节大小和序列化耗时都更消耗性能 跨平台 TCP：通常要求客户端和服务端为统一平台 HTTP：可以在各种异构平台运行 总结 ​ RPC 的 TCP 方式主要用于系统内部的服务调用，性能消耗低，传输效率高。而且封装了“服务发现”，“负载均衡”，“熔断降级”一类面向服务的高级特性 ​ HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。 将通俗点，就是RPC就像地区方言（有些方言可能就是普通话），只有内部知道，双方都需要知道方言，不然没法沟通；HTTP就是普通话，基本都能懂，也会说 2 如何设计一个RPC​ RPC的设计一般都会包含五个模块：协议模块，序列化模块，网络模块，服务端模块和客户端模块。 ​ 协议模块一般是指：请求和响应参数的封装，服务的描述等 ​ 序列化模块：提供将对象通过某种方法把对象以字节序列的形式保存起来的API ​ 网络传输模块：定义网络传输协议，提供服务调用功能 以下结合netty传输来设计 2.1参考(近)万字总结，RPC 项目相关问题及解答_技术交流_牛客网 (nowcoder.com) (109条消息) java int转byte数组_Dan淡淡的心的博客-CSDN博客_int转byte数组 (25 封私信 / 1 条消息) 既然有 HTTP 请求，为什么还要用 RPC 调用？ - 知乎 (zhihu.com)","link":"/2022/03/15/%E6%A1%86%E6%9E%B6/RPC/%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%9D%A5%E5%88%86%E6%9E%90%E5%85%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E9%80%94/"},{"title":"动态代理在RPC中的运用","text":"​ 动态代理在 RPC 框架的实现中起到了至关重要的作用，它可以帮助用户屏蔽 RPC 调用时底层网络通信、服务发现、负载均衡等具体细节。 1 动态代理基础​ 代理模式的优势是可以很好地遵循设计模式中的开放封闭原则，对扩展开发，对修改关闭。 ​ 动态代理是一种代理模式，它提供了一种能够在运行时动态构建代理类以及动态调用目标方法的机制。代理类可以看作是对被代理对象的包装，对目标方法的调用是通过代理类来完成的。所以通过代理模式可以有效地将服务提供者和服务消费者进行解耦，隐藏了 RPC 调用的具体细节。 JDK动态代理JDK 动态代理实现依赖 java.lang.reflect 包中的两个核心类：InvocationHandler 接口和Proxy 类。 InvocationHandler 接口 ​ JDK 动态代理所代理的对象必须实现一个或者多个接口，生成的代理类也是接口的实现类，然后通过 JDK 动态代理是通过反射调用的方式代理类中的方法，不能代理接口中不存在的方法。 ​ 每一个动态代理对象必须提供 InvocationHandler 接口的实现类，InvocationHandler 接口中只有一个 invoke() 方法。当我们使用代理对象调用某个方法的时候，最终都会被转发到 invoke() 方法执行具体的逻辑。 Proxy 类 ​ Proxy 类可以理解为动态创建代理类的工厂类，它提供了一组静态方法和接口用于动态生成对象和代理类。 Cglib动态代理​ Cglib 动态代理是基于 ASM 字节码生成框架实现的第三方工具类库，相比于 JDK 动态代理，Cglib 动态代理更加灵活，它是通过字节码技术生成的代理类，所以代理类的类型是不受限制的。使用 Cglib 代理的目标类无须实现任何接口，可以做到对目标类零侵入。 ​ Cglib 动态代理是对指定类以字节码的方式生成一个子类，并重写其中的方法，以此来实现动态代理。因为 Cglib 动态代理创建的是目标类的子类，所以目标类必须要有无参构造函数，而且目标类不要用 final 进行修饰。 Cglib 动态代理的实现需要依赖两个核心组件：MethodInterceptor 接口和 Enhancer类 MethodInterceptor 接口 ​ MethodInterceptor 接口只有 intercept() 一个方法，所有被代理类的方法执行最终都会转移到 intercept() 方法中进行行为增强，真实方法的执行逻辑则通过 Method 或者 MethodProxy 对象进行调用。 Enhancer 类 ​ Enhancer 类是 Cglib 中的一个字节码增强器，它为我们对代理类进行扩展时提供了极大的便利。Enhancer 类的本质是在运行时动态为代理类生成一个子类，并且拦截代理类中的所有方法。 参考(121条消息) jdk动态代理invoke方法自动运行原因_码到的博客-CSDN博客_动态代理invoke [27 动态代理：为用户屏蔽 RPC 调用的底层细节.md (lianglianglee.com)](https://learn.lianglianglee.com/专栏/Netty 核心原理剖析与 RPC 实践-完/27 动态代理：为用户屏蔽 RPC 调用的底层细节.md)","link":"/2022/03/06/%E6%A1%86%E6%9E%B6/RPC/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8RPC%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"},{"title":"JDK和Cglib动态代理的区别","text":"1 为什么需要代理？​ 简单来说，就是为了保证单一性原则问题，也就是每个类的功能尽可能单一，这样才能是该类被改动的可能性最小。比如，如果当我们需要为类里加上权限，日志等功能时，如果每个类都需要这种功能，那就要修改每个类，这样工作量很大，所以我们需要一个代理，让我们可以在不改动原有代码的前提下，实现一些其他功能，即增强。我们在进入目标类之前，先进入代理类，在代理类中写我们需要的额外功能，这样原有类不动，不影响原有功能。 ​ 下面就是一个关于静态代理的实例，能帮助理解代理的意义 12345678/*** 共同接口*/public interface ProgrammerInterface { void goToWork(); void goOffWork();} 1234567891011121314/*** 程序员类*/public class Programmer implements ProgrammerInterface{ @Override public void goToWork() { System.out.print(&quot;开始上班了\\n&quot;); } @Override public void goOffWork() { System.out.print(&quot;终于下班了\\n&quot;); }} 1234567891011121314151617181920212223242526272829/*** 程序员代理类*/public class ProgrammerProxy implements ProgrammerInterface { //目标类(程序员类) Programmer programmer; //构造方法,初始化目标类 public ProgrammerProxy(Programmer programmer) { this.programmer = programmer; } @Override public void goToWork() { System.out.print(&quot;进入了上班代理\\n&quot;); programmer.goToWork(); System.out.print(&quot;上班时间为:&quot; + new Date() + &quot;\\n\\n&quot;); } @Override public void goOffWork() { System.out.print(&quot;进入了下班代理\\n&quot;); programmer.goOffWork(); System.out.print(&quot;下班时间为:&quot; + new Date() + &quot;\\n&quot;); }} 1234567891011121314public class ProxyDemoApplication { public static void main(String[] args) {// Programmer programmer = new Programmer();// programmer.goToWork();// programmer.goOffWork(); Programmer programmer = new Programmer(); ProgrammerProxy programmerProxy = new ProgrammerProxy(programmer); programmerProxy.goToWork(); programmerProxy.goOffWork(); }} 运行结果 1234567进入了上班代理开始上班了上班时间为：Sun Feb 20 16:51:09 CST 2022进入了下班代理终于下班了下班时间为：Sun Feb 20 16:51:09 CST 2022 ​ 但静态代理有两个问题 如果其他类需要实现同样的功能，则需要在写一个代理类，这样会很麻烦。 当我们需要新增功能时，需要在接口，类，代理类上都要新增，项目规模较大时不好维护 ​ 所以，就出现了动态代理，下面来聊聊Java中动态代理的几种方式和区别。 2 JDK动态代理​ JDK动态代理主要是通过，反射包中的Porxy类和InvokationHandler接口。它们结合在一起后可以创建动态代理类。Porxy类基于传递的参数创建动态代理类。InvokationHandler则用于激发动态代理类的方法。这个过程是在程序执行过程中动态生成与处理的，所以叫动态代理。 ​ 下面来看看使用示例 实现InvokationHandler接口​ JDK 动态代理类必须实现反射包中的 java.lang.reflect.InvocationHandler 接口，在此接口中只有一个 invoker 方法： ​ 在InvocationHandler#invoker中必须调用目标类被代理的方法，否则无法做到代理的实现。下面为实现 InvocationHandler 的代码。 12345678910111213141516public class TargetInvoker implements InvocationHandler { // 代理中持有的目标类 private Object target; public TargetInvoker(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;jdk 代理执行前&quot;); Object result = method.invoke(target, args); System.out.println(&quot;jdk 代理执行后&quot;); return result; }} ​ 在实现InvocationHandler#invoker时，该方法里有三个参数： proxy 代理目标对象的代理对象，它是真实的代理对象。 method 执行目标类的方法 args 执行目标类的方法的参数 创建JDK动态代理类​ 创建 JDK 动态代理类实例同样也是使用反射包中的 java.lang.reflect.Proxy 类进行创建。通过调用Proxy#newProxyInstance静态方法进行创建。 1234567891011public class DynamicProxyAnimal { public static Object getProxy(Object target) throws Exception { Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), // 指定目标类的类加载 target.getClass().getInterfaces(), // 代理需要实现的接口，可指定多个，这是一个数组 new TargetInvoker(target) // 代理对象处理器 ); return proxy; }} ​ Proxy#newProxyInstance中的三个参数（ClassLoader loader、Class&lt;?&gt;[] interfaces、InvocationHandler h）： loader 加载代理对象的类加载器 interfaces 代理对象实现的接口，与目标对象实现同样的接口 h 处理代理对象逻辑的处理器，即上面的 InvocationHandler 实现类。 ​ 最后实现执行 DynamicProxyAnimal 动态代理： 3 Cglib动态代理​ CGLIB 动态代理的实现机制是生成目标类的子类，通过调用父类（目标类）的方法实现，在调用父类方法时再代理中进行增强。 实现 MethodInterceptor 接口​ 相比于 JDK 动态代理的实现，CGLIB 动态代理不需要实现与目标类一样的接口，而是通过方法拦截的方式实现代理，代码实现如下，首先方法拦截接口 net.sf.cglib.proxy.MethodInterceptor。 12345678910public class TargetInterceptor implements MethodInterceptor { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(&quot;CGLIB 调用前&quot;); Object result = proxy.invokeSuper(obj, args); System.out.println(&quot;CGLIB 调用后&quot;); return result; }} 通过方法拦截接口调用目标类的方法，然后在该被拦截的方法进行增强处理，实现方法拦截器接口的 intercept 方法里面有四个参数： obj 代理类对象 method 当前被代理拦截的方法 args 拦截方法的参数 proxy 代理类对应目标类的代理方法 创建Cglib动态代理类​ 创建 CGLIB 动态代理类使用 net.sf.cglib.proxy.Enhancer 类进行创建，它是 CGLIB 动态代理中的核心类，首先创建个简单的代理类： 1234567891011121314public class CglibProxy { public static Object getProxy(Class&lt;?&gt; clazz){ Enhancer enhancer = new Enhancer(); // 设置类加载 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new TargetInterceptor()); // 创建代理类 return enhancer.create(); }} ​ 设置被代理类的信息和代理类拦截的方法的回调执行逻辑，就可以实现一个代理类。 实现 CGLIB 动态代理调用： 1234567public class Main { @Test public void dynamicProxy() throws Exception { Animal cat = (Animal) CglibProxy.getProxy(Cat.class); cat.call(); }} ​ 4 总结​ 两种机制的不同实现： JDK 动态代理是通过实现目标类的接口，然后将目标类在构造动态代理时作为参数传入，使代理对象持有目标对象，再通过代理对象的 InvocationHandler 实现动态代理的操作。 CGLIB 动态代理是通过配置目标类信息，然后利用 ASM 字节码框架进行生成目标类的子类。当调用代理方法时，通过拦截方法的方式实现代理的操作。 ​ 从而，我们知道： JDK动态代理只能对实现了接口的类生成代理，而不能针对类 CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 ​ 后续再出一篇关于源码阅读的文章详解，这两种方式是如何实现代理的。 参考JDK 动态代理与 CGLIB 有哪些区别? - 掘金 (juejin.cn) 你必须会的 JDK 动态代理和 CGLIB 动态代理 - 知乎 (zhihu.com)","link":"/2022/02/20/%E6%A1%86%E6%9E%B6/Spring/JDK%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"抢红包：二倍均值法实现均匀分配","text":"​ 今天面蔚来被问到了，当时实现的算法不够均匀，被面试官指出了，上网搜了下，有种二倍均值法可以实现，故在此记录 1 算法介绍​ 对于钱数money，份数person，每次计算出均值avgAmount = money / person，再将其乘2，得到下一个人可分配红包的范围，进行分配以后，money和person都减少，再进行该操作，最后一个人不用随机，直接取剩余金额即可 2 算法实现1234567891011121314151617181920212223242526272829303132333435363738package test;import java.io.IOException;import java.util.Arrays;public class Test { public static void main(String[] args) throws IOException { int money = 100; // 钱数 int person = 10; // 份数 int[] resultArr = clickReaPacket(money, person); String s = Arrays.toString(resultArr); System.out.println(s); } private static int[] clickReaPacket(int money, int person) { int[] amountArr = new int[person]; System.out.printf(&quot;%s 分钱分给 %s 人\\n&quot;, money, person); for (int i = 0; i &lt; amountArr.length - 1; i++) { // 注意 money 和 person 两个 int 变量做除法，应该转换其中一个为浮点类型，以保存精度 double avgAmount = ((double) money) / person; double doubleAvfAmount = avgAmount * 2; person --; int min = 1; double max = doubleAvfAmount; int currentAmount = getRandomBetween(min, max); amountArr[i] = currentAmount; money = money - currentAmount; System.out.printf(&quot;剩余人数：%s\\t抢到：%s \\t剩余金额：%s\\t本次均值的二倍：%s\\t金额随机范围：[%s, %s]\\n&quot;, person, currentAmount, money, doubleAvfAmount, min, max); } amountArr[amountArr.length - 1] = money; return amountArr; } private static int getRandomBetween(int a, double b) { double newScope = Math.random() * (b - a); return (int) (Math.floor(a + newScope)); }}","link":"/2022/03/11/%E7%AE%97%E6%B3%95/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/%E6%8A%A2%E7%BA%A2%E5%8C%85%EF%BC%9A%E4%BA%8C%E5%80%8D%E5%9D%87%E5%80%BC%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9D%87%E5%8C%80%E5%88%86%E9%85%8D/"},{"title":"位运算","text":"剑指 Offer II 004. 只出现一次的数字刷穿剑指offer-Day02-整数II 004.只出现一次的数字 位运算讲解 - 只出现一次的数字 12345678910111213141516class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int ret = 0; for (int i = 0; i &lt; 32; i ++) { int cnt = 0; for (auto num: nums) { cnt += num &gt;&gt; i &amp; 1; } if (cnt % 3 != 0) { ret |= 1 &lt;&lt; i; } } return ret; }}; 剑指 Offer II 005. 单词长度的最大乘积123456789101112131415161718192021222324class Solution {public: int maxProduct(vector&lt;string&gt;&amp; words) { int n = words.size(); vector&lt;int&gt; dict(n, 0); for (int i = 0; i &lt; words.size(); i ++) { int t = 0; for (auto c: words[i]) { int bit = c - 'a'; t |= (1 &lt;&lt; bit); } dict[i] = t; } int ans = 0; for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; i; j ++) if ((dict[i] &amp; dict[j]) == 0) { int temp = words[i].size() * words[j].size(); ans = max(ans, temp); } return ans; } };","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"区间DP","text":"87. 扰乱字符串1234567891011121314151617181920212223242526272829class Solution {public: bool isScramble(string s1, string s2) { int n = s1.size(); if (s1 == s2) return true; if (s1.size() != s2.size()) return false; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, false))); // 处理长度为1的情况 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; n; j ++) if (s1[i] == s2[j]) f[i][j][1] = true; // f[i][j][len] 代表 s1s1 从 ii 开始，s2s2 从 jj 开始，后面长度为 lenlen 的字符是否能形成「扰乱字符串」（互为翻转）。 for (int len = 2; len &lt;= n; len ++) for (int i = 0; i &lt;= n - len; i ++) for (int j = 0; j &lt;= n - len; j ++) for (int k = 1; k &lt; len; k ++) { // 分割点 // a : 0 - i, b : 0 - j ; a: i - n, j - n bool a = f[i][j][k] &amp;&amp; f[i + k][j + k][len - k]; // a : 0 - i, b : n - i, n ; a: i - n, 0 - j bool b = f[i][j + len - k][k] &amp;&amp; f[i + k][j][len - k]; if (a || b) { f[i][j][len] = true; } } return f[0][0][n]; }}; 375. 猜数字大小 II1234567891011121314151617181920class Solution {public: int getMoneyAmount(int n) { //定义 f[l][r]f[l][r] 为考虑在 [l, r][l,r] 范围内进行猜数的最小成本。 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); // 需要找到能猜中数字的最小成本，也就是最坏情况最好的结果 // 对于任一区间取min是因为我们在该区间可以先选择小的数去试，由此降低成本 for (int len = 2; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; f[l][r] = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cur = max(f[l][x - 1], f[x + 1][r]) + x; f[l][r] = min(f[l][r], cur); } } return f[1][n]; }}; 516. 最长回文子序列123456789101112131415161718192021222324252627282930313233class Solution {public: /* bb aa bb bb a bb dp[i][j] 表示 第 i 个字符到 第 j 个字符之间最长的回文子序列长度 1、当 s[i] == s[j] 时，考虑 i 和 j 中间序列的奇偶个数， dp[i][j] = dp[i+1][j-1] + 2 对上述 dp[i][j] = dp[i+1][j-1] + 2 的解释： 当序列为 b aa b 时， i = 0, j = 3，则 dp[0][3] = dp[1][2] + 2 = 4 当序列为 b a b 时，i = 0, j = 2，则 dp[0][2] = dp[1][1] + 2 = 3 当序列为 b b 时， i = 0, j = 1，则 dp[0][1] = dp[1][0] = 0 + 2 = 2 (dp[1][0] 默认值为 0) 该式子同时考虑到了奇偶 2、当 s[i] != s[j] ，那么 dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]) 对上述 dp[i][j] 式子的解释： 假如序列为 d c b c c（index：0-4），s[0] != s[4] ，则 dp[0][4] = Math.max(dp[0][3],dp[1,4]) = Math.max(2,3) = 3 */ int longestPalindromeSubseq(string s) { int n = s.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i + 1][j - 1] + 2; } else { f[i][j] = max(f[i + 1][j], f[i][j - 1]); } } } return f[0][n - 1]; }}; 664. 奇怪的打印机123456789101112131415161718192021class Solution {public: int strangePrinter(string s) { int n = s.size(); // f[i][j] 表示 区间[i,j]的最小打印次数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i][j - 1]; } else { for (int k = i; k &lt; j; k ++) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } } return f[0][n - 1]; }}; 877. 石子游戏1234567891011121314151617class Solution {public: bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); // 定义 f[l][r]f[l][r] 为考虑区间 [l,r][l,r]，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); for (int len = 1; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; int a = piles[l - 1] + f[l + 1][r]; int b = piles[r - 1] + f[l][r - 1]; f[l][r] = max(a, b); } return f[1][n] &gt; 0; }};","link":"/2022/02/02/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4DP/"},{"title":"双指针","text":"剑指 Offer II 008. 和大于等于 target 的最短子数组123456789101112class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(), sum = 0, res = INT_MAX; for (int i = 0, j = 0; i &lt; n; i ++) { sum += nums[i]; while (sum - nums[j] &gt;= target) sum -= nums[j ++]; if (sum &gt;= target) res = min(res, i - j + 1); } return res == INT_MAX ? 0 : res; }}; 剑指 Offer II 009. 乘积小于 K 的子数组 1234567891011121314class Solution {public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) { //已知ABC &lt; target, 新增一位X变成ABCX, 若ABCX &lt; target 则新增的subarray中必须满足 1.连续 2.包含X //所以从X向左数: X, CX, BCX, ABCX int n = nums.size(), product = 1, res = 0; for (int i = 0, j = 0; i &lt; n; i ++ ) { product *= nums[i]; while (i &gt;= j &amp;&amp; product &gt;= k) product /= nums[j ++]; res += i - j + 1; } return res; }}; 剑指 Offer II 010. 和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }}; 剑指 Offer II 014. 字符串中的变位词 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617class Solution {public: bool checkInclusion(string s1, string s2) { map&lt;char, int&gt; hash; // 存储子串各个字符数量 for (auto c: s1) hash[c] ++; int tot = hash.size(), statify = 0; // tot是字符总数，statify是s2中满足要求的数量 for (int i = 0, j = 0; i &lt; s2.size(); i ++) { if (--hash[s2[i]] == 0) statify ++; while (i - j + 1 &gt; s1.size()) { // 窗口大小小于s1.size if (hash[s2[j]] == 0) statify --; hash[s2[j ++]] ++; } if (statify == tot) return true; } return false; }}; 剑指 Offer II 017. 含有所有字符的最短字符串 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920class Solution {public: string minWindow(string s, string t) { map&lt;char, int&gt; hash; for (auto c: t) hash[c] ++; int tot = hash.size(), statify = 0; string res; for (int i = 0, j = 0; i &lt; s.size(); i ++) { if (hash[s[i]] == 1) statify ++; hash[s[i]] --; while (hash[s[j]] &lt; 0) hash[s[j ++]] ++; // 注意这里是&lt;，所以不会出现后续的不符合要求的字符顶去前面的，例如BANC，N的出现不会将B删去 if (statify == tot) { if (res.empty() || res.size() &gt; i - j + 1) { res = s.substr(j, i - j + 1); } } } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"树专题","text":"剑指 Offer II 043. 往完全二叉树添加节点 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class CBTInserter {public: TreeNode *root; int size = 0; void dfs(TreeNode *root) { if (root == nullptr) return ; size ++; dfs(root-&gt;left); dfs(root-&gt;right); } CBTInserter(TreeNode *root) { this-&gt;root = root; dfs(root); } int insert(int v) { size ++; TreeNode* fatherNode = getFatherNode(size / 2); if (size % 2 == 1) { fatherNode-&gt;right = new TreeNode(v); } else { fatherNode-&gt;left = new TreeNode(v); } return fatherNode-&gt;val; } TreeNode* getFatherNode(int n) { if (n == 1) return root; TreeNode* node = getFatherNode(n / 2); return (n % 2 == 1) ? node-&gt;right : node-&gt;left; } TreeNode* get_root() { return root; }};/** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj = new CBTInserter(root); * int param_1 = obj-&gt;insert(v); * TreeNode* param_2 = obj-&gt;get_root(); */ [剑指 Offer II 045. 二叉树最底层最左边的值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/LwUNpT/) 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int maxDepth = -1; int res; int findBottomLeftValue(TreeNode* root) { dfs (root, 0); return res; } void dfs(TreeNode *root, int depth) { if (root == nullptr) return ; if (depth &gt; maxDepth) { res = root-&gt;val; maxDepth = depth; } dfs(root-&gt;left, depth + 1); dfs(root-&gt;right, depth + 1); }}; 剑指 Offer II 047. 二叉树剪枝 - 力扣（LeetCode） (leetcode-cn.com) 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* pruneTree(TreeNode* root) { if (root == nullptr) return nullptr; auto left = pruneTree(root-&gt;left); auto right = pruneTree(root-&gt;right); if (root-&gt;val == 0 &amp;&amp; !left &amp;&amp; !right) { return nullptr; } root-&gt;left = left; root-&gt;right = right; return root; }}; 剑指 Offer II 049. 从根节点到叶节点的路径数字之和 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int sum; int sumNumbers(TreeNode* root) { dfs(root, 0); return sum; } void dfs(TreeNode *root, int path) { if (root == nullptr) return ; path = path * 10 + root-&gt;val; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) { sum += path; return ; } dfs(root-&gt;left, path); dfs(root-&gt;right, path); }}; 剑指 Offer II 050. 向下的路径节点之和 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int res; int pathSum(TreeNode* root, int targetSum) { if (root == nullptr) return 0; dfs(root, targetSum); pathSum(root-&gt;left, targetSum); pathSum(root-&gt;right, targetSum); return res; } void dfs(TreeNode *root, int sum) { if (root == nullptr) return ; sum -= root-&gt;val; if (!sum) res ++; if (root-&gt;left != nullptr) dfs(root-&gt;left, sum); if (root-&gt;right != nullptr) dfs(root-&gt;right, sum); }}; 剑指 Offer II 053. 二叉搜索树中的中序后继 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode *res; bool flag; void dfs(TreeNode *root, TreeNode *p) { if (root == NULL) return ; dfs(root-&gt;left, p); if (root-&gt;val &gt; p-&gt;val &amp;&amp; !flag) { res = root; flag = true; } dfs(root-&gt;right, p); } TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if (root == NULL) return NULL; dfs(root, p); return res; }}; 剑指 Offer II 054. 所有大于等于节点的值之和 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int sum = 0; TreeNode* convertBST(TreeNode* root) { if (root == nullptr) return nullptr; convertBST(root-&gt;right); root-&gt;val = root-&gt;val + sum; sum = root-&gt;val; convertBST(root-&gt;left); return root; }};","link":"/2022/02/18/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%93%E9%A2%98/"},{"title":"状压DP","text":"526. 优美的排列123456789101112131415161718class Solution {public: int countArrangement(int n) { int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(mask, 0)); f[0][0] = 1; // 考虑前i个数，状态为0的方案数（优美排列数量） for (int i = 1; i &lt;= n; i ++) // 枚举当前位置 for (int state = 1; state &lt;= mask; state ++) // 枚举当前状态，0为选该数，1为不选 for (int k = 1; k &lt;= n; k ++) { // 枚举当前位置填了什么数 if (!((state &gt;&gt; (k - 1)) &amp; 1)) continue; // 如果当前数在状态中为0，则跳过 if (k % i &amp;&amp; i % k) continue; // 不满足任何整除关系 // state &amp; (~(1 &lt;&lt; (k - 1))) 代表将 state 中数值 k 的位置置零 f[i][state] += f[i - 1][state &amp; ~(1 &lt;&lt; (k - 1))]; } return f[n][mask - 1]; }}; 847. 访问所有节点的最短路径1234567891011121314151617181920212223242526class Solution {public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; dist(mask, vector&lt;int&gt;(n + 1, INT_MAX)); // state和u(该状态下的最后一步)对应的步数 deque&lt;vector&lt;int&gt;&gt; d; // 存储state 和 u for (int i = 0; i &lt; n; i ++) { dist[1 &lt;&lt; i][i] = 0; d.push_back({1 &lt;&lt; i, i}); } while (!d.empty()) { auto poll = d.front(); d.pop_front(); int state = poll[0], u = poll[1], step = dist[state][u]; if (state == mask - 1) return step; for (int i: graph[u]) { if (dist[state | (1 &lt;&lt; i)][i] == INT_MAX) { dist[state | (1 &lt;&lt; i)][i] = step + 1; d.push_back({state | (1 &lt;&lt; i), i}); } } } return -1; }};","link":"/2022/02/03/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%8A%B6%E5%8E%8BDP/"},{"title":"前缀和","text":"525. 连续数组 1234567891011121314151617181920class Solution {public: int findMaxLength(vector&lt;int&gt;&amp; nums) { /* 由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 cur 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 curcur 值即可 */ unordered_map&lt;int, int&gt; hash{{0, -1}}; int cur = 0, ans = 0; for (int i = 0; i &lt; nums.size(); i ++) { cur += nums[i] == 0 ? -1 : 1; if (hash.count(cur)) { ans = max(ans, i - hash[cur]); } else { hash[cur] = i; } } return ans; }}; 剑指 Offer II 010. 和为 k 的子数组 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"背包DP","text":"279. 完全平方数 12345678910111213class Solution {public: int numSquares(int n) { // dp[i] 表示 能凑出i的完全平方数的最小数量 vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i ++) { dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j ++) dp[i] = min(dp[i], dp[i - j * j] + 1); } return dp[n]; }}; 322. 零钱兑换 12345678910111213class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 1e9); dp[0] = 0; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) dp[j] = min(dp[j], dp[j - coins[i]] + 1); if (dp[amount] == 1e9) return -1; return dp[amount]; }}; 416. 分割等和子集 12345678910111213141516class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = 0; for (auto &amp;x: nums) sum += x; int target = sum / 2; if (target * 2 != sum) return false; vector&lt;int&gt; dp(target + 1, 0); // dp[i] 表示 凑出 i 所需的价值数 for (auto &amp;x: nums) for (int j = target; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } return dp[target] == target; }}; 474. 一和零 12345678910111213141516171819202122232425class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int len = strs.size(); vector&lt;vector&lt;int&gt;&gt; cnt(len, vector&lt;int&gt;(2, 0)); for (int i = 0; i &lt; len; i ++) { int zero = 0, one = 0; for (auto &amp;c: strs[i]) { if (c == '1') one ++; else zero ++; } cnt[i][0] = zero, cnt[i][1] = one; } vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int k = 0; k &lt; len; k ++) { int zero = cnt[k][0], one = cnt[k][1]; for (int i = m; i &gt;= zero; i --) for (int j = n; j &gt;= one; j --) { f[i][j] = max(f[i][j], f[i - zero][j - one] + 1); } } return f[m][n]; }}; 494. 目标和 1234567891011121314151617181920class Solution {public: const int Offset = 1000; int findTargetSumWays(vector&lt;int&gt;&amp; a, int t) { int n = a.size(); int s = 0; for (int i: a) s += abs(i); if (abs(t) &gt; s) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2 * s + 1, 0)); dp[0][s] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = -s; j &lt;= s; j ++) { if (j - a[i - 1] &gt;= -s) dp[i][j + s] += dp[i - 1][j - a[i - 1] + s]; if (j + a[i - 1] &lt;= s) dp[i][j + s] += dp[i - 1][j + a[i - 1] + s]; } return dp[n][t + s]; }}; 518. 零钱兑换 II 1234567891011121314class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { // dp[i][j] 表示 考虑前i个物品，凑出 j 的方案数 int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) { dp[j] += dp[j - coins[i]]; } return dp[amount]; }}; 879. 盈利计划 12345678910111213141516171819class Solution {public: const int MOD = 1e9 + 7; // dp[i][j][k] 表示 前i个个物品，人数不超过j，利润至少为k的方案数 int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) { int m = group.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(minProfit + 1, 0)); for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= m; i ++) { int a = group[i - 1], b = profit[i - 1]; for (int j = n; j &gt;= a; j --) for (int k = minProfit; k &gt;= 0; k --) { dp[j][k] += dp[j - a][max(k - b, 0)]; dp[j][k] %= MOD; } } return dp[n][minProfit]; }}; 1049. 最后一块石头的重量 II 未优化空间 问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值进一步分析：要让差值小,两堆石头的重量都要接近sum/2;我们假设两堆分别为A,B,A&lt;sum/2,B&gt;sum/2,若A更接近sum/2,B也相应更接近sum/2进一步转化：将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;、 123456789101112131415161718// d[i][j]代表考虑前 i 个物品（数值），凑成总和不超过 j 的最大价值。class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(t + 1, 0)); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = 0; j &lt;= t; j ++) { dp[i][j] = dp[i - 1][j]; if (j &gt;= x) dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + x); } } return sum - 2 * dp[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;int&gt; dp(t + 1, 0); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = t; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } } return sum - 2 * dp[t]; }}; 1155. 掷骰子的N种方法 未优化空间 1234567891011121314class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(t + 1, 0)); f[0][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 0; j &lt;= t; j ++) for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[i][j] = (f[i][j] + f[i - 1][j - k]) % MOD; } return f[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;int&gt; f(t + 1, 0); f[0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = t; j &gt;= 0; j --) { f[j] = 0; //由于我们直接是在 f[i][j]f[i][j] 格子的基础上进行方案数累加，因此在计算 f[i][j]f[i][j] 记得手动置零。 for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[j] = (f[j] + f[j - k]) % MOD; } } return f[t]; }}; 1449. 数位成本和为目标值的最大数字 1234567891011121314151617181920212223242526class Solution {public: // dp[i][j] 表示 考虑前i个物品，总成本为j的最大整数长度 string largestNumber(vector&lt;int&gt;&amp; cost, int t) { int n = cost.size(); vector&lt;int&gt; dp(t + 1, INT_MIN); dp[0] = 0; for (int i = 1; i &lt;= n; i ++) { int x = cost[i - 1]; for (int j = x; j &lt;= t; j ++) { dp[j] = max(dp[j], dp[j - x] + 1); } } if (dp[t] &lt; 0) return &quot;0&quot;; string res = &quot;&quot;; for (int i = 9, j = t; i &gt;= 1; i --) { int x = cost[i - 1]; while (j &gt;= x &amp;&amp; dp[j] == dp[j - x] + 1) { res += to_string(i); j -= x; } } return res; }}; 1995. 统计特殊四元组 123456789101112131415161718192021class Solution {public: int countQuadruplets(vector&lt;int&gt;&amp; nums) { // dp[i][j][k] 考虑前i个数，恰好凑出j，使用个数为k的方案数 int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(110, vector&lt;int&gt;(4, 0))); f[0][0][0] = 1; for (int i = 1; i &lt;= n; i ++) { int x = nums[i - 1]; for (int j = 0; j &lt; 110; j ++) for (int k = 0; k &lt; 4; k ++) { f[i][j][k] += f[i - 1][j][k]; if (j &gt;= x &amp;&amp; k &gt;= 1) f[i][j][k] += f[i - 1][j - x][k - 1]; } } int res = 0; for (int i = 3; i &lt; n; i ++) res += f[i][nums[i]][3]; return res; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85DP/"},{"title":"记忆化搜索","text":"87. 扰乱字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int Y = 1, N = -1; string s1, s2; bool isScramble(string _s1, string _s2) { s1 = _s1, s2 = _s2; if (s1 == s2) return true; if (s1.size() != s2.size()) return false; int n = s1.size(); // cache表示s1从i开始，s2从j开始 len 位，是否形成扰动字符串 cache.resize(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0))); return dfs(0, 0, n); } bool dfs(int i, int j, int len) { if (cache[i][j][len] != 0) return cache[i][j][len] == Y; string a = s1.substr(i, len), b = s2.substr(j, len); if (a == b){ cache[i][j][len] = Y; return true; } if (!check(a, b)) { cache[i][j][len] = N; return false; } for (int k = 1; k &lt; len; k ++) { if (dfs(i, j, k) &amp;&amp; dfs(i + k, j + k, len - k)) { cache[i][j][len] = Y; return true; } if (dfs(i, len - k + j, k) &amp;&amp; dfs(i + k, j, len - k)) { cache[i][j][len] = Y; return true; } } cache[i][j][len] = N; return false; } bool check(string a, string b) { if (a.size() != b.size()) return false; vector&lt;int&gt; cnt1(26, 0), cnt2(26, 0); for (auto c: s1) { cnt1[c - 'a'] ++; } for (auto c: s2) { cnt2[c - 'a'] ++; } return cnt1 == cnt2; }}; 375. 猜数字大小 II12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; int getMoneyAmount(int n) { cache.resize(n + 1, vector&lt;int&gt;(n + 1, 0)); return dfs(1, n); } int dfs(int l, int r) { if (l &gt;= r) return 0; if (cache[l][r] != 0) return cache[l][r]; int ans = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cnt = max(dfs(l, x - 1), dfs(x + 1, r)) + x; ans = min(ans, cnt); } cache[l][r] = ans; return ans; }}; 403. 青蛙过河1234567891011121314151617181920212223242526272829303132class Solution {public: unordered_map&lt;string, bool&gt; cache; // 存储u下标跳k步有没有方案 unordered_map&lt;int, int&gt; map; // 存储每个石块对应的下标 bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); for (int i = 0; i &lt; n; i ++) { map.insert({stones[i], i}); } if (!map.count(1)) return false; return dfs(stones, n, 1, 1); } bool dfs(vector&lt;int&gt; &amp;stones, int n, int u, int k) { if (u == n - 1) return true; string key = to_string(u) + '_' + to_string(k); if (cache.count(key)) return cache[key]; for (int i = -1; i &lt;= 1; i ++) { if (k + i == 0) continue; int next = stones[u] + i + k; // 下一个跳跃点 if (map.count(next)) { bool cur = dfs(stones, n, map[next], k + i); cache.insert({key, cur}); if (cur) return true; } } cache.insert({key, false}); return false; }}; 494. 目标和12345678910111213141516171819202122class Solution {public: unordered_map&lt;string, int&gt; cache; // 表示从u下标,当前计算结果为string，的方案数int int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { return dfs(nums, target, 0, 0); } int dfs(vector&lt;int&gt; &amp;nums, int target, int u, int cur) { string key = to_string(u) + '_' + to_string(cur); if (cache.count(key)) return cache[key]; if (u == nums.size()) { cache.insert({key, cur == target ? 1: 0}); return cache[key]; } int left = dfs(nums, target, u + 1, cur - nums[u]); int right = dfs(nums, target, u + 1, cur + nums[u]); cache.insert({key, left + right}); return cache[key]; }}; 552. 学生出勤记录 II1234567891011121314151617181920212223class Solution {public: // cache 是指 下标为u，连续a个数为acnt，l个数为lcnt的方案数 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int mod = (int)1e9 + 7; int checkRecord(int n) { cache.resize(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3, -1))); return dfs(n, 0, 0); } int dfs(int u, int acnt, int lcnt) { if (acnt &gt;= 2) return 0; if (lcnt &gt;= 3) return 0; if (u == 0) return 1; if (cache[u][acnt][lcnt] != -1) return cache[u][acnt][lcnt]; int ans = 0; ans = dfs(u - 1, acnt + 1, 0) % mod; // A ans = (ans + dfs(u - 1, acnt, lcnt + 1)) % mod; // L ans = (ans + dfs(u - 1, acnt, 0)) % mod; // P cache[u][acnt][lcnt] = ans; return ans; }}; 576. 出界的路径数12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int MOD = (int) 1e9 + 7; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { cache.resize(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, -1))); return dfs(m, n, maxMove, startRow, startColumn); } int dfs(int m, int n, int u, int x, int y) { if (x &gt;= m || x &lt; 0) return 1; if (y &gt;= n || y &lt; 0) return 1; if (u == 0) return 0; if (cache[u][x][y] != -1) return cache[u][x][y]; int ans = 0; ans = dfs(m, n, u - 1, x + 1, y) % MOD; ans = (ans + dfs(m, n, u - 1, x, y + 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x, y - 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x - 1, y)) % MOD; cache[u][x][y] = ans; return ans; }}; 1137. 第 N 个泰波那契数12345678910111213class Solution {public: int cache[40]; int tribonacci(int n) { if (n == 0) return 0; if (n == 1 || n == 2) return 1; if (cache[n] != 0) return cache[n]; cache[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3); return cache[n]; }}; 剑指 Offer 10- I. 斐波那契数列1234567891011121314class Solution {public: int mod = (int) 1e9 + 7; int cache[110]; int fib(int n) { if (n &lt;= 1) return n; if (cache[n] != 0) return cache[n]; cache[n] = fib(n - 1) + fib(n - 2); cache[n] %= mod; return cache[n]; }}; 638. 大礼包 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;int&gt; price; vector&lt;vector&lt;int&gt;&gt; special; vector&lt;int&gt; needs; map&lt;vector&lt;int&gt;, int&gt; cache; int shoppingOffers(vector&lt;int&gt;&amp; _price, vector&lt;vector&lt;int&gt;&gt;&amp; _special, vector&lt;int&gt;&amp; _needs) { price = _price; special = _special; needs = _needs; return dfs(needs); } int dfs(vector&lt;int&gt; needs) { if (cache.count(needs)) { return cache[needs]; } int n = needs.size(); int minN = 0; for (int i = 0; i &lt; n; i ++) { minN += price[i] * needs[i]; } for (int i = 0; i &lt; special.size(); i ++) { bool flag = true; vector&lt;int&gt; nextNeeds = needs; for (int j = 0; j &lt; n; j ++) { if (special[i][j] &gt; nextNeeds[j]) flag = false; nextNeeds[j] -= special[i][j]; } if (!flag) continue; minN = min(minN, dfs(nextNeeds) + special[i][n]); } return cache[needs] = minN; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"title":"netty入门（一）","text":"1 Netty是什么​ Netty是一个异步的，基于事件驱动的网络应用框架，用于快速开发高性能，高可靠的网络I/O程序。并且Netty主要针对TCP协议下，面对Client端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。 ​ Netty本质上是一个NIO框架，使用于服务器通讯相关的多种应用场景。 思考，NIO是一个同步非阻塞模型，而又说Netty是异步的，这不是会矛盾吗 ​ 首先，我们要知道，这两者是没有关系的，Netty所说的异步是指异步事件驱动，用户使用Channel进行IO操作，会立即返回。但是IO操作的任务是提交给Netty的NIO底层去进行处理的。打个比方，你给客服打电话请求注销手机卡，但客服可能不会马上帮你注销，会给你一个回复说注销后会发短信通知你（回调函数），接着，这个请求就交由底层相关注销手机卡的人员进行处理，处理完后再告诉客服，客服再发短信。 2 IO模型​ IO模型的简单理解：就是用什么样的通道进行数据的发送和接收 ​ Java支持3种网络编程模型I/O模式：BIO，NIO，AIO BIO：同步阻塞，服务实现模式为一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成性能开销。 NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理。 AIO：异步非阻塞，AlO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。 BIO，NIO，AIO适用场景分析 BIO方式适用于连接数目比较小且固定的架构 NIO方式适用于连接数目多且连接比较短的架构，比如聊天服务器，弹幕系统，服务器间通信等 AIO方式适用于连接数目多且连接比较长的服务，比如相册服务器 BIOBIO编程简单流程 服务器端启动一个serverSocket 客户端启动socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯 客户端发出请求后,先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝 如果有响应,客户端线程会等待请求结束后，在继续执行 NIO​ NIO有三大核心部分:Channel(通道)，Buffer(缓冲区)，Selector(选择器) Channel，Buffer，Selector之间的关系 每个channel都会对应一个Bufer Selectot 对对应一个线程，一个线程对应多个channel(连接) 该图反应了有三个channel注册到该selector l程序 程序切换到哪个channel是有事件决定的, Event 就是一个重要的概念5) Selector会根据不同的事件,在各个通道上切换 Buffer就是一个内存块，底层是有一个数组 数据的读取写入是通过Buffer,这个和BiO, BIO中要么是输入流，或者是输出流,不能双向，但是NIO的Buffer是可以读也可以写,需要flip方法切换 channel是双向的,可以返回底层操作系统的情况,比如Linux，底层的操作系统通道就是双向的 BIO VS NIO BIO以流的方式处理数据,而NIO以块的方式处理数据,块,I/o的效率比流I/o高很多 BIO是阻塞的，NIO则是非阻塞的 BlO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器)用于监听多个通道的事件（比如:连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 3 NIO基本介绍3.1 Buffer​ 缓冲区本质是一个可以读写数据的内存块，可以理解是一个容器对象。 在NIO中，Buffer是一个顶层父类，它是一个抽象类 Buffer类定义了所有的缓冲区都具有的四个属性提供关于其所包含的数据元素的信息 3.2 Channel基本介绍 1）通道可以同时进行读写 2）通道可以实现异步读写数据 3）通道可以从缓冲中读数据，也可以写数据到缓冲 关于Buffer和 Channel的注意事项和细节 ByteBuffer支持类型化的put和 get, put放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有BufferUnderflowException异常。 可以将一个普通Buffer转成只读Buffer NIO还提供了MappedByteBuffer，可以让文件直接在内存（堆外的内存〉中进行修改，而如何同步到文件由NIO来完成 前面我们讲的读写操作，都是通过一个Buffer完成的，NIO还支持通过多个Buffer(即 Buffer数组)完成读写操作，即 Scattering 和 Gathering 3.3 Selector基本介绍 Java的 NIO，用非阻塞的I0方式。可以用一个线程，处理多个的客户端连接，就会使用到selector(选择器) Selector能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。 只有在连接真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 避免了多线程之间的上下文切换导致的开销 4 零拷贝4.1 基本介绍​ 零拷贝是指没有CPU拷贝的技术。 4.2 传统IO数据读写​ 在没有DMA技术时，数据的传输过程需要CPU的全程参与，这是很消耗性能的 ​ 什么是DMA（直接内存访问）技术呢？在进⾏ I/O 设备和内存的数据传输的时候，数据搬运的⼯作全部交给DMA控制器，⽽CPU不再参与任何与数据搬运相关的事情，这样CPU就可以去处理别的事务。 ​ 加入该技术，就有了下图 ​ 继续分析该读写方式有多糟糕 ​ 从上图可以看出，期间发生了4次用户态与内核态的上下文切换，以及4次数据拷贝 ​ 由此read和write是系统调用，每次都会发生2次上下文切换 ​ 而4次数据拷贝是 第⼀次拷⻉，把磁盘上的数据拷⻉到操作系统内核的缓冲区⾥，这个拷⻉的过程是通过 DMA 搬运的 第⼆次拷⻉，把内核缓冲区的数据拷⻉到⽤户的缓冲区⾥，于是我们应⽤程序就可以使⽤这部分数据了，这个拷⻉到过程是由 CPU 完成的。 第三次拷⻉，把刚才拷⻉到⽤户的缓冲区⾥的数据，再拷⻉到内核的 socket 的缓冲区⾥，这个过程依然还是由 CPU 搬运的。 第四次拷⻉，把内核的 socket 缓冲区⾥的数据，拷⻉到⽹卡的缓冲区⾥，这个过程⼜是由 DMA 搬运的。 4.3 mmap优化​ mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据映射到⽤户空间，这样，操作系统内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。 ​ 这里当用户态调用write时，操作系统会将内核缓冲区的数据拷贝到socket缓冲区中，这发生在内核态，从而减少一次数据拷贝的过程 ​ 但这仍然需要4次上下文切换，3次数据拷贝 4.4 sendFile优化​ 在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 sendfile() 。 12345678910#include &lt;sys/socket.h&gt;/* 参数说明： 1. 目的端文件描述符 2. 源端文件描述符 3. 源端偏移量 4. 复制数据的长度 @return 实际复制数据的长度*/ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); ​ 该系统调用的好处有二： 可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。 可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。 ​ 但这还不是真正零拷贝，可以发现图中②还有个CPU拷贝 ​ 只有当网卡支持SG-DMA技术时，才可以实现真正的零拷贝 ​ 使用SG-DMA技术如下图 第⼀步，通过 DMA 将磁盘上的数据拷⻉到内核缓冲区⾥； 第⼆步，缓冲区描述符和数据⻓度传到 socket 缓冲区，这样⽹卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷⻉到⽹卡的缓冲区⾥，此过程不需要将数据从操作系统内核缓冲区拷⻉到 socket缓冲区中，这样就减少了⼀次数据拷⻉； 5 线程模型5.1 基本介绍​ 从不同角度来看，对操作系统来说，线程模型往往指的是用户线程和内核线程的对应关系。而在本文中，指的是线程/进程处理连接请求的一种模型。 ​ 前文我们知道，当一个线程要处理很多请求时，使用read不断轮询判断是否有数据是十分低效的，而由此衍生出的IO多路复用就是解决该问题的方案，它会用一个系统调用函数来监听所有关心的连接，也就是可以在一个监控线程里面监控很多连接。它的检测方法如下： 如果没有事件发⽣，线程只需阻塞在这个系统调⽤，⽽⽆需像前⾯的线程池⽅案那样轮训调⽤read操作来判断是否有数据。 如果有事件发⽣，内核会返回产⽣了事件的连接，线程就会从阻塞状态返回，然后在⽤户态中再处理这些连接对应的业务即可。 ​ 但由于传统的IO多路复用编写程序十分繁琐，开发效率不高，由此衍生除了Reactor模式。 5.2 传统阻塞I/O服务模型 ​ 可以看出来，这就是种阻塞IO，每个连接都需要独立的线程去进行处理，当并发数很大时，就会创建大量线程，占用很大系统资源。而且当连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read操作，造成线程资源浪费。 5.3 Reactor模式​ Reactor模式指的是对事件反应，也就是来了一个事件，Reactor就有相应的反应/响应。即即 I/O 多路复⽤监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程/线程。 Reactor模式主要由Reactor和处理资源池这两个核⼼部分组成，它俩负责的事情如下： Reactor负责监听和分发事件，事件类型包含连接事件、读写事件； 处理资源池负责处理事件，如read-&gt; 业务逻辑 -&gt;send； Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于： Reactor的数量可以只有⼀个，也可以有多个； 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程 由此，产生了四种方案： 单Reactor单进程 / 线程； 单Reactor多进程 / 线程； 多Reactor单进程 / 线程； 多 Reactor多进程 / 线程 ​ 由于，多Reactor单进程 / 线程实现⽅案相⽐单Reactor单进程 / 线程⽅案，不仅复杂⽽且也没有性能优势，因此实际中并没有应⽤。 5.3.1 单Reactor单进程/线程​ 下面介绍单进程的情况，在c实现中，一般都是这种，因为 C 语编写完的程序，运⾏后就是⼀个独⽴的进程，不需要在进程中再创建线程。而Java 程序是跑在 Java 虚拟机这个进程上⾯的，虚拟机中有很多线程，我们写的 Java 程序只是其中的⼀个线程⽽已。 可以看到进程⾥有 Reactor、Acceptor、Handler这三个对象： Reactor 对象的作⽤是监听和分发事件； Acceptor 对象的作⽤是获取连接； Handler 对象的作⽤是处理业务； ​ 对象⾥的 select、accept、read、send 是系统调⽤函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch是分发事件操作。 流程 Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch进⾏分发，具体分发给 Acceptor 对象还是 Handler对象，还要看收到的事件类型； 如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理，Acceptor 对象会通过 accept ⽅法 获取连接，并创建⼀个Handler对象来处理后续的响应事件； 如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应； Handler对象通过 read-&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。 优缺点 优点：全部⼯作都在同⼀个进程内完成，所以实现起来⽐较简单，不需要考虑进程间通信，也不⽤担⼼多进程竞争。 缺点： 第⼀个缺点，因为只有⼀个进程，⽆法充分利⽤ 多核 CPU 的性能； 第⼆个缺点，Handler 对象在业务处理时，整个进程是⽆法处理其他连接的事件的，如果业务处理耗 ​ 所以单 Reactor 单进程的⽅案不适⽤计算机密集型的场景，只适⽤于业务处理⾮常快速的场景 5.3.2 单Reactor多线程/进程 详细说⼀下这个⽅案： Reactor 对象通过select（IO 多路复⽤接⼝） 监听事件，收到事件后通过dispatch进⾏分发，具体分发给Acceptor对象还是 Handler 对象，还要看收到的事件类型； 如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理，Acceptor 对象会通过 accept ⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件； 如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应； 上⾯的三个步骤和单 Reactor 单线程⽅案是⼀样的，接下来的步骤就开始不⼀样了： Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给⼦线程⾥的 Processor 对象进⾏业务处理； ⼦线程⾥的 Processor 对象就进⾏业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send ⽅法将响应结果发送给 client； 优缺点 优点 ​ 能够充分利用多核CPU的处理能力 缺点 涉及共享数据的竞争 因为⼀个Reactor对象承担所有事件的监听和响应，⽽且只在主线程中运⾏，在⾯对瞬间⾼并发的场景时，容易成为性能的瓶颈的地⽅。 5.3.3 多Reactor多进程/线程 ⽅案详细说明如下： 主线程中的 MainReactor对象通过 select监控连接建⽴事件，收到事件后通过 Acceptor对象中的accept获取连接，将新的连接分配给某个⼦线程； ⼦线程中的 SubReactor对象将 MainReactor对象分配的连接加⼊ select继续进⾏监听，并创建⼀个Handler ⽤于处理连接的响应事件。 如果有新的事件发⽣时，SubReactor对象会调⽤当前连接对应的 Handler 对象来进⾏响应。 Handler 对象通过 read -&gt; 业务处理 -&gt;send的流程来完成完整的业务流程。 多 Reactor多线程的⽅案虽然看起来复杂的，但是实际实现时⽐单Reactor多线程的⽅案要简单的多，原因如下： 主线程和⼦线程分⼯明确，主线程只负责接收新连接，⼦线程负责完成后续的业务处理。 主线程和⼦线程的交互很简单，主线程只需要把新连接传给⼦线程，⼦线程⽆须返回数据，直接就可以在⼦线程将处理结果发送给客户端。 Netty和Memcache都采用了多Reactor多线程的方案 总结 生活案例理解 单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服 单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待 主从 Reactor 多线程，多个前台接待员，多个服务生 参考【网络编程】Netty采用的NIO为什么是同步非阻塞的？_牛客博客 (nowcoder.net) 《图解系统》——小林coding","link":"/2022/03/08/netty/netty%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"MySQL中的锁机制","text":"1 基本介绍​ 锁机制用于管理对共享资源的并发访问。对于不同引擎，所使用的锁机制是不同的。接下来会对InnoDB存储引擎和MyISAM进行分析 1.1 行锁与表锁​ 顾名思义：表锁就是对整张表进行加锁，而行锁则是锁定某行、某几行数据或者行之间的间隙。 ​ 各引擎对锁的支持情况如下： 行锁 表锁 InnoDB √ √ MyISAM √ 行锁 ​ 行锁是作用在索引上的。 ​ InnoDB中，每一个InnoDB表都需要一个聚簇索引，有且只有一个。如果为该表设置了一个主键，那么MySQL将主键作为聚簇索引；如果你不定义一个主键，那么MySQL会把第一个唯一索引（NOT NULL）作为聚簇索引；如果这两种情况都不是，那就创建一个GEN_CLUST_INDEX的隐藏聚簇索引。 ​ 因为是聚簇索引，所以B+树上的叶子节点都存储了数据行，那么如果现在是二级索引呢？InnoDB中的二级索引的叶节点存储的是主键值（或者说聚簇索引的值），所以通过二级索引查询数据时，还需要将对应的主键去聚簇索引中再次进行查询。 ​ 以两条SQL的执行为例，讲解下InnoDB对于单行数据的加锁原理 12update user set age = 10 where id = 49;update user set age = 10 where name = 'Tom'; ​ 第一条SQL使用主键查询，只需要在 id = 49 这个主键索引上加上锁。第二条 SQL 使用二级索引来查询，那么首先在 name = Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id = 49 这个主键索引上加锁。 ​ 也就是说使用主键索引需要加一把锁，使用二级索引需要在二级索引和主键索引上各加一把锁。 ​ 根据索引对单行数据进行更新的加锁原理了解了，那如果更新操作涉及多个行呢，比如下面 SQL 的执行场景。 1update user set age = 10 where id &gt; 49; ​ 上述 SQL 的执行过程如下图所示。MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新改行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止。 表锁 ​ 前面说过，查询列有索引时，InnoDB就会使用行锁锁住对应的索引行。但是没有索引时，就需要使用表锁，把整张表锁住了 ​ 表锁使用的是一种一次性锁技术，也就是说，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。 ​ 除了使用 unlock tables 显示释放锁之外，会话持有其他表锁时执行lock table 语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者 begin 开启事务时，也会释放之前持有的锁。 ​ 表锁由 MySQL Server 实现，行锁则是存储引擎实现，不同的引擎实现的不同。在 MySQL 的常用引擎中 InnoDB 支持行锁，而 MyISAM 则只能使用 MySQL Server 提供的表锁。 两种锁的比较 ​ 表锁：加锁过程的开销小，加锁的速度快；不会出现死锁的情况；锁定的粒度大，发生锁冲突的几率大，并发度低； 一般在执行DDL语句时会对整个表进行加锁，比如说 ALTER TABLE 等操作； 如果对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话，那么将会锁整张表； 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。 行锁：加锁过程的开销大，加锁的速度慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高； 最大程度的支持并发，同时也带来了最大的锁开销。 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。 行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 2 MyISAM表锁2.1 MyISAM表级锁模式 表共享读锁（Table Read Lock）：不会阻塞其他线程对同一个表的读操作请求，但会阻塞其他线程的写操作请求； 表独占写锁（Table Write Lock）：一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，都会被阻塞； ​ 默认情况下，写锁比读锁具有更高的优先级；当一个锁释放后，那么它会优先相应写锁等待队列中的锁请求，然后再是读锁中等待的获取锁的请求。 ​ 这种设定也是MyISAM表不适合于有大量更新操作和查询操作的原因。 大量更新操作可能会造成查询操作很难以获取读锁，从而过长的阻塞。 一些需要长时间运行的查询操作，也会使得线程“饿死”，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短的时间内完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。） 我们可以通过一些设置来调节MyISAM的调度行为： 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利； 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低； 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级； 给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。 2.2 MyISAM对表加锁分析​ MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。 ​ 在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。 ​ MyISAM存储引擎支持并发插入，以减少给定表的读操作和写操作之间的争用： ​ 如果MyISAM表在数据文件中没有空闲块（由于删除或更新导致的空行），则行始终插入数据文件的末尾。在这种情况下，你可以自由混合并发使用MyISAM表的 INSERT 和 SELECT 语句而不需要加锁（你可以在其他线程进行读操作的情况下，同时将行插入到MyISAM表中）。 ​ 如果文件中有空闲块，则并发插入会被禁止，但当所有的空闲块重新填充有新数据时，它又会自动启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。 当concurrent_insert=0时，不允许并发插入功能。 当concurrent_insert=1时，允许对没有空闲块的表使用并发插入，新数据位于数据文件结尾（缺省）。 当concurrent_insert=2时，不管表有没有空想快，都允许在数据文件结尾并发插入。 2.3 显式加表锁的应用​ 上面已经提及了表锁的加锁方式，一般表锁都是隐式加锁的，不需要我们去主动声明，但是也有需要显式加锁的情况，这里简单做下介绍： 给MyISAM表显式加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表 order_detail，其中记录有订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL： 12SELECT SUM(total) FROM orders;SELECT SUM(subtotal) FROM order_detail; ​ 这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是： 1234LOCK tables orders read local,order_detail read local;SELECT SUM(total) FROM orders;SELECT SUM(subtotal) FROM order_detail;Unlock tables; 3 InnoDB行锁与表锁3.1 InnoDB锁模式 InnoDB中的行锁 InnoDB实现了以下两种类型的行锁 共享锁（S）：加了锁的记录，所有事务都能去读取但不能修改，同时阻止其他事务获得相同数据集的排他锁； 排他锁（X）：允许已经获得排他锁的事务去更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁； 补充：行锁是加在索引上的，如果当你的查询语句不走索引的话，那么它就会升级到表锁，最终造成效率低下，所以在写SQL语句时需要特别注意。 InnoDB表锁——意向锁 ​ 由于表锁和行锁虽然锁定范围不同，但是会相互冲突。当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。 ​ 意向锁也是表级锁，分为读意向锁（IS锁）和写意向锁（IX锁）。当事务要在记录上加上行锁时，要首先在表上加上意向锁。这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了，从而就能提高效率。 ​ 意向锁之间是不会产生冲突的，它只会阻塞表级读锁或写锁。意向锁不于行级锁发生冲突。 3.2 锁模式的兼容矩阵​ 下面表显示了了各种锁之间的兼容情况： X IX S IS X IX 兼容 兼容 S 兼容 兼容 IS 兼容 兼容 兼容 （注意上面的X与S是说表级的X锁和S锁，意向锁不和行级锁发生冲突） 如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；如果两者不兼容，那么该事务就需要等待锁的释放。 3.3 InnoDB的加锁方法 意向锁是 InnoDB 自动加的，不需要用户干预； 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加上排他锁； 对于普通的SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集添加共享锁或排他锁 共享锁（S）：select * from table_name where ... lock in share mode。此时其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X）：select * from table_name where ... for update。其他session可以查询记录，但是不能对该记录加共享锁或排他锁，只能等待锁释放后在加锁。 select for update ​ 在执行这个select查询语句的时候，会将对应的索引访问条目加上排他锁（X锁），也就是说这个语句对应的锁就相当于update带来的效果; 使用场景：为了让确保自己查找到的数据一定是最新数据，并且查找到后的数据值允许自己来修改，此时就需要用到select for update语句； 性能分析：select for update语句相当于一个update语句。在业务繁忙的情况下，如果事务没有及时地commit或者rollback可能会造成事务长时间的等待，从而影响数据库的并发使用效率。 select lock in share mode ​ in share mode子句的作用就是将查找的数据加上一个share锁，这个就是表示其他的事务只能对这些数据进行简单的 select 操作，而不能进行 DML 操作。 使用场景：为了确保自己查询的数据不会被其他事务正在修改，也就是确保自己查询到的数据是最新的数据，并且不允许其他事务来修改数据。与select for update不同的是，本事务在查找完之后不一定能去更新数据，因为有可能其他事务也对同数据集使用了 in share mode的方式加上了S锁； 性能分析：select lock in share mode语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit或者rollback也可能会造成大量的事务等待。 4 行锁的类型​ 接下来根据应用场景的不同，又可以将行锁进行进一步的划分：Next-Key Lock、Gap Lock、Record Lock以及插入意向GAP锁。 ​ 不同的锁锁定的位置是不同的，比如说记录锁只锁定对应的记录，而间隙锁锁住记录和记录之间的间隙，Next-key Lock则锁住所属记录之间的间隙。不同的锁类型锁定的范围大致如图所示： 4.1 记录锁（Record Lock）​ 记录锁最简单的一种行锁形式。 4.2 间隙锁（Gap Lock）​ 当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（参考上面所说的空闲块）的记录，就叫做间隙。 ​ 从上面这句话可以表明间隙锁是所在两个存在的索引之间，是一个开区间，像最开始的那张索引图，15和18之间，是有（16，17）这个间隙存在的。 ​ 共享间隙锁与独占间隙锁之间是没有区别的，两者之间并不冲突。其存在的目的都是防止其他事务往间隙中插入新的纪录，故而一个事务所采取的间隙锁是不会去阻止另外一个事务在同一个间隙中加锁的。 ​ 在 RU 和 RC 两种隔离级别下，即使使用 select in share mode 或 select for update，也无法防止幻读（读后写的场景）。因为这两种隔离级别下只会有行锁，而不会有间隙锁。而如果是 RR 隔离级别的话，就会在间隙上加上间隙锁。 4.3 临键锁（Next-key Lock）​ 临键锁是记录锁与与间隙锁的结合，所以临键锁与间隙锁是一个同时存在的概念，并且临键锁是个左开有闭的却比如(16, 18]。 ​ MySQL 默认隔离级别是RR，在这种级别下，如果你使用 select in share mode 或者 select for update 语句，那么InnoDB会使用临键锁（记录锁 + 间隙锁），因而可以防止幻读； ​ 但还有种情况是隔离级别是 RR，如果使用普通的select语句，那么此时 InnoDB 引擎将是使用快照读，应该是不会有幻读幻读问题。 4.4 插入意向锁（Insert Intention Lock）​ 不同类型的锁之间的兼容如下表所示： RECORED GAP NEXT-KEY II GAP（插入意向锁） RECORED 兼容 兼容 GAP 兼容 兼容 兼容 兼容 NEXT-KEY 兼容 兼容 II GAP 兼容 兼容 （其中行表示已有的锁，列表示意图加上的锁） 其中，第一行表示已有的锁，第一列表示要加的锁。插入意向锁较为特殊，所以我们先对插入意向锁做个总结，如下： 插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的； 插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key锁，则会阻塞。 其他类型的锁的规则较为简单： 间隙锁不和其他锁（不包括插入意向锁）冲突； 记录锁和记录锁冲突，Next-key锁和 Next-key 锁冲突，记录锁和 Next-key锁冲突； 参考【MySQL】MySQL中的锁机制 - 周二鸭 - 博客园 (cnblogs.com) 《MySQL是怎样运行的》 本文很多都摘抄自己其他文章，仅作个人学习使用，未进行传播，如有侵权，联系即删","link":"/2022/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"},{"title":"Spring Bean生命周期","text":"1 前言​ Bean是由Spring IoC容器实例化，组装和管理的对象，并且Spring Bean的生命周期完全由容器控制。这里所说的生命周期主要是指singleton bean，对于prototype的bean，Spring在创建好交给使用者后将不会管理后续的生命周期。 ​ 对于Spring Bean的生命周期，本文将会从以下两部分将： 生命周期的概要流程 扩展点的作用 2 Bean生命周期概述​ 我们知道对于普通的Java对象来说，它们的生命周期是： 创建阶段(Created) 应用阶段(In Use) 不可见阶段(Invisible) 不可达阶段(Unreachable) 收集阶段(Collected) 终结阶段(Finalized) 对象空间重分配阶段(De-allocated) ​ 而对于Spring Bean来说，可以概述为4个阶段： 实例化（Instantiation） 属性赋值（Populate） 初始化（Initialization） 销毁（Destruction） 从图中分析 实例化：第1步，实例化一个bean对象 属性赋值：第2步，为bean对象设置相关属性和依赖 初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用； 销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。 ​ 下面结合代码来直观的看下， 12345678910111213141516171819202122232425// AbstractAutowireCapableBeanFactory.javaprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // 1. 实例化 BeanWrapper instanceWrapper = null; if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } Object exposedObject = bean; try { // 2. 属性赋值 populateBean(beanName, mbd, instanceWrapper); // 3. 初始化 exposedObject = initializeBean(beanName, exposedObject, mbd); } // 4. 销毁-注册回调接口 try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } return exposedObject;} ​ 由于初始化较复杂，包含了第3~7步，所以我们进到 initializeBean() 方法里具体看下其过程（注释的序号对应图中序号）： 123456789101112131415161718192021222324252627282930313233343536// AbstractAutowireCapableBeanFactory.javaprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { // 3. 检查 Aware 相关接口并设置相关依赖 if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } // 4. BeanPostProcessor 前置处理 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } // 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法 // 6. 若配置自定义的 init-method方法，则执行 try { invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } // 7. BeanPostProceesor 后置处理 if (mbd == null || !mbd.isSynthetic()) { wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} ​ 在 invokInitMethods() 方法中会检查 InitializingBean 接口和 init-method 方法 ​ 销毁的过程也与其类似： 12345678910111213141516171819202122232425262728// DisposableBeanAdapter.javapublic void destroy() { // 9. 若实现 DisposableBean 接口，则执行 destory()方法 if (this.invokeDisposableBean) { try { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; { ((DisposableBean) this.bean).destroy(); return null; }, this.acc); } else { ((DisposableBean) this.bean).destroy(); } } } // 10. 若配置自定义的 detory-method 方法，则执行 if (this.destroyMethod != null) { invokeCustomDestroyMethod(this.destroyMethod); } else if (this.destroyMethodName != null) { Method methodToInvoke = determineDestroyMethod(this.destroyMethodName); if (methodToInvoke != null) { invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke)); } }} ​ 这里额外说一下为什么JVM类加载是初始化再实例化，而Spring Bean是先实例化再初始化，有什么不同？（刚开始困扰了一会儿QAQ） ​ 首先，要明确。类加载是JVM的基本过程，而Spring是在其上层的实现，这两个不在同个层次 ​ 在JVM中，初始化是在类级别的，主要功能是为静态成员赋值，执行静态代码块，执行&lt;clinit&gt;方法。实例化是指在堆区分配空间，执行实例对象初始化，设置引用变量指向刚分配的内存地址（注意实例化也有一个初始化，这次初始化就会调用构造函数了，这是实例对象级别的） ​ 在Spring中，实例化就是创造出一个bean对象了，包含了JVM的初始化和实例化；初始化就是给对象中的属性赋值，相当于人为操作。 3 扩展点的作用3.1 Aware接口​ 若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源。 Spring 中提供的 Aware 接口有： BeanNameAware：注入当前 bean 对应 beanName； BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader； BeanFactoryAware：注入 当前BeanFactory容器 的引用。 其代码实现如下： 123456789101112131415// AbstractAutowireCapableBeanFactory.javaprivate void invokeAwareMethods(final String beanName, final Object bean) { if (bean instanceof Aware) { if (bean instanceof BeanNameAware) { ((BeanNameAware) bean).setBeanName(beanName); } if (bean instanceof BeanClassLoaderAware) { ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); } if (bean instanceof BeanFactoryAware) { ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); } }} ​ 以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。 EnvironmentAware：注入 Enviroment，一般用于获取配置属性； EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析； ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。 123456789101112131415161718192021222324252627// ApplicationContextAwareProcessor.javaprivate void invokeAwareInterfaces(Object bean) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware)bean).setMessageSource(this.applicationContext); } if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext); }} 3.2 容器级的方法（BeanPostProcessor 一系列接口） 3.2.1 InstantiationAwareBeanPostProcessor 源码分析​ 从源码中发现InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor 12345678910111213141516171819202122232425262728293031323334package org.springframework.beans.factory.config;import java.beans.PropertyDescriptor;import org.springframework.beans.BeansException;import org.springframework.beans.PropertyValues;import org.springframework.lang.Nullable;public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor { @Nullable default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException { return null; } default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { return true; } @Nullable default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { return null; } @Deprecated @Nullable default PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException { return pvs; }} 1234567891011121314151617package org.springframework.beans.factory.config;import org.springframework.beans.BeansException;import org.springframework.lang.Nullable;public interface BeanPostProcessor { @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; }} InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 调用点 Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：InstantiationAwareBeanPostProcessor接口中的postProcessBeforeInstantiation，在实例化之前调用。BeanPostProcessor接口中的postProcessAfterInitialization，在实例化之后调用。 12345678910111213141516171819202122232425262728293031/* org.spring framework.beans . factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation 作用：在实例化之前解析是否有快捷创建的Bean，既是通过postProcessBeforeInstantiation返回的Bean 内部调用两个重要的方法: 1. applyBeanPostProcessorsBeforeInstantiation: 内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用J 2. applyBeanPostProcessorsAfterInitialization: 如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】*/@Nullableprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { Class&lt;?&gt; targetType = determineTargetType(beanName, mbd); if (targetType != null) { // 调用方法，内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】 bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); // 如果返回了快捷的Bean if (bean != null) { //如果postProcessBeforeInstantiation方法返回了快捷的Bean， // 内部遍历调用 postProcessBeforeInstantiation方法【在初始化之后调用】 bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean;} applyBeanPostProcessorsBeforeInstantiation 12345678910111213141516/* 将 InstantiationAwareBeanPostProcessors 应用于指定的 bean 定义（按类和名称）， 调用它们的 postProcessBeforeInstantiation 方法。任何返回的对象都将用作 bean， 而不是实际实例化目标 bean。来自后处理器的空返回值将导致目标 bean 被实例化。*/@Nullableprotected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) { // getBeanPostProcessorCache返回预过滤后处理器的内部缓存，如有必要，重新（重新）构建它。 for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { Object result = bp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } return null;} applyBeanPostProcessorsAfterInitialization 1234567891011121314151617/* 作用:遍历调用postProcessAfterInitialization*/@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) { Object current = processor.postProcessAfterInitialization(result, beanName); if (current == null) { return result; } result = current; } return result;} InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation 调用点 boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException正常情况下在实例化之后在执行populateBean之前调用返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的postProcessPropertyValues将不会执行,但是初始化和BeanPostProcessor的仍然会执行。 1234567891011121314151617181920212223242526protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { // 执行postProcessAfterInstantiation方法 if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { // 返回结果为false，那么赋值continuewithPropertyPopulation=false，表示不继续执行属性填充 return; } } } ....} 3.2.2 BeanPostProcessor 源码分析​ initializeBean是该接口源码的入口 ​ 进入初始化接口： 1234567891011121314151617181920212223242526272829303132protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // 初始化前执行的方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } if (mbd == null || !mbd.isSynthetic()) { // 初始化后执行的方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization 12345678910111213141516@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; // 1. 获取到所有的后置处理器 getBeanPostProcessors() for (BeanPostProcessor processor : getBeanPostProcessors()) { // 2. 调用后置处理器的方法 Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) { return result; } result = current; } return result;} ​ 进入postProcessBeforeInitialization方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization@Override@Nullablepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware || bean instanceof ApplicationStartupAware)) { return bean; } AccessControlContext acc = null; if (System.getSecurityManager() != null) { acc = this.applicationContext.getBeanFactory().getAccessControlContext(); } if (acc != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareInterfaces(bean); return null; }, acc); } else { invokeAwareInterfaces(bean); } return bean;}private void invokeAwareInterfaces(Object bean) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware) bean).setMessageSource(this.applicationContext); } if (bean instanceof ApplicationStartupAware) { ((ApplicationStartupAware) bean).setApplicationStartup(this.applicationContext.getApplicationStartup()); } if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); }} ​ ApplicationContextAwareProcessor#postProcessBeforeInitialization 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 invokeAwareInterfaces(bean)，向容器中添加相关接口的上下文环境。 3.3 InitializingBean 和 init-methodInitializingBean 和 init-method 是 Spring 为 bean 初始化提供的扩展点。 InitializingBean接口 的定义如下： 123public interface InitializingBean { void afterPropertiesSet() throws Exception;} 在 afterPropertiesSet() 方法写初始化逻辑。 指定 init-method 方法，指定初始化方法： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;demo&quot; class=&quot;com.w1nd.Demo&quot; init-method=&quot;init()&quot;/&gt; &lt;/beans&gt; DisposableBean 和 destory-method 与上述类似，就不描述了。 4. 总结​ 最后总结下如何记忆 Spring Bean 的生命周期： 首先是实例化、属性赋值、初始化、销毁这 4 个大阶段； 再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作； 销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。 参考如何记忆 Spring Bean 的生命周期 - 掘金 (juejin.cn) 一文读懂 Spring Bean 的生命周期 - SegmentFault 思否 (104条消息) JVM类 和 spring Bean 的实例化 和 初始化区别以及顺序_秋楓的博客-CSDN博客_spring实例化和初始化的区别 java类的初始化和实例化区别 - pu20065226 - 博客园 (cnblogs.com) 聊聊spring的那些扩展机制 - 掘金 (juejin.cn)","link":"/2022/02/10/%E6%A1%86%E6%9E%B6/Spring/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"序列DP","text":"334. 递增的三元子序列 12345678910111213141516class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int small = INT_MAX, big = INT_MAX; for (int x: nums) { if (x &lt;= small) { small = x; } else if (x &lt;= big) { big = x; } else { return true; } } return false; }}; 1234567891011121314151617181920class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1, INT_MAX); // f[len] = x 表示 以 长度为 len 的序列的最小尾元素为x int ans = 1; for (int i = 0; i &lt; n; i ++) { int l = 1, r = i + 1; int x = nums[i]; while (l &lt; r) { // 二分查找小于nums[i]的最小元素 int mid = l + r &gt;&gt; 1; if (f[mid] &gt;= x) r = mid; else l = mid + 1; } f[r] = x; ans = max(ans, r); } return ans &gt;= 3; }}; 354. 俄罗斯套娃信封问题 123456789101112131415161718class Solution {public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) { int n = envelopes.size(); vector&lt;int&gt; f(n, 0); // 以 i 结尾的最大信封 sort(envelopes.begin(), envelopes.end()); int res = 0; for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) { if (envelopes[i][0] &gt; envelopes[j][0] &amp;&amp; envelopes[i][1] &gt; envelopes[j][1]) f[i] = max(f[i], f[j] + 1); } res = max(res, f[i]); } return res; }}; 368. 最大整除子集 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, 0); // f[i] 表示 前i个数中以a[i]结尾的整除子集的最长序列的元素个数 sort(nums.begin(), nums.end()); int k = 0; // 整除序列最后一个元素下标 for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) if (nums[i] % nums[j] == 0) f[i] = max(f[i], f[j] + 1); if (f[k] &lt; f[i]) k = i; } vector&lt;int&gt; res; // 逆推得出答案 while (true) { res.push_back(nums[k]); if (f[k] == 1) break; // 只剩一个元素 for (int i = 0; i &lt; k; i ++) { if ((nums[k] % nums[i] == 0) &amp;&amp; f[k] == f[i] + 1) { k = i; break; } } } return res; }}; 390. 消除游戏 1234567class Solution {public: int lastRemaining(int n) { if (n == 1) return 1; return 2 * (n / 2 + 1 - lastRemaining(n / 2)); }}; 446. 等差数列划分 II - 子序列 LeetCode 446. 等差数列划分 II - 子序列 - AcWing 12345678910111213141516171819202122class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; a) { typedef long long LL; int n = a.size(); // 由于每个数可能都会在不同等差数列中，需要用哈希表来存 vector&lt;unordered_map&lt;LL, int&gt;&gt; f(n); // f[i][j] 表示 考虑以第 i 个数结尾 公差为j的等差数列的个数 int res = 0; for (int i = 0; i &lt; n; i ++) for (int k = 0; k &lt; i; k ++) { LL j = (LL)a[i] - a[k]; auto it = f[k].find(j); // 查找a[k]结尾公差为j的等差数列的个数 int t = 0; if (it != f[k].end()) { t = it-&gt;second; res += t; } f[i][j] += t + 1; } return res; }}; 472. 连接词 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: typedef unsigned long long ULL; unordered_set&lt;ULL&gt; hash; const int P = 131; vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) { // 初始化字符串哈希表 for (auto &amp;s: words) { ULL t = 0; for (auto &amp;c: s) { t = t * P + c; } hash.insert(t); } vector&lt;string&gt; res; for (auto &amp;s: words) if (check(s)) res.push_back(s); return res; } bool check(string str) { int n = str.size(); vector&lt;int&gt; f(n + 1, -1); // f[i] 表示 在i前面的连接词的个数 f[0] = 0; for (int i = 0; i &lt;= n; i ++) { if (f[i]== -1) continue; ULL cur = 0; for (int j = i + 1; j &lt;= n; j ++) { cur = cur * P + str[j - 1]; if (hash.count(cur)) { f[j] = max(f[j], f[i] + 1); } } if (f[n] &gt;= 2) return true; } return false; }}; 583. 两个字符串的删除操作 123456789101112131415161718class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 0; i &lt;= n; i ++) f[i][0] = 1; for (int j = 0; j &lt;= m; j ++) f[0][j] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i][j - 1], f[i - 1][j]); if (word1[i - 1] == word2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } int maxn = f[n][m] - 1; return n + m - 2 * maxn; }}; 629. K个逆序对数组 LeetCode 629. K个逆序对数组 - AcWing 123456789101112131415161718class Solution {public: const int MOD = 1e9 + 7; int kInversePairs(int n, int k) { // f[i][j] 表示 所有由数字 1 ~ i 组成的含有 j 个 逆序对的数组个数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1, 0)); f[1][0] = 1; for (int i = 2; i &lt;= n; i ++) { long long s = 0; for (int j = 0; j &lt;= k; j ++) { s += f[i - 1][j]; if (j &gt;= i) s -= f[i - 1][j - i]; f[i][j] = s % MOD; } } return (f[n][k] + MOD) % MOD; } }; 673. 最长递增子序列的个数 123456789101112131415161718192021class Solution {public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n), g(n); // f 表示 以i结尾的最长上升子序列长度，g 表示 以 i 结尾的最长上升子序列的个数 int maxl = 0, cnt = 0; // maxl是最长子序列长度，cnt是子序列个数 for (int i = 0; i &lt; n; i ++) { f[i] = g[i] = 1; for (int j = 0; j &lt; i; j ++) { if (nums[j] &lt; nums[i]) { if (f[i] &lt; f[j] + 1) f[i] = f[j] + 1, g[i] = g[j]; else if (f[i] == f[j] + 1) g[i] += g[j]; } } if (maxl &lt; f[i]) maxl = f[i], cnt = g[i]; else if (maxl == f[i]) cnt += g[i]; } return cnt; }}; 689. 三个无重叠子数组的最大和 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; s(n, 0); int sum = 0; for (int i = 0; i &lt; n; i ++) { sum += nums[i]; if (i &gt;= k) sum -= nums[i - k]; if (i &gt;= k - 1) s[i - k + 1] = sum; } vector&lt;int&gt; left(n, 0), right(n, 0); int maxIndex = 0; for (int i = 0; i &lt; n; i ++) { if (s[maxIndex] &lt; s[i]) maxIndex = i; left[i] = maxIndex; } maxIndex = n - 1; for (int i = n - 1; i &gt;= 0; i --) { if (s[maxIndex] &lt;= s[i]) maxIndex = i; right[i] = maxIndex; } vector&lt;int&gt; res(3, -1); for (int i = k; i &lt; n - k; i ++) { if (res[0] == -1 || s[res[0]] + s[res[1]] + s[res[2]] &lt; s[i] + s[left[i - k]] + s[right[i + k]]) { res[0] = left[i - k]; res[1] = i; res[2] = right[i + k]; } } return res; }}; 740. 删除并获得点数 1234567891011121314151617181920class Solution {public: const int N = 1e4 + 10; int deleteAndEarn(vector&lt;int&gt;&amp; nums) { // f[i][j] 表示是否删除 j 数 的 最大点数 int n = nums.size(); int maxn = 0; vector&lt;int&gt; cnt(N); for(auto x: nums) { cnt[x] ++; maxn = max(maxn, x); } vector&lt;vector&lt;int&gt;&gt; f(maxn + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= maxn; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = max(f[i][1], f[i - 1][0] + cnt[i] * i); } return max(f[maxn][0], f[maxn][1]); }}; 978. 最长湍流子数组 12345678910111213141516171819// 优化了空间class Solution {public: int maxTurbulenceSize(vector&lt;int&gt;&amp; arr) { int n = arr.size(); // f[i][0/1]表示 以i结尾的数组 元素状态为j的最大湍流子数组长度 vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(2, 0)); int ans = 1; f[0][0] = f[0][1] = 1; for (int i = 1; i &lt; n; i ++) { for (int j = 0; j &lt; 2; j ++) f[i % 2][j] = 1; if (arr[i - 1] &lt; arr[i]) f[i % 2][0] = f[(i - 1) % 2][1] + 1; if (arr[i - 1] &gt; arr[i]) f[i % 2][1] = f[(i - 1) % 2][0] + 1; for (int j = 0; j &lt; 2; j ++) ans = max(ans, f[i % 2][j]); } return ans; }}; 1035. 不相交的线 123456789101112131415161718class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int n = nums1.size(), m = nums2.size(); // f[i][j] 表示 考虑 前 i 个 数字，前 j 个数字组成最大公共子序列长度 // 最长公共子序列 是考虑的情况是不一定包含第i个字符的 // 例如，我们通常考虑f[i - 1][j]为前i - 1，j个数字的最长子序列，但这里不一定包含第j个，只是可能，所以 f[i - 1][j] 包含 f[i - 1][j - 1]; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (nums1[i - 1] == nums2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1143. 最长公共子序列 12345678910111213141516class Solution {public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (text1[i - 1] == text2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1218. 最长定差子序列 1234567891011121314151617181920212223class Solution {public: // 注意覆盖问题：hash.insert遇到一样的键不会覆盖 // 由于 arr长度 为 1e5，不能用两层循环，使用哈希表进行优化 int longestSubsequence(vector&lt;int&gt;&amp; arr, int diff) { int n = arr.size(); // f[i][j] 表示 前i个数，第i个数选或不选的最长定差子序列长度 vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][1] = 1; unordered_map&lt;int, int&gt; hash; hash[arr[0]] = 0; for (int i = 1; i &lt; n; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = 1; int prev = arr[i] - diff; if (hash.count(prev)) { f[i][1] = max(f[i][1], f[hash[prev]][1] + 1); } hash[arr[i]] = i; } return max(f[n - 1][0], f[n - 1][1]); }}; 1473. 粉刷房子 III 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: const int INF = 0x3f3f3f3f; int minCost(vector&lt;int&gt;&amp; houses, vector&lt;vector&lt;int&gt;&gt;&amp; cost, int n, int m, int t) { // f[i][j][k] 表示 考慮前i个房子，第i个房子粉刷为j，分区数量为k的所有方案中的最小总花费 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(t + 1, 0))); for (int i = 0; i &lt;= n; i ++) for (int j = 0; j &lt;= m; j ++) f[i][j][0] = INF; for (int i = 1; i &lt;= n; i ++) { int color = houses[i - 1]; // 当前房子的颜色 for (int j = 1; j &lt;= m; j ++) { for (int k = 1; k &lt;= t; k ++) { if (k &gt; i) { // 如果分区数量大于房子数，不合法 f[i][j][k] = INF; continue; } if (color != 0) { // 当前房子已经染色 if (color == j) { // 只有与当前颜色相同才能被转移 int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp); // 与前面颜色相同的情况 } else { f[i][j][k] = INF; } } else { // 当前房子未被染色 int u = cost[i - 1][j - 1]; int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp) + u; // 与前面颜色相同的情况 } } } } int ans = INF; for (int i = 1; i &lt;= m; i ++) ans = min(ans, f[n][i][t]); return ans == INF ? -1: ans; }}; 1713. 得到子序列的最少操作次数 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: /* target 6 4 8 1 3 2 arr 4 7 6 2 3 8 6 1 list 1 0 5 4 2 0 3 */ int minOperations(vector&lt;int&gt;&amp; t, vector&lt;int&gt;&amp; a) { int n = t.size(), m = a.size(); unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; n; i ++) hash.insert({t[i], i}); // 建立 target 和 arr 的映射关系 vector&lt;int&gt; list; for (auto x: a) { // 由于target各元素不相同，list中保存了arr与target相同元素的下标，并且递增，故可转化为LIS问题 if (hash.count(x)) list.push_back(hash[x]); } int cnt = list.size(); // q[i] 表示 长度为i的上升子序列 中末尾元素最小的数 vector&lt;int&gt; q(cnt + 1, 0); // 使用LIS的贪心+二分的方法求解，复杂度为nlog(n) // 个人感觉这种优化方式主要是维护一个单调队列，每次加入新的元素，要和之前加入的对比， // 找到比自己小的最后一个数，那么它就可以代替这之前的那个数，因为它更小，更好维护递增序列， // 例如 1 3 5 ，加入1个4（规定长度3），那肯定4替换掉5更好 int len = 0; for (int i = 0; i &lt; cnt; i ++) { int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; list[i]) l = mid; else r = mid - 1; } q[r + 1] = list[i]; if (r + 1 &gt; len) len ++; } return n - len; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%BA%8F%E5%88%97DP/"},{"title":"线性DP","text":"10. 正则表达式匹配12345678910111213141516171819202122232425class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(), m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; // dp状态表示：dp[i][j] s以i结尾的子串与p以j结尾的子串是否匹配 vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; // 下一个是*，当前 字符不能单独使用，跳过 if (i - 1 &gt;= 0 &amp;&amp; p[j] != '*') { dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); // 对应了p[j]为普通字符和'.'两种情况 } else if (p[j] == '*') { // 字符为'*' dp[i][j] = (j - 2 &gt;= 0 &amp;&amp; dp[i][j - 2]) || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')); } } return dp[n][m]; }}; 44. 通配符匹配1234567891011121314151617181920class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(); int m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (p[j] != '*') { dp[i][j] = i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (p[j] == s[i] || p[j] == '?'); } else { dp[i][j] = dp[i][j - 1] || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j]); } } return dp[n][m]; }}; 45. 跳跃游戏 II123456789101112class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n); for (int i = 1, j = 0; i &lt; n; i ++) { while (j + nums[j] &lt; i) j ++; dp[i] = dp[j] + 1; } return dp[n - 1]; }}; 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string ss) { int n = ss.size(); string s = &quot; &quot; + ss; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; i ++) { int a = s[i] - '0', b = (s[i - 1] - '0') * 10 + (s[i] - '0'); if (a &gt;= 1 &amp;&amp; a &lt;= 9) dp[i] = dp[i - 1]; if (b &gt;= 10 &amp;&amp; b &lt;= 26) dp[i] += dp[i - 2]; } return dp[n]; }}; 115. 不同的子序列1234567891011121314151617181920class Solution {public: int numDistinct(string ss, string tt) { int n = ss.size(), m = tt.size(); string s = &quot; &quot; + ss; string t = &quot; &quot; + tt; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); // f[i][j] 表示 0~i，0~j的字符串匹配个数 for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { // 不匹配s[i] dp[i][j] = dp[i - 1][j]; if (s[i] == t[j]) { // 匹配s[i] dp[i][j] = (0LL + dp[i][j] + dp[i - 1][j - 1]) % INT_MAX; } } return dp[n][m]; }}; 119. 杨辉三角 II123456789101112131415class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; dp(rowIndex + 1); dp[0] = 1; for (int i = 1; i &lt;= rowIndex; i ++) for (int j = i; j &gt;= 0; j --) { if (j - 1 &gt;= 0) dp[j] += dp[j - 1]; if (dp[j] == 0) dp[j] = 1; } vector&lt;int&gt; res; for (int i = 0; i &lt; rowIndex + 1; i ++) res.push_back(dp[i]); return res; }}; 213. 打家劫舍 II1234567891011121314151617181920212223class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 1) return nums[0]; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0)); // 不选第1间, 0不选，1选 for (int i = 1; i &lt; n; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res1 = max(dp[n - 1][0], dp[n - 1][1]); dp[0][1] = nums[0], dp[0][0] = 0; for (int i = 1; i &lt; n - 1; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res2 = max(dp[n - 2][0], dp[n - 2][1]); return max(res1, res2); }}; 403. 青蛙过河1234567891011121314151617181920class Solution {public: bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); if (stones[1] != 1) return false; // dp[i][j]表示跳到位置i步长为j是否可以 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); dp[1][1] = true; for (int i = 2; i &lt; n; i ++) for (int j = 1; j &lt; i; j ++) { int k = stones[i] - stones[j]; // 步长 if(k &lt;= j + 1) { dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; } } for (int i = 1; i &lt; n; i ++) if (dp[n - 1][i]) return true; return false; }}; 576. 出界的路径数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: const int MOD = (int) 1e9 + 7; int n, m, maxn; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int findPaths(int _m, int _n, int _maxMove, int r, int c) { n = _m, m = _n, maxn = _maxMove; vector&lt;vector&lt;int&gt;&gt; dp(n * m, vector&lt;int&gt;(maxn + 1, 0)); // 初始化边缘 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j ++) { if (i == 0) add(i, j, dp); if (j == 0) add(i, j, dp); if (i == n - 1) add(i, j, dp); if (j == m - 1) add(i, j, dp); } // f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1] for (int k = 1; k &lt;= maxn; k ++) { for (int idx = 0; idx &lt; m * n; idx ++) { vector&lt;int&gt; info(2, 0); info = parseIdx(idx); int x = info[0], y = info[1]; for (int i = 0; i &lt; 4; i ++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; int nidx = getIdx(nx, ny); dp[idx][k] += dp[nidx][k - 1]; dp[idx][k] %= MOD; } } } return dp[getIdx(r, c)][maxn]; } void add(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;dp) { for (int k = 1; k &lt;= maxn; k ++) { dp[getIdx(x, y)][k] ++; } } int getIdx(int x, int y) { return x * m + y; } vector&lt;int&gt; parseIdx(int idx) { return vector&lt;int&gt;{idx / m, idx % m}; }}; 639. 解码方法 II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution {public: const int MOD = (int) 1e9 + 7; // i 表示当前遍历字符下标，j表示前一个字符下标 // f[i] 表示 以 s[i] 结尾的字符串，共有多少种解码方法 /* s[i] == '*'： s[i]可以单独组成一个，f[i] += f[i - 1] * 9 可以和前面的字符组成： 若s[j] == 1，那么 f[i] += f[i - 2] * 9 (11 - 19) 若s[j] == 2，那么 f[i] += f[i - 2] * 6 (21 - 26) 若s[j] == *，那么 f[i] += f[i - 2] * 15 s[i] != '*'，s[i]为数字时： s[j] 为 '*'： s[i] == 0，f[i] += f[i - 2] * 2; （10，20） s[i] != 0： f[i] = f[i - 1] (1 - 9) 1 &lt;= s[i] &lt;= 6 f[i] += f[i - 2] * 2 （11 - 16，21 - 26） 7 &lt;= s[i] &lt;= 9 f[i] += f[i - 2] * 1 （17 - 19） s[j] != '*'： s[i] == 0，f[i] = f[i - 2] (10, 20) s[i] != 0： f[i] = f[i - 1] (1 - 9) s[j] == 1，f[i] = f[i - 2]; (11 - 19) s[j] == 2 且 1 &lt;= s[i] &lt;= 6 ，f[i] = f[i - 2]; (21 - 26) */ int numDecodings(string s) { int n = s.size(); vector&lt;long&gt; f(n, 0); // 注意这里要long f[0] = s[0] == '*' ? 9 : (s[0] != '0' ? 1 : 0); for (int i = 1; i &lt; n; i ++) { char c = s[i], prev = s[i - 1]; if (c == '*') { f[i] += f[i - 1] * 9; if (prev == '*') f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 15; else { int u = prev - '0'; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 9; else if (u == 2) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 6; } } else { int t = c - '0'; if (prev == '*') { if (t == 0) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; else { f[i] += f[i - 1]; if (t &gt;= 1 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; if (t &gt;= 7 &amp;&amp; t &lt;= 9) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { int u = prev - '0'; if (t == 0) { if (u == 1 || u == 2) { f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { f[i] = f[i - 1]; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); if (u == 2 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } } f[i] %= MOD; } return (int) f[n - 1]; }}; 650. 只有两个键的键盘1234567891011121314151617181920// f[i][j]表示经过最后一次操作，记事本上有i个字符，粘贴板上有j个字符的最小操作次数class Solution {public: const int MAX_INT = 0x3f3f3f3f; int minSteps(int n) { vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, MAX_INT)); dp[1][0] = 0, dp[1][1] = 1; for (int i = 2; i &lt;= n; i ++) { int minN = MAX_INT; for (int j = 0; j &lt;= i / 2; j ++) { dp[i][j] = dp[i - j][j] + 1; // paste minN = min(minN, dp[i][j]); } dp[i][i] = minN + 1; // copy all } int res = MAX_INT; for (int i = 0; i &lt;= n; i ++) res = min(res, dp[n][i]); return res; }}; 678. 有效的括号字符串1234567891011121314151617181920212223class Solution {public: bool checkValidString(string s) { int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(n + 1, 0)); dp[0][0] = true; for (int i = 1; i &lt;= n; i ++) { char c = s[i - 1]; for (int j = 0; j &lt;= i; j ++) { if (c == '(') { if (j - 1 &gt;= 0) dp[i][j] = dp[i - 1][j - 1]; } else if (c == ')') { if (j + 1 &lt;= i) dp[i][j] = dp[i - 1][j + 1]; } else { dp[i][j] = dp[i - 1][j]; if (j - 1 &gt;= 0) dp[i][j] = dp[i][j] | dp[i - 1][j - 1]; if (j + 1 &lt;= i) dp[i][j] = dp[i][j] | dp[i - 1][j + 1]; } } } return dp[n][0]; }}; 1220. 统计元音字母序列的数目12345678910111213141516171819202122232425262728293031class Solution {public: const int MOD = 1e9 + 7; // dp[i][j] 表示 长度为i的字符串，结尾为j的字符串 的 个数 int countVowelPermutation(int n) { vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt;(5, 0)); for (int i = 0; i &lt; 5; i ++) dp[0][i] = 1; for (int i = 1; i &lt; n; i ++) { // 每个元音 'a' 后面都只能跟着 'e' dp[i][1] += dp[i - 1][0]; // 每个元音 'e' 后面只能跟着 'a' 或者是 'i' dp[i][0] += dp[i - 1][1]; dp[i][2] += dp[i - 1][1]; // 每个元音 'i' 后面 不能 再跟着另一个 'i' dp[i][0] += dp[i - 1][2]; dp[i][1] += dp[i - 1][2]; dp[i][3] += dp[i - 1][2]; dp[i][4] += dp[i - 1][2]; // 每个元音 'o' 后面只能跟着 'i' 或者是 'u' dp[i][2] += dp[i - 1][3]; dp[i][4] += dp[i - 1][3]; // 每个元音 'u' 后面只能跟着 'a' dp[i][0] += dp[i - 1][4]; for (int j = 0; j &lt; 5; j ++) dp[i][j] %= MOD; } long res = 0; for (int i = 0; i &lt; 5; i ++) res += dp[n - 1][i]; return (int) (res % MOD); }}; 1751. 最多可以参加的会议数目 II1234567891011121314151617181920212223242526272829303132333435class Solution {public: static bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) { // 升序排序 return a[1] &lt;= b[1]; } int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; events, int k) { int n = events.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k + 1, 0)); sort(events.begin(), events.end(), cmp); for (int i = 0; i &lt; n; i ++) printf(&quot;[%d %d %d]&quot;, events[i][0], events[i][1], events[i][2]); for (int i = 1; i &lt;= n; i ++) { auto p = events[i - 1]; int s = p[0], e = p[1], v = p[2]; int last = 0; for (int t = i - 1; t &gt;= 1; t --) { auto l = events[t - 1]; if (s &gt; l[1]) { last = t; // 更新为不冲突的事件下标 break; } } for (int j = 1; j &lt;= k; j ++) { dp[i][j] = max(dp[i - 1][j], dp[last][j - 1] + v); // 选与不选 } } return dp[n][k]; }}; 1787. 使所有区间的异或结果为零12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: /* 易知，将nums排列为一个二维数组（每行为k个），问题将转化为： 使得每列相等，且最终首行异或值为0的更改元素数 定义 f[i][xor]为考虑前i列，且首行前i列异或值的xor的更改元素数 由于需要知道i - 1列的最小更改元素数，使之转态转移，所以需要一个状态数组prev 另外，使用 map记录每一列数字对应的个数 cnt记录每一列数字总数 所以，分析状态转移方程 当在第0列时： f[0][xor] = f[0][xor] + cnt - map[xor] 当在其他列时，需要考虑从前一列转移的状态： 另外，还有 考虑整列修改： f[i][xor] = f[i - 1][xor] + cnt; 考虑部分修改： f[i][xor] = f[i - 1][xor ^ cur] + cnt - map[cur]; */ const int maxVal = INT_MAX / 2; const int maxHalf = 1 &lt;&lt; 10; int minChanges(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(maxHalf, maxVal)); vector&lt;int&gt; prev(k, maxVal); for (int i = 0; i &lt; k; i ++) { // 遍历每一列 int cnt = 0; unordered_map&lt;int, int&gt; map; for (int j = i; j &lt; n; j += k) { map[nums[j]] ++; cnt ++; } if (i == 0) { // 第0列 for (int x = 0; x &lt; maxHalf; x ++) { dp[0][x] = min(dp[0][x], cnt - map[x]); prev[0] = min(prev[0], dp[0][x]); } } else { // 其他列 for (int x = 0; x &lt; maxHalf; x ++) { dp[i][x] = prev[i - 1] + cnt; for (auto &amp;it: map) { dp[i][x] = min(dp[i][x], dp[i - 1][x ^ it.first] + cnt - it.second); } prev[i] = min(prev[i], dp[i][x]); } } } return dp[k - 1][0]; }}; 剑指 Offer 42. 连续子数组的最大和1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; int ans = dp[0]; for (int i = 1; i &lt; n; i ++) { dp[i] = max(nums[i], dp[i - 1] + nums[i]); ans = max(ans, dp[i]); } return ans; }}; LCP 07. 传递信息12345678910111213class Solution {public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) { vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(15, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= k; i ++) for(auto &amp;r: relation) { int a = r[0], b = r[1]; dp[i][b] += dp[i - 1][a]; } return dp[k][n - 1]; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%90%86%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7DP/"},{"title":"红黑树","text":"1 概念1. 1 定义（1）结点是红色或黑色 （2）根节点是黑色 （3）所有叶子都是黑色（叶子是NULL结点） （4）每个红色节点的两个子节点一定都是黑色。不能有两个红色节点相连。 （5）任意一节点到每个叶子节点的路径都包含数量相同的黑结点。俗称：黑高！ 红黑树实例图 ​ 红黑树并不是一个完美平衡二叉查找树，从图上可以看到，根结点P的左子树显然比右子树高， ​ 但左子树和右子树的黑结点的层数是相等的，也就是说，任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。 ​ 所以我们叫红黑树这种平衡为黑色完美平衡。 ​ 红黑树的性质讲完了，只要这棵树满足以上性质，这棵树就是趋近与平衡状态的。 1.2 性质​ 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长 1.3 关于红黑树操作​ 在了解这些操作前，先明确三个小操作 变色：结点的颜色由红变黑或由黑变红。 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变 左旋图示 右旋图示 另外，约定一些节点的称呼 1.3.1 插入插入操作包括两部分工作： 查找插入的位置 插入后自平衡 ​ 注意：插入节点，必须为红色，理由很简单，红色在父节点（如果存在）为黑色节点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。 ​ 但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。 红黑树插入节点情景分析情景1：红黑树为空树​ 最简单的一种情景，直接把插入结点作为根结点就行 ​ 注意：根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。 情景2：插入结点的Key已存在​ 处理：更新当前节点的值，为插入节点的值 情景3：插入结点的父结点为黑结点​ 由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。 ​ 情景4：插入节点的父节点为红色​ 再次回想下红黑树的性质2：根结点是黑色。如果插入节点的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。 ​ 这一点很关键，因为后续的旋转操作肯定需要祖父结点的参与。 ​ 插入情景4.1：叔叔结点存在并且为红结点 依据红黑树性质4可知，红色节点不能相连 ==&gt; 祖父结点肯定为黑结点； 因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红 处理： 将P和U节点改为黑色 将PP改为红色 将PP设置为当前节点，进行后续处理 ​ 可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理； 但如果PP的父结点是红色，则违反红黑树性质了。所以需要将PP设置为当前节点，继续做插入操作自平衡处理，直到平衡为止。 插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点 注意：单纯从插入前来看，叔叔节点非红即空（NIL节点），否则的话破坏了红黑树性质5，此路径会比其它路径多一个黑色节点。 ​ 插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况） ​ 处理： 变颜色：将P设置为黑色，将PP设置为红色 对PP节点进行右旋 插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况） 处理： 对P进行左旋 将P设置为当前节点，得到LL红色情况 按照LL红色情况处理（1.变颜色 2.右旋PP） 插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点 该情景对应情景4.2，只是方向反转，直接看图。 插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况） 处理： 变颜色：将P设置为黑色，将PP设置为红色 对PP节点进行左旋 插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况） 处理： 对P进行右旋 将P设置为当前节点，得到RR红色情况 按照RR红色情况处理（1.变颜色 2.左旋PP） 1.3.2 删除​ 删除操作整体要比插入难一些。插入操作主要容易违背红黑树的定义4（红黑树中不存在两个相邻的红色结点）。而删除操作主要容易违背定义5（删除黑色结点可能导致根结点到叶结点黑色结点的数目减少，即黑高降低）。 ​ 在介绍具体的操作之前，先了解些概念 当删除结点 v 是黑色结点，且其被其黑色子节点替换时，其子结点就被标记为 双黑 ​ 删除操作最主要的任务就可以转化为将双黑结点转化为我们普通黑色结点。 红黑树的删除分析​ 首先我们假定要删除的结点为 v ，u 是用来替换 v 的孩子结点（注意，当 v 是叶结点时， u 是 NULL结点，且NULL结点我们还是当做黑色结点处理）。 ​ 删除操作总纲： 执行标准的 BST 的删除操作 简单情况：u 或者 v 是红色 复杂情况：u 和 v 都是黑色结点。 ​ ​ 简单情况：u或v是红色节点​ 如果 u 或者 v 是红色，我们将替换结点 v 的结点 u 标记为黑色结点（这样黑高就不会变化）。注意这里是 u 或者 v 是红色结点，因为在一棵红黑树中，是不允许有两个相邻的红色结点的，而结点 v 是结点 u 的父结点，因此只能是 u 或者 v 是红色结点。 ​ 删除结点 v 为黑色结点 10 ，替换结点 v 的结点 u 为红色结点 9 的情况： ​ ​ 删除结点 v 为红色结点 20 ，替换结点 v 的结点 u 为黑色NULL结点 h 的情况： 复杂情况：u和v都是黑色节点​ 下面不想写了= =，具体参考这篇博文把，感觉写的不错 图解：红黑树删除篇（一文读懂） - 知乎 (zhihu.com) 2 代码实现2.1 RBTree.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372package DataStructure.rbtree;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * &lt;p&gt; * ②创建RBNode * &lt;p&gt; * ③辅助方法定义：parentOf(node)，isRed(node)，setRed(node)，setBlack(node)，inOrderPrint() * &lt;p&gt; * ④左旋方法定义：leftRotate(node) * &lt;p&gt; * ⑤右旋方法定义：rightRotate(node) * &lt;p&gt; * ⑥公开插入接口方法定义：insert(K key, V value); * &lt;p&gt; * ⑦内部插入接口方法定义：insert(RBNode node); * &lt;p&gt; * ⑧修正插入导致红黑树失衡的方法定义：insertFIxUp(RBNode node); * &lt;p&gt; * ⑨测试红黑树正确性 */public class RBTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private static final boolean RED = true; // 红 private static final boolean BLACK = false; // 黑 @Data @AllArgsConstructor @NoArgsConstructor static class RBNode&lt;K extends Comparable&lt;K&gt;, V&gt; { private RBNode parent; //父结点 private RBNode left; // 左子树 private RBNode right; // 右子树 private boolean color; // 颜色 private K key; //键 private V value; // 值 } /** * 树根的引用 */ private RBNode root; public RBNode getRoot() { return this.root; } private RBNode parentOf(RBNode node) { if (node != null) { return node.parent; } return null; } /** * 当前结点是否为红色 * @param node * @return */ private boolean isRed(RBNode node) { return node != null &amp;&amp; node.color == RED; } /** * 当前结点是否为黑色 * @param node * @return */ private boolean isBlack(RBNode node) { return node != null &amp;&amp; node.color == BLACK; } /** * 设置节点为红色 * * @param node */ private void setRed(RBNode node) { if (node != null) { node.color = RED; } } /** * 设置节点为黑色 * * @param node */ private void setBlack(RBNode node) { if (node != null) { node.color = BLACK; } } /** * 中序打印二叉树 */ public void inOrderPrint() { inOrderPrint(root); } private void inOrderPrint(RBNode node) { if (node != null) { inOrderPrint(node.left); System.out.println(&quot;key:&quot; + node.key + &quot;.value:&quot; + node.value); inOrderPrint(node.right); } } /** * 左旋方法 * 左旋示意图：左旋x节点 * p p * | | * x y * / \\ ----&gt; / \\ * lx y x ry * / \\ / \\ * ly ry lx ly * * 左旋做了几件事？ * 1.将x的右子节点指向y的左子节点(ly)，并且把y的左子节点更新为x * 2.当x的父节点(不为空时)，更新y的父节点为x的父节点，并将x的父节点 指定 子树(当前x的子树位置) 指定为y * 3.将x的父节点更新为y，将y的左子节点更新为x */ private void leftRotate(RBNode x) { RBNode y = x.right; x.right = y.left; // 1.将x的右子节点指向y的左子节点(ly)，并且把y的左子节点更新为x if (y.left != null) { y.left.parent = x; } // 2.当x的父节点(不为空时)，更新y的父节点为x的父节点，并将x的父节点 指定 子树(当前x的子树位置) 指定为y if (x.parent != null) { y.parent = x.parent; if (x == x.parent.left) { // 如果x是其父节点的左子节点，则将y放在x父节点的左边 x.parent.left = y; } else { x.parent.right = y; // 如果x是其父节点的右子节点，则将y放在x父节点的右边 } } else { // 说明x为根节点，此时需要更新y为根节点 的引用 this.root = y; this.root.parent = null; // 根节点无父节点 } // 3.将x的父节点更新为y，将y的左子节点更新为x x.parent = y; y.left = x; } /** * 右旋方法 * 右旋示意图：右旋y节点 * * p p * | | * y x * / \\ ----&gt; / \\ * x ry lx y * / \\ / \\ * lx ly ly ry * * 右旋都做了几件事？ * 1.将y的左子节点指向x的右子节点，并且更新x的右子节点的父节点为y * 2.当y的父节点不为空时，更新x的父节点为y的父节点，更新y的父节点的指定子节点（y当前位置） 为x * 3.更新y 的父节点为x ,更新x 的右子节点为y */ public void rightRotate(RBNode y) { RBNode x = y.left; y.left = x.right; // 1.将x的右子节点 赋值 给了 y 的左子节点，并且更新x的右子节点的父节点为 y if (x.right != null) { x.right.parent = y; } // 2.将y的父节点p（非空时）赋值给x的父节点，同时更新p的子节点为x（左或右） if (y.parent != null) { x.parent = y.parent; if (y == y.parent.left) { // 如果y是其父节点的左子节点，则将x放在y父节点的左边 y.parent.left = x; } else { // 如果y是其父节点的右子节点，则将x放在y父节点的右边 y.parent.right = x; } } else { // 说明y为根节点，此时需要更新x为根节点 的引用 this.root = x; x.parent = null; } // 3.将x的右子节点赋值为y，将y的父节点设置为x x.right = y; y.parent = x; } /** * public插入方法 * * @param key * @param value */ public void insert(K key, V value) { RBNode node = new RBNode&lt;&gt;(); node.setKey(key); node.setValue(value); // 新结点一定是红色 node.setColor(RED); insert(node); } /** * 插入节点 * @param node */ private void insert(RBNode node) { // 第一步：查找当前要插入节点node的父节点 RBNode parent = null; // 声明要插入节点node的父节点 RBNode x = this.root; while (x != null) { parent = x; /** * cmp &gt; 0 说明node.key 大于 x.key 需要到x 的右子树查找 * cmp == 0 说明node.key 等于 x.key 需要进行替换操作 * cmp &lt; 0 说明node.key 小于 x.key 需要到x 的左子树查找 */ int cmp = node.key.compareTo(x.key); if (cmp &gt; 0) { x = x.right; } else if (cmp == 0) { x.setValue(node.getValue()); return ; // 修改完后 就不再继续往下面的代码执行了 } else { x = x.left; } } /** * 退出上面的while循环后，到这里，说明树中没有相同key 的元素 * * 需要添加新元素node到 x(parent) 目前位置的左子树/右子树 */ node.parent = parent; if (parent != null) { // 判断node与parent的key谁大 int cmp = node.key.compareTo(parent.key); if (cmp &gt; 0) { // 当前node的key比parent 的key大，需要把node放入parent 的右子节点 parent.right = node; } else { // 当前node的key比parent 的key大，需要把node放入parent 的右子节点 parent.left = node; } } else { // parent == null; 说明为空树 this.root = node; // 直接给树根赋值为node } // 新元素node 加入树中之后，要调用修复红黑树平衡的方法 insertFixUp(node); } /** * 插入后修复红黑树平衡的方法 * |---情景1：如果红黑树为空树,需要将根节点染为黑色 * |---情景2：如果插入节点的key已经存在,(这种情况不需要处理,因为修改树中的值不会触发红黑树修复平衡方法) * |---情景3：如果插入节点的父节点为黑色,这种情况不需要处理,(参考红黑树的性质4和性指5去理解) * (因为所插入的路径中,黑色节点数没发生变化,所以红黑树依然平衡) * &lt;p&gt; * 情景4 需要去处理的情景 * |---情景4：插入节点的父节点为红色,(违反红黑树性质4,不能有两个红色节点相连) * |---情景4.1：叔叔节点存在，并且为红色（父-叔 双红） * 处理：将爸爸和叔叔染成黑色，将爷爷染成红色，并且再以爷爷节点为当前节点，进行下一轮处理 * |---情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树 * 处理： * |---情景4.2.1：插入节点为其父节点的左子节点（LL情况） * 处理：将父节点染为黑色，将爷爷染为红色，然后以爷爷节点右旋即可 * |---情景4.2.2：插入节点为其父节点的右子节点（LR情况） * 处理：将父节点进行一次左旋，得到LL双红情景(4.2.1),然后指定父节点为当前节点进行下一轮处理 * |---情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树 * |---情景4.3.1：插入节点为其父节点的右子节点（RR情况） * 处理：将父节点染为黑色，将爷爷节点染为红色，然后以爷爷节点左旋即可 * |---情景4.3.2：插入节点为其父节点的左子节点（RL情况） * 处理：以父节点进行一次右旋，得到RR双红情景(4.3.1),然后指定父节点为当前节点进行下一轮处理 */ private void insertFixUp(RBNode node) { RBNode parent = parentOf(node); // 当前节点的父节点 RBNode gparent = parentOf(parent); // 当前节点的爷爷节点 // 存在父节点且父节点为红色 if (parent != null &amp;&amp; isRed(parent)) { // 父节点是红色的，那么一定存在爷爷节点(性质2：根节点只能是黑色) // 父节点为爷爷节点的左子树 if (parent == gparent.left) { RBNode uncle = gparent.right; // 情景4.1：叔叔节点存在，并且为红色（父-叔 双红） // 将父和叔染色为黑色，再将爷爷染红，并将爷爷设置为当前节点，进入下一次循环判断 if (uncle != null &amp;&amp; isRed(uncle)) { setBlack(parent); setBlack(uncle); setRed(gparent); insertFixUp(gparent); return ; } // 情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树 if (uncle == null || isBlack(uncle)) { /** * 情景4.2.1：插入节点为其父节点的左子节点（LL情况） * 处理：将父节点染为黑色，将爷爷染为红色，然后以爷爷节点右旋即可 */ // 插入节点为其父节点的左子节点（LL情况）=&gt; // 变色（父节点变黑，爷爷节点变红），右旋爷爷节点 if (node == parent.left) { setBlack(parent); setRed(gparent); rightRotate(gparent); // 以gparent右旋 } /** * 情景4.2.2：插入节点为其父节点的右子节点（LR情况） * 处理：将父节点进行一次左旋，得到LL双红情景(4.2.1),然后指定父节点为当前节点进行下一轮处理 */ // 插入节点为其父节点的右子节点（LR情况）=&gt; // 左旋（父节点），当前节点设置为父节点，进入下一次循环 if (node == parent.right) { leftRotate(parent); // parent左旋 insertFixUp(parent); // 进行下一轮处理 return ; } } } else { // 父节点为爷爷节点的右子树 RBNode uncle = gparent.left; // 情景4.1：叔叔节点存在，并且为红色（父-叔 双红） // 将父和叔染色为黑色，再将爷爷染红，并将爷爷设置为当前节点，进入下一次循环判断 if (uncle != null &amp;&amp; isRed(uncle)) { setBlack(parent); setBlack(uncle); setRed(gparent); insertFixUp(gparent); return ; } // 情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树 if (uncle == null || isBlack(uncle)) { /** * 情景4.3.1：插入节点为其父节点的右子节点（RR情况） * 处理：将父节点染为黑色，将爷爷节点染为红色，然后以爷爷节点左旋即可 */ // 插入节点为其父节点的右子节点（RR情况）=&gt; // 变色（父节点变黑，爷爷节点变红），右旋爷爷节点 if (node == parent.right) { setBlack(parent); setRed(gparent); leftRotate(gparent); } /** * 情景4.3.2：插入节点为其父节点的左子节点（RL情况） * 处理：以父节点进行一次右旋，得到RR双红情景(4.3.1),然后指定父节点为当前节点进行下一轮处理 */ // 插入节点为其父节点的左子节点（RL情况） // 右旋（父节点）得到RR情况，当前节点设置为父节点，进入下一次循环 if (node == parent.left) { rightRotate(parent); insertFixUp(parent); return ; } } } } setBlack(this.root); }} 2.2 TreeOperation.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package DataStructure.rbtree;public class TreeOperation { /** 树的结构示例： 1 / \\ 2 3 / \\ / \\ 4 5 6 7 */ /** * 用于获得树的层数 * @param root * @return */ public static int getTreeDepth(RBTree.RBNode root) { return root == null ? 0 : (1 + Math.max(getTreeDepth(root.getLeft()), getTreeDepth(root.getRight()))); } /** * 将树的值写入数组 * @param currNode * @param rowIndex * @param columnIndex * @param res * @param treeDepth */ private static void writeArray(RBTree.RBNode currNode, int rowIndex, int columnIndex, String[][] res, int treeDepth) { // 保证输入的树不为空 if (currNode == null) return ; // 先将当前节点保存到二维数组中 res[rowIndex][columnIndex] = String.valueOf(currNode.getKey() + &quot;-&quot; + (currNode.isColor() ? &quot;R&quot; : &quot;B&quot;) + &quot;&quot;); // 计算当前位于树的第几层 int currLevel = ((rowIndex + 1) / 2); // 若到了最后一层，则返回 if (currLevel == treeDepth) return ; // 计算当前行到下一行，每个元素之间的间隔（下一行的列索引与当前元素的列缩影之间的间隔） int gap = treeDepth - currLevel - 1; // 对左儿子进行判断，若有左儿子，则记录相应的&quot;/&quot;与左儿子的值 if (currNode.getLeft() != null) { res[rowIndex + 1][columnIndex - gap] = &quot;/&quot;; writeArray(currNode.getLeft(), rowIndex + 2, columnIndex - gap * 2, res, treeDepth); } // 对右儿子进行判断，若有右儿子，则记录相应的&quot;\\&quot;与右儿子的值 if (currNode.getRight() != null) { res[rowIndex + 1][columnIndex + gap] = &quot;\\\\&quot;; writeArray(currNode.getRight(), rowIndex + 2, columnIndex + gap * 2, res, treeDepth); } } /** * 展示 * @param root */ public static void show(RBTree.RBNode root) { if (root == null) System.out.println(&quot;EMPTY!&quot;); // 得到树的深度 int treeDepth = getTreeDepth(root); // 最后一行的宽度为2的（n - 1）次方乘3，再加1 // 作为整个二维数组的宽度 int arrayHeight = treeDepth * 2 - 1; int arrayWidth = (2 &lt;&lt; (treeDepth - 2)) * 3 + 1; // 用一个字符串数组来存储每个位置应显示的元素 String[][] res = new String[arrayHeight][arrayWidth]; // 对数组进行初始化，默认为一个空格 for (int i = 0; i &lt; arrayHeight; i++) { for (int j = 0; j &lt; arrayWidth; j++) { res[i][j] = &quot; &quot;; } } // 从根节点开始，递归处理整个树 // res[0][(arrayWidth + 1)/ 2] = (char)(root.val + '0'); writeArray(root, 0, arrayWidth / 2, res, treeDepth); // 此时，已经将所有需要显示的元素储存到了二维数组中，将其拼接并打印即可 for (String[] line : res) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; line.length; i++) { sb.append(line[i]); if (line[i].length() &gt; 1 &amp;&amp; i &lt;= line.length - 1) { i += line[i].length() &gt; 4 ? 2 : line[i].length() - 1; } } System.out.println(sb.toString()); } }} 2.3 RBTreeTest.java123456789101112131415161718package DataStructure.rbtree;import java.util.Scanner;public class RBTreeTest { public static void main(String[] args) { RBTree&lt;String, Object&gt; rbtree = new RBTree(); //测试输入：ijkgefhdabc while(true) { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入key:&quot;); String key = sc.next(); rbtree.insert(key, null); TreeOperation.show(rbtree.getRoot()); } }} 3 HashMap底层红黑树分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent;// 父节点 TreeNode&lt;K,V&gt; left;// 左子树 TreeNode&lt;K,V&gt; right;// 右子树 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red;// 颜色 /** * 有参构造函数 */ TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } /** * 获取红黑树的根节点 */ final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } } /** * 确保给定的根root是树的第一个节点 */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) { ... } /** * 调用find方法查找. */ final TreeNode&lt;K, V&gt; getTreeNode(int h, Object k) { // 从树的根节点开始查找 return ((parent != null) ? root() : this).find(h, k, null); } /** * 从根节点出发查找具有给定哈希值和键的节点.从根节点出发 * 查找当前要插入节点node的父节点 * * 经典二叉查找树的查找过程，先根据hash值比较，再根据key值比较决定是查左子树还是右子树。 */ final TreeNode&lt;K, V&gt; find(int h, Object k, Class&lt;?&gt; kc) { TreeNode&lt;K, V&gt; p = this; do { int ph, dir; K pk; TreeNode&lt;K, V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) // 左子树 p = pl; else if (ph &lt; h) // 右子树 p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) // 找到了直接返回 return p; else if (pl == null) // hash相同但key不同，左子树为空查右子树 p = pr; else if (pr == null) // 右子树为空查左子树 p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) // 通过compare方法比较key值的大小决定使用左子树还是右子树 p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) // 如果以上条件都不通过，则尝试在右子树查找 return q; else // 都没找到就在左子树查找 p = pl; } while (p != null); return null; } /** * 用于在a 和 b 的hash值相等且不可比较时对插入进行排序 */ static int tieBreakOrder(Object a, Object b) { ... } /** * 对链表进行树化的方法 *（1）从链表的第一个元素开始遍历； *（2）将第一个元素作为根节点； *（3）其它元素依次插入到红黑树中，再做平衡； *（4）将根节点移到链表第一元素的位置（因为平衡的时候根节点会改变）； */ final void treeify(Node&lt;K, V&gt;[] tab) { TreeNode&lt;K, V&gt; root = null; for (TreeNode&lt;K, V&gt; x = this, next; x != null; x = next) { next = (TreeNode&lt;K, V&gt;) x.next; x.left = x.right = null; // 第一个元素作为根节点且为黑节点，其它元素依次插入到树中再做平衡 if (root == null) { x.parent = null; x.red = false; root = x; } else { K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; // 从根节点查找元素插入的位置 for (TreeNode&lt;K, V&gt; p = root; ; ) { int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); // 如果最后没找到元素，则插入 TreeNode&lt;K, V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; // 插入后平衡，默认插入的是红节点，在balanceInsertion()方法里 root = balanceInsertion(root, x); break; } } } } // 把根节点移动到链表的头节点，因为经过平衡之后原来的第一个元素不一定是根节点了 moveRootToFront(tab, root); } /** * 对红黑树进行反树化的方法 */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) { Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) { Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; } return hd; } /** * 向树种插入数据的方法 *（1）寻找根节点； *（2）从根节点开始查找； *（3）比较hash值及key值，如果都相同，直接返回，在putVal()方法中决定是否要替换value值； *（4）根据hash值及key值确定在树的左子树还是右子树查找，找到了直接返回； *（5）如果最后没有找到则在树的相应位置插入元素，并做平衡； */ final TreeNode&lt;K, V&gt; putTreeVal(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; // 标记是否找到这个key的节点 boolean searched = false; // 找到树的根节点 TreeNode&lt;K, V&gt; root = (parent != null) ? root() : this; // 从树的根节点开始遍历 for (TreeNode&lt;K, V&gt; p = root; ; ) { // dir=direction，标记是在左边还是右边 // ph=p.hash，当前节点的hash值 int dir, ph; // pk=p.key，当前节点的key值 K pk; if ((ph = p.hash) &gt; h) { // 当前hash比目标hash大，说明在左边 dir = -1; } else if (ph &lt; h) // 当前hash比目标hash小，说明在右边 dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) // 两者hash相同且key相等，说明找到了节点，直接返回该节点 // 回到putVal()中判断是否需要修改其value值 return p; else if ((kc == null &amp;&amp; // 如果k是Comparable的子类则返回其真实的类，否则返回null (kc = comparableClassFor(k)) == null) || // 如果k和pk不是同样的类型则返回0，否则返回两者比较的结果 (dir = compareComparables(kc, k, pk)) == 0) { // 这个条件表示两者hash相同但是其中一个不是Comparable类型或者两者类型不同 // 比如key是Object类型，这时可以传String也可以传Integer，两者hash值可能相同 // 在红黑树中把同样hash值的元素存储在同一颗子树，这里相当于找到了这颗子树的顶点 // 从这个顶点分别遍历其左右子树去寻找有没有跟待插入的key相同的元素 if (!searched) { TreeNode&lt;K, V&gt; q, ch; searched = true; // 遍历左右子树找到了直接返回 if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } // 如果两者类型相同，再根据它们的内存地址计算hash值进行比较 dir = tieBreakOrder(k, pk); } TreeNode&lt;K, V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { // 如果最后确实没找到对应key的元素，则新建一个节点 Node&lt;K, V&gt; xpn = xp.next; TreeNode&lt;K, V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K, V&gt;) xpn).prev = x; // 插入树节点后平衡 // 把root节点移动到链表的第一个节点 moveRootToFront(tab, balanceInsertion(root, x)); return null; } } } // remove 调用 removeNode //public V remove(Object key) { // Node&lt;K, V&gt; e; // return (e = removeNode(hash(key), key, null, false, true)) == null ? // null : e.value; //} final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, index; // 如果桶的数量大于0且待删除的元素所在的桶的第一个元素不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K, V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果第一个元素正好就是要找的元素，赋值给node变量后续删除使用 node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) // 如果第一个元素是树节点，则以树的方式查找节点 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); else { // 否则遍历整个链表查找元素 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } // 如果找到了元素，则看参数是否需要匹配value值，如果不需要匹配直接删除， // 如果需要匹配则看value值是否与传入的value相等 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) // 如果是树节点，调用树的删除方法（以node调用的，是删除自己） ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); else if (node == p) // 如果待删除的元素是第一个元素，则把第二个元素移到第一的位置 tab[index] = node.next; else // 否则删除node节点 p.next = node.next; ++modCount; --size; // 删除节点后置处理 afterNodeRemoval(node); return node; } } return null; } /** *（1）先查找元素所在的节点； *（2）如果找到的节点是树节点，则按树的移除节点处理； *（3）如果找到的节点是桶中的第一个节点，则把第二个节点移到第一的位置； *（4）否则按链表删除节点处理； *（5）修改size，调用移除节点后置处理等； */ final void removeTreeNode(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, boolean movable) { int n; // 如果桶的数量为0直接返回 if (tab == null || (n = tab.length) == 0) return; // 节点在桶中的索引 int index = (n - 1) &amp; hash; // 第一个节点，根节点，根左子节点 TreeNode&lt;K, V&gt; first = (TreeNode&lt;K, V&gt;) tab[index], root = first, rl; // 后继节点，前置节点 TreeNode&lt;K, V&gt; succ = (TreeNode&lt;K, V&gt;) next, pred = prev; if (pred == null) // 如果前置节点为空，说明当前节点是根节点，则把后继节点赋值到第一个节点的位置，相当于删除了当前节点 tab[index] = first = succ; else // 否则把前置节点的下个节点设置为当前节点的后继节点，相当于删除了当前节点 pred.next = succ; // 如果后继节点不为空，则让后继节点的前置节点指向当前节点的前置节点，相当于删除了当前节点 if (succ != null) succ.prev = pred; // 如果第一个节点为空，说明没有后继节点了，直接返回 if (first == null) return; // 如果根节点的父节点不为空，则重新查找父节点 if (root.parent != null) root = root.root(); // 如果根节点为空，则需要反树化（将树转化为链表） // 如果需要移动节点且树的高度比较小，则需要反树化 if (root == null || (movable &amp;&amp; (root.right == null || (rl = root.left) == null || rl.left == null))) { tab[index] = first.untreeify(map); // too small return; } // 分割线，以上都是删除链表中的节点，下面才是直接删除红黑树的节点（因为TreeNode本身即是链表节点又是树节点） // 删除红黑树节点的大致过程是寻找右子树中最小的节点放到删除节点的位置，然后做平衡，此处不过多注释 TreeNode&lt;K, V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) { TreeNode&lt;K, V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K, V&gt; sr = s.right; TreeNode&lt;K, V&gt; pp = p.parent; if (s == pr) { // p was s's direct parent p.parent = s; s.right = p; } else { TreeNode&lt;K, V&gt; sp = s.parent; if ((p.parent = sp) != null) { if (s == sp.left) sp.left = p; else sp.right = p; } if ((s.right = pr) != null) pr.parent = s; } p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; } else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) { TreeNode&lt;K, V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; } TreeNode&lt;K, V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) { // detach TreeNode&lt;K, V&gt; pp = p.parent; p.parent = null; if (pp != null) { if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; } } if (movable) moveRootToFront(tab, r); } final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) { ... } // 左旋 static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) { if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; } return root; } // 右旋 static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) { TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) { if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; } return root; } // 修复红黑树平衡的方法 static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) { if ((xp = x.parent) == null) { x.red = false; return x; } else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) { if ((xppr = xpp.right) != null &amp;&amp; xppr.red) { xppr.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.right) { root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateRight(root, xpp); } } } } else { if (xppl != null &amp;&amp; xppl.red) { xppl.red = false; xp.red = false; xpp.red = true; x = xpp; } else { if (x == xp.left) { root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; } if (xp != null) { xp.red = false; if (xpp != null) { xpp.red = true; root = rotateLeft(root, xpp); } } } } } } static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) { for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) { if (x == null || x == root) return root; else if ((xp = x.parent) == null) { x.red = false; return x; } else if (x.red) { x.red = false; return root; } else if ((xpl = xp.left) == x) { if ((xpr = xp.right) != null &amp;&amp; xpr.red) { xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) { xpr.red = true; x = xp; } else { if (sr == null || !sr.red) { if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; } if (xpr != null) { xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; } if (xp != null) { xp.red = false; root = rotateLeft(root, xp); } x = root; } } } else { // symmetric if (xpl != null &amp;&amp; xpl.red) { xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl == null) x = xp; else { TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) { xpl.red = true; x = xp; } else { if (sl == null || !sl.red) { if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; } if (xpl != null) { xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; } if (xp != null) { xp.red = false; root = rotateRight(root, xp); } x = root; } } } } } /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) { TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; } } 将链表转换为红黑树 treeifyBin()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。 Node&lt;K,V&gt;[] tab = tab 数组名 int hash = hash表示哈希值*/final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; /* 如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)， 就去扩容。而不是将结点变为红黑树。 目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容， 那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。 */ if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //扩容方法 resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { /* 1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化 2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e， e是哈希表中指定位置桶里的链表结点，从第一个开始 */ // hd：红黑树的头结点 tl：红黑树的尾结点 TreeNode&lt;K,V&gt; hd = null, tl = null; do { // 新创建一个树的结点，内容和当前链表结点e一致 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; // 将新创键的p结点赋值给红黑树的头结点 else { p.prev = tl; // 将上一个结点p赋值给现在的p的前一个结点 tl.next = p; // 将现在结点p作为树的尾结点的下一个结点 } tl = p; /* e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null 则回到上面继续取出链表中结点转换为红黑树 */ } while ((e = e.next) != null); /* 让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树 而不是链表数据结构了 */ if ((tab[index] = hd) != null) hd.treeify(tab); }} 参考(110条消息) HashMap底层红黑树实现(自己实现一个简单的红黑树) JDK源码阅读之Entry - 简书 (jianshu.com)","link":"/2022/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"title":"Spring源码阅读（一）","text":"1 前言​ 阅读源码可以帮助提高debug能力以及更加熟悉该框架的原理与构建方式，学习大师的思维。本系列文章将会通过阅读Spring源码，尽力分析各个函数，类，接口等的实现方式与原理，来让自己更加深刻理解这一框架。 ​ 首先，我们要知道，Spring是一个生态体系，其中包含了Spring Framework, Spring Boot, Spring Cloud等，一般说的Spring源码是指Spring Framework中的。 ​ 而在Spring Framework中，又会有许多模块所组成 一共有以下20多个不同的模块 12345spring-aop spring-context-indexer spring-instrument spring-orm spring-webspring-aspects spring-context-support spring-jcl spring-oxm spring-webfluxspring-beans spring-core spring-jdbc spring-r2dbc spring-webmvcspring-context spring-expression spring-jms spring-test spring-websocketspring-messaging spring-tx ​ 而我们知道，Spring最核心的功能就是IOC和AOP，也是本次源码分析的重点 ​ 在图中，也就是Core Container中的模块和AOP、Aspects。接下来，说说大致作用： Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。 Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。 Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。 AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 大致了解了以后，将进入源码分析了 2 环境搭建新建一个maven项目以后，导入以下pom文件 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring_core&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; applicationContext.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;com.w1nd.spring.dao.Person&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;Bruis&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Person.java 123456789package com.w1nd.spring.dao;import lombok.Data;@Datapublic class Person { private Integer age; private String name;} 3 IoC过程​ IoC（控制反转）简单来说就是将创建Bean和注入Bean的权利赋予给了Spring容器，不用程序员自己去管理，在bean生成或初始化的时候，Spring容器就会将数据注入到bean中，又或者通过将对象的引用注入到对象数据域中的方式来注入对方法调用的依赖。 ​ 在Spring容器的设计中，有两个主要的容器机制： 实现BeanFactory接口的简单容器系列 ​ 实现了容器最基本的功能 ApplicationContext应用上下文 ​ 除了拥有BeanFactory的所有功能外，还支持特殊类型bean如上一节中的BeanFactoryPostProcessor和BeanPostProcessor的自动识别、资源加载、容器事件和监听器、国际化支持、单例bean自动初始化等。 对于这两个容器，DefaultListableBeanFactory是是Spring注册及加载bean的默认实现，我们可以直接使用该类来加载 123456789101112131415161718package com.w1nd.spring;import com.w1nd.spring.dao.Person;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); reader.loadBeanDefinitions(&quot;applicationContext.xml&quot;); Person person1 = (Person) beanFactory.getBean(&quot;person&quot;); System.out.println(person1); }} 但在下面演示中，为了更好的了解spring一系列衍生方案，使用ClassPathXmlApplicationContext来加载xml文件，演示程序如下 1234567891011121314package com.w1nd.spring;import com.w1nd.spring.dao.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain { public static void main(String[] args) { //使用spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person person = (Person)context.getBean(&quot;person&quot;); System.out.println(person); }} ​ 另外，我们来看DefaultListableBeanFactory和ClassPathXmlApplicationContext两个类的继承链图，这对于接下来的debug会更有帮助 ​ 建议将该图画下来，debug时对着用箭头标明，这样不会混乱 ​ 下面对上述演示程序debug 3.1 初始 加载ContextClosedEvent，以免后续出现问题 ClassPathXmlApplicationContext构造函数（ClassPathXmlApplicationContext.class） 12345678910111213141516171819202122public ClassPathXmlApplicationContext(String configLocation) throws BeansException { this(new String[] {configLocation}, true, null);}/* 使用给定的父类容器创建新的ClassPathXmlApplicationContext，然后从给定的XML文件加载定义， 加载所有bean定义并且创建所有的单例，在进一步配置上下文后调用refresh。换句话说xml文件的读取， bean的创建和实例化都是在refresh()方法中进行的，refresh()函数中包含了几乎所有的 ApplicationContext中提供的全部功能。*/public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); //设置配置路径 setConfigLocations(configLocations); if (refresh) { //refresh Spring容器 很重要，这个方法 refresh(); }} 设置配置路径（AbstractRefreshableConfigApplicationContext.class） 12345678910111213//给configLocations字符串数组设置值，支持多个配置文件已数组方式同时传入。public void setConfigLocations(@Nullable String... locations) { if (locations != null) { Assert.noNullElements(locations, &quot;Config locations must not be null&quot;); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) { this.configLocations[i] = resolvePath(locations[i]).trim(); } } else { this.configLocations = null; }} 3.2 refresh refresh函数（AbstractApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 简单来说，Spring容器的初始化是在refresh()方法来启动的，这个方法标志着IOC容器的正式启动。 具体来说，这里的启动包括了BeanDefinition和Resource的定位、载入和注册三个基本过程。*/@Overridepublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;); // 准备刷新容器（上下文环境） prepareRefresh(); // 通知子类刷新内部bean工厂，初始化BeanFactory并进行XML的解析读取 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 准备 bean 工厂以在此上下文中使用。 prepareBeanFactory(beanFactory); try { // 允许在上下文子类中对 bean 工厂进行后处理。 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;); // 调用在上下文中注册为 bean 的工厂处理器。 invokeBeanFactoryPostProcessors(beanFactory); // 注册拦截 bean 创建的 bean 处理器。 registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // 为此上下文初始化消息源。 initMessageSource(); // 为此上下文初始化事件多播器。 initApplicationEventMulticaster(); // 初始化特定上下文子类中的其他特殊 bean。 onRefresh(); // 检查侦听器 bean 并注册它们。 registerListeners(); // 实例化所有剩余的（非惰性初始化）单例。 finishBeanFactoryInitialization(beanFactory); // 最后一步：发布相应的事件。 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } }} ​ 鉴于该方法的重要性，下面对其函数名分目录分别讲解，每个函数会逐渐深入其子函数去分序号，部分不会讲的可能不太重要或仅知道该函数作用即可。往后，每个函数名后面会写明所在类，部分辅助函数和其他函数放在同个代码块说明，代码块的函数通常在同个类，如果不在，会在注释标明 3.3 prepareRefresh prepareRefresh（）（AbstractApplicationContext.class） 1234567891011121314151617181920212223242526272829303132333435363738/* 准备此上下文以进行刷新、设置其启动日期和活动标志以及执行任何属性源的初始化。*/protected void prepareRefresh() { // 切换到活动状态 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) { if (logger.isTraceEnabled()) { logger.trace(&quot;Refreshing &quot; + this); } else { logger.debug(&quot;Refreshing &quot; + getDisplayName()); } } // 初始化上下文环境中的任何占位符属性源。这里对于子类啥都不会干 initPropertySources(); // 验证所有标记为必需的属性都是可解析的： // 请参阅 ConfigurablePropertyResolvesetRequiredProperties getEnvironment().validateRequiredProperties(); // 存储预刷新 ApplicationListeners... if (this.earlyApplicationListeners == null) { this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); } else { // 将本地应用程序侦听器重置为预刷新状态。 this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); } // 允许收集早期应用程序事件，一旦多播器可用就发布... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();} 3.4 obtainFreshBeanFactory该方法的时序图 obtainFreshBeanFactory （AbstractApplicationContext.class） 1234567/* 告诉子类刷新内部 bean 工厂。会返回新的BeanFactory实例*/protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { refreshBeanFactory(); return getBeanFactory();} refreshBeanFactory（AbstractRefreshableApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 此实现执行此上下文的底层 bean 工厂的实际刷新，关闭先前的 bean 工厂（如果有）并为上下文生命周期的下一阶段初始化一个新的 bean 工厂。*/@Overrideprotected final void refreshBeanFactory() throws BeansException { // 如果有 Bean工厂，则关闭该工厂 if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // 创建一个新bean工厂，这里的DefaultListableBeanFactory就是前面的Spring核心类，这个类真的很重要！ DefaultListableBeanFactory beanFactory = createBeanFactory(); // 序列化指定ID，如果需要的话，让这个BeanFactory从ID反序列化掉BeanFactory对象 beanFactory.setSerializationId(getId()); // 自定义此上下文使用的内部 bean 工厂。为每次 refresh() 尝试调用。默认实现应用此上下文 // 的“allowBeanDefinitionOverriding”和“allowCircularReferences”设置（如果指定）。 // 可以在子类中重写以自定义任何DefaultListableBeanFactory 的设置。 customizeBeanFactory(beanFactory); // 加载bean定义信息，这一步实际上就从XML配置文件里的bean信息给读取到了Factory里了。 loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; } catch (IOException ex) { throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); }}/* 确定此上下文当前是否包含 bean 工厂，即至少已刷新一次且尚未关闭。*/ protected final boolean hasBeanFactory() { return (this.beanFactory != null);}/* 关闭BeanFactory实例*/@Overrideprotected final void closeBeanFactory() { DefaultListableBeanFactory beanFactory = this.beanFactory; if (beanFactory != null) { beanFactory.setSerializationId(null); this.beanFactory = null; }} ​ 上面图片，是loadBeanDefinitions（）方法运行完之后，eanFactory变量里面存放着一个ConcurrentHashMap变量，用于存放着person这个KV键值对，Key为person，Value为一个ArrayList的变量，里面存放着person的两个属性：age、name。下面接着深入该方法分析 loadBeanDefinitions（AbstractXmlApplicationContext.class） ​ BeanDefinition，顾名思义，用于定义bean信息的类，包含bean的class类型、构造参数、属性值等信息，每个bean对应一个BeanDefinition的实例。简化BeanDefinition仅包含bean的class类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 通过 XmlBeanDefinitionReader 加载 bean 定义。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 为给定的 BeanFactory 创建一个新的 XmlBeanDefinitionReader。 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 使用此上下文的资源加载环境配置 bean 定义阅读器。 beanDefinitionReader.setEnvironment(this.getEnvironment()); // 设置 ResourceLoader 以用于资源定位。 beanDefinitionReader.setResourceLoader(this); // 设置要用于解析的 SAX 实体解析器。默认情况下，将使用 ResourceEntityResolver。 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 允许子类提供阅读器的自定义初始化 initBeanDefinitionReader(beanDefinitionReader); // 实际加载 bean 定义。 loadBeanDefinitions(beanDefinitionReader);}/* AbstractApplicationContext.class 以可配置的形式返回此应用程序上下文的环境，允许进一步定制。 如果未指定，则将通过 createEnvironment() 初始化默认环境。*/@Overridepublic ConfigurableEnvironment getEnvironment() { if (this.environment == null) { this.environment = createEnvironment(); } return this.environment;}/* XmlBeanDefinitionReader.class*/public void setEntityResolver(@Nullable EntityResolver entityResolver) { this.entityResolver = entityResolver;}/* 初始化用于加载此上下文的 bean 定义的 bean 定义阅读器。默认实现为空。 可以在子类中被覆盖，例如用于关闭 XML 验证或使用不同的 XmlBeanDefinitionParser 实现。*/protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) { reader.setValidating(this.validating);} loadBeanDefinitions（AbstractXmlApplicationContext.class） ​ 注意这个和上个不一样，是重载 1234567891011121314/* 使用给定的 XmlBeanDefinitionReader 加载 bean 定义。 bean 工厂的生命周期由 refreshBeanFactory 方法处理；因此这个方法只是应该加载和或注册 bean 定义。*/protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); // &lt;-------是string路径会执行这个 }} loadBeanDefinitions（AbstractBeanDefinationReader.class） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, &quot;Location array must not be null&quot;); int count = 0; for (String location : locations) { count += loadBeanDefinitions(location); } return count;}/* 从指定的资源位置加载 bean 定义。位置也可以是位置模式， 前提是此 bean 定义读取器的 ResourceLoader 是 ResourcePatternResolver。*/public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException { ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) { throw new BeanDefinitionStoreException( &quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;); } if (resourceLoader instanceof ResourcePatternResolver) { // 资源模式匹配可用。 try { Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); // 从指定的 XML 文件加载 bean 定义。这里debug会进去XmlBeanDefinitionReader， int count = loadBeanDefinitions(resources); if (actualResources != null) { Collections.addAll(actualResources, resources); } if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;); } return count; } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); } } else { // 只能通过绝对 URL 加载单个资源。 Resource resource = resourceLoader.getResource(location); int count = loadBeanDefinitions(resource); if (actualResources != null) { actualResources.add(resource); } if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;); } return count; }} getResources（PathMatchingResourcePatternResolver.class） 12345678910111213141516171819202122232425262728@Overridepublic Resource[] getResources(String locationPattern) throws IOException { Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) { // 类路径资源（可能有多个同名资源） if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) { // 类路径资源模式 return findPathMatchingResources(locationPattern); } else { // 具有给定名称的所有类路径资源 return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); } } else { // 通常只在前缀后面查找一个模式，并且在Tomcat之后只有“* /”分隔符之后的“war：”协议。 int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(':') + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) { // 文件模式 return findPathMatchingResources(locationPattern); } else { // 具有给定名称的单个资源 return new Resource[] {getResourceLoader().getResource(locationPattern)}; } }} loadBeanDefinitions（XmlBeanDefinitionReader.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 从XML配置文件中获取bean定义信息*/public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); ... Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } ... try { InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //获取到读取xml配置文件的InputStream流后，进行BeanDefinitions的加载 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { ... } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }}/* 真正从xml配置文件中加载Bean定义信息*/protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { //获取xml的配置信息并封装为Document对象 Document doc = doLoadDocument(inputSource, resource); return this.registerBeanDefinitions(doc, resource); } catch (BeanDefinitionStoreException ex) { ... }} 以上的流程是在读取BeanDefinition信息，下面看如何将其注册 registerBeanDefinitions（XmlBeanDefinitionReader.class） 123456789101112/* 注册包含在给定 DOM 文档中的 bean 定义*/public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 创建 BeanDefinitionDocumentReader 以用于从 XML 文档中实际读取 bean 定义 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 注册表中定义的 bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // 打开一个 DOM 文档；然后初始化在 &lt;beans&gt; 级别指定的默认设置；然后解析包含的 bean 定义。 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // &lt;----------- return getRegistry().getBeanDefinitionCount() - countBefore;} registerBeanDefinitions（DefaultBeanDefinitionDocumentReader.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* 注册并解析包含的 bean 定义。*/public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; doRegisterBeanDefinitions(doc.getDocumentElement());}/* 在给定的根 &lt;beans&gt; 元素中注册每个 bean 定义。*/protected void doRegisterBeanDefinitions(Element root) { BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 解析beanDefinitions信息，经过这个方法，beanFactory中就会保存从xml配置文件中解析而来的信息 parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;}/* 解析文档中根级别的元素：“import”、“alias”、“bean”*/protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析默认元素 parseDefaultElement(ele, delegate); } else { delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); }}/* 解析默认元素*/private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { // 读取到xml配置文件的&lt;bean&gt;节点 processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 递归 doRegisterBeanDefinitions(ele); }}/* 处理给定的 bean 元素，解析 bean 定义并将其注册到注册表。*/protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 解析提供的 &lt;bean&gt; 元素 if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); // 如果适用，通过命名空间处理程序装饰给定的 bean 定义。 try { // 注册最终的装饰实例。 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // 发送注册事件。 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} parseBeanDefinitionElement（BeanDefinitionParserDelegate.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);}/* 解析提供的 &lt;bean&gt; 元素。*/@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } //终于，这里要解析beanDefinition了 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null;}/* 解析 bean 定义本身，而不考虑名称或别名。如果在解析 bean 定义期间出现问题，则可能返回 null。*/@Nullablepublic AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // 创建BeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 通过构造器解析参数值 parseConstructorArgElements(ele, bd); // 通过property的value解析值吗，本文的程序xml就是通过property属性设置bean的值的，最终被这一方法所解析出来。 parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null;}// 解析给定 bean 元素的属性子元素。public void parsePropertyElements(Element beanEle, BeanDefinition bd) { NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { // 解析出参数值来，这里就真正的讲age的23，和name的bruis值解析出来并防止在一个组装的类里面存放着。 // 因为这里有两个bean，所以要循环调用两次parsePropertyElement()方法 parsePropertyElement((Element) node, bd); } }}// 解析属性元素public void parsePropertyElement(Element ele, BeanDefinition bd) { String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) { error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { if (bd.getPropertyValues().contains(propertyName)) { error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele); return; } Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); // 就是这一步，将K为age、name，值分别为23、bruis的KV对存放在了Spring容器里。 bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); }} 总结：该方法实际上实现了容器的初始化以及BeanDefinition的注册与加载，方便后续Bean的创建和加载 容器的初始化过程如下： 第一个过程是Resource定位过程。这个Resource定位过程指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一接口。这个定位过程类似于容器寻找数据的过程，就像使用水桶装水先要把水找到一样。 第二个过程是BeanDefinition的载入。这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。下面介绍这个数据结构的详细定义。具体来说，这个BeanDefinition实际上就是POJO对象在IOC容器的抽象，通过这个BeanDefinition定义的数据结构，使IOC能够方便地对POJO对象进行管理。 第三个过程是向IOC容器注册这些BeanDefinition的过程，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的。这个注册过程把载入过程中解析到的BeanDefinition向IOC容器进行注册。通过上面的分析，我们知道IOC内部将BeanDefinition注册到了ConcurrentHashMap中。 3.5 prepareBeanFactory prepareBeanFactory（AbstractApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 配置工厂的标准上下文特征，例如上下文的 ClassLoader 和后处理器*/protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 告诉内部 bean 工厂使用上下文的类加载器等。 beanFactory.setBeanClassLoader(getClassLoader()); if (!shouldIgnoreSpel) { beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); } beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 使用上下文回调配置 bean 工厂。 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class); // BeanFactory 接口未在普通工厂中注册为可解析类型。 // MessageSource 作为 bean 注册（并为自动装配找到）。 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 将用于检测内部 bean 的早期后处理器注册为 ApplicationListener。 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 检测 LoadTimeWeaver 并准备编织（如果找到）。 if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // 为类型匹配设置一个临时 ClassLoader。 beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册默认环境 bean。 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) { beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup()); }} 3.6 postProcessBeanFactory postProcessBeanFactory（AbstractApplicationContext.class） 1234567/* 在标准初始化之后修改应用程序上下文的内部 bean 工厂。所有 bean 定义都将被加载， 但还没有 bean 被实例化。这允许在某些 ApplicationContext 实现中注册特殊的 BeanPostProcessors 等。 简单来说，就是允许我们在bean实例化之前修改bean的定义信息即BeanDefinition的信息*/protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {} 3.7 invokeBeanFactoryPostProcessors invokeBeanFactoryPostProcessors （AbstractApplicationContext.class） 1234567891011// 实例化并调用所有已注册的 BeanFactoryPostProcessor bean，如果给定，则尊重显式顺序。必须在单例实例化之前调用。protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); }} 3.8 registerBeanPostProcessors registerBeanPostProcessors （AbstractApplicationContext.class） 123456/* 实例化并注册所有 BeanPostProcessor bean，如果给定，则尊重显式顺序。必须在应用程序 bean 的任何实例化之前调用。*/protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);} 3.9 initMessageSource initMessageSource（AbstractApplicationContext.class） 123456789101112131415161718192021222324252627282930/* 初始化消息源。如果没有在此上下文中定义，则使用父级。*/protected void initMessageSource() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) { this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); // 使 MessageSource 感知父 MessageSource。 if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) { HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource; if (hms.getParentMessageSource() == null) { // 如果尚未注册父消息源，则仅将父上下文设置为父消息源。 hms.setParentMessageSource(getInternalParentMessageSource()); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;); } } else { // 使用空 MessageSource 能够接受 getMessage 调用。 DelegatingMessageSource dms = new DelegatingMessageSource(); dms.setParentMessageSource(getInternalParentMessageSource()); this.messageSource = dms; beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource); if (logger.isTraceEnabled()) { logger.trace(&quot;No '&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;' bean, using [&quot; + this.messageSource + &quot;]&quot;); } }} 3.10 initApplicationEventMulticaster initApplicationEventMulticaster（AbstractApplicationContext.class） 123456789101112131415161718192021/* 初始化 ApplicationEventMulticaster。如果上下文中没有定义，则使用 SimpleApplicationEventMulticaster。*/protected void initApplicationEventMulticaster() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) { this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (logger.isTraceEnabled()) { logger.trace(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;); } } else { this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); if (logger.isTraceEnabled()) { logger.trace(&quot;No '&quot; + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + &quot;' bean, using &quot; + &quot;[&quot; + this.applicationEventMulticaster.getClass().getSimpleName() + &quot;]&quot;); } }} 3.11 onRefresh onRefresh（AbstractApplicationContext.class） 123456/* 可以重写以添加特定于上下文的刷新工作的模板方法。在单例实例化之前调用特殊 bean 的初始化。这个实现是空的。*/protected void onRefresh() throws BeansException { // 对于子类：默认情况下什么都不做。} 3.12 registerListeners registerListeners（AbstractApplicationContext.class） 123456789101112131415161718192021protected void registerListeners() { // 首先注册静态指定的监听器。 for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // 不要在这里初始化 FactoryBeans：我们需要让所有常规 bean 保持未初始化状态，以让后处理器应用于它们！ String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // 发布早期应用程序事件，因为我们终于有了一个多播器...... Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (!CollectionUtils.isEmpty(earlyEventsToProcess)) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } }} 3.12 finishBeanFactoryInitialization finishBeanFactoryInitialization（AbstractApplicationContext.class） 1234567891011121314151617181920212223242526272829303132/* 完成此上下文的 bean 工厂的初始化，初始化所有剩余的单例 bean。*/protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // 为此上下文初始化转换服务。 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // 如果之前没有注册过任何 BeanFactoryPostProcessor（例如 PropertySourcesPlaceholderConfigurer bean）， // 则注册一个默认的嵌入值解析器：此时，主要用于解析注释属性值。 if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); } // 尽早初始化 LoadTimeWeaverAware bean，以便尽早注册它们的转换器。 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // 停止使用临时 ClassLoader 进行类型匹配。 beanFactory.setTempClassLoader(null); // 允许缓存所有 bean 定义元数据，而不是期望进一步的更改。 beanFactory.freezeConfiguration(); // 实例化所有剩余的（非惰性初始化）单例。 beanFactory.preInstantiateSingletons();} ​ 这里的懒加载的意思，指的是bean单例不是在Spring容器初始化的时候就创建的，而是在要使用该bean的时候，才会创建该bean。 preInstantiateSingletons（DefaultListableBeanFactory.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic void preInstantiateSingletons() throws BeansException { if (logger.isTraceEnabled()) { logger.trace(&quot;Pre-instantiating singletons in &quot; + this); } // 迭代一个副本以允许 init 方法依次注册新的 bean 定义。 // 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。 // 获取所有的bean定义的名字，并保存在集合List里面。 List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // 触发所有非延迟单例bean的初始化... for (String beanName : beanNames) { // 触发所有适用bean的后初始化回调 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { if (isFactoryBean(beanName)) { Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged( (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } } else { getBean(beanName); } } } // 为所有适用的 bean 触发初始化后回调... for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { StartupStep smartInitialize = this.getApplicationStartup().start(&quot;spring.beans.smart-initialize&quot;) .tag(&quot;beanName&quot;, beanName); SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } smartInitialize.end(); } }} getBean（AbstractBeanFactory.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159@Overridepublic Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false);}/* 返回指定 bean 的一个实例，该实例可以是共享的，也可以是独立的。*/protected &lt;T&gt; T doGetBean( String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { // 去除name上存在的工厂bean的前缀 String beanName = transformedBeanName(name); Object beanInstance; // 快速判断单例缓存中是否存在该bean，如果存在则返回单例bean；否则返回null Object sharedInstance = getSingleton(beanName); // &lt;-------------- if (sharedInstance != null &amp;&amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName + &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } // 从单例缓存中获取单例bean beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // 如果我们已经在创建这个 bean 实例，则失败：我们可能在循环引用中。 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // 检查此工厂中是否存在 bean 定义。 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // 未找到 -&gt; 检查父级。 String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // 使用显式参数委托给父级。 return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // 没有 args -&gt; 委托给标准 getBean 方法。 return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } if (!typeCheckOnly) { markBeanAsCreated(beanName); // 将指定的 bean 标记为已创建（或即将创建）。这允许 bean 工厂优化其缓存以重复创建指定的 bean } StartupStep beanCreation = this.applicationStartup.start(&quot;spring.beans.instantiate&quot;) .tag(&quot;beanName&quot;, name); try { if (requiredType != null) { beanCreation.tag(&quot;beanType&quot;, requiredType::toString); } RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 保证当前 bean 所依赖的 bean 的初始化。 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } registerDependentBean(dep, beanName); try { getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } // 创建 bean 实例。 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&gt; { try { return createBean(beanName, mbd, args); // &lt; ----------------- } catch (BeansException ex) { // 从单例缓存中显式删除实例：它可能已被创建过程急切地放在那里，以允许循环引用解析。 // 还要删除任何接收到对 bean 的临时引用的 bean。 destroySingleton(beanName); throw ex; } }); beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } else if (mbd.isPrototype()) { // 这是一个原型 -&gt; 创建一个新实例。 Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) { throw new IllegalStateException(&quot;No scope name defined for bean '&quot; + beanName + &quot;'&quot;); } Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;); } try { Object scopedInstance = scope.get(beanName, () -&gt; { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new ScopeNotActiveException(beanName, scopeName, ex); } } } catch (BeansException ex) { beanCreation.tag(&quot;exception&quot;, ex.getClass().toString()); beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; } finally { beanCreation.end(); } } return adaptBeanInstance(name, beanInstance, requiredType);} getSingleton（DefaultSingletonBeanRegistry.class） 123456789101112131415161718192021222324252627282930313233343536@Override@Nullablepublic Object getSingleton(String beanName) { return getSingleton(beanName, true);}/* 返回在给定名称下注册的（原始）单例对象。 检查已经实例化的单例，还允许对当前创建的单例进行早期引用（解决循环引用）。*/@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) { // 快速检查没有完整单例锁的现有实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) { synchronized (this.singletonObjects) { // 在完整的单例锁中一致地创建早期引用 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) { ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } } } return singletonObject;} createBean（AbstractAutowireCapableBeanFactory.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342/* 此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等。*/@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (logger.isTraceEnabled()) { logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;); } RootBeanDefinition mbdToUse = mbd; // 确保此时实际解析了 bean 类，并克隆 bean 定义以防动态解析的 Class 无法存储在共享的合并 bean 定义中。 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // 准备方法覆盖 try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); } try { // 调用实例化前的后置处理器，在这个后置处理器中可以对bean进行处理，可以返回由后置处理器处理的bean而不是被实例化的bean。 // 换句话说就是这里可以拦截住bean的实例化 // Spring的后置处理器后面有机会再专门写一篇博文来总结学习一下 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); } try { Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) { logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;); } return beanInstance; } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) { // 先前检测到的异常已经具有正确的 bean 创建上下文，或者要与 DefaultSingletonBeanRegistry 通信的非法单例状态。 throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex); }}/* 正在的创建一个bean，并且按照配置文件的配置来实例化该bean。如果没有初始化前的后置处理器的调用，则调用该方法。*/protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // 创建一个包装类，用于包装真正要创建的bean。 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 使用适当的实例化策略例如：工厂方法、构造函数自动装配或者简单实例化 来为指定bean创建新的实例。 // 这里仅仅是简单的实例化，为bean设置默认初始值 // 也就是name为null，age为0。此时instanceWrapper任然还只是一个包装bean，并不是一个真正意义上的person类bean。 // 1. 实例化 instanceWrapper = createBeanInstance(beanName, mbd, args); } // 终于，我们千辛万苦打断点调试来到了这一步，就是这一步， 获得了我们想要的person类bean。 // 只需要在BeanWrapper里取出WrapperInstance即可。 // 接下来就是要拿这个创建好的bean和BeanDefinition进行实例化了。 Object bean = instanceWrapper.getWrappedInstance(); // 获取bean的类型 Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // 调用后置处理器去修改bean的定义信息。 synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, ex); } mbd.postProcessed = true; } } // 即使被 BeanFactoryAware 等生命周期接口触发，也急切地缓存单例以解析循环引用。 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(&quot;Eagerly caching bean '&quot; + beanName + &quot;' to allow for resolving potential circular references&quot;); } addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); } // 实例化一个真正使用的bean。 Object exposedObject = bean; try { // 2. 属性赋值 populateBean(beanName, mbd, instanceWrapper); // &lt;-------------------- // 3. 初始化 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); } } if (earlySingletonExposure) { Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;); } } } } // 销毁注册回调接口 try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); } return exposedObject;}/* 使用 bean 定义中的属性值填充给定 BeanWrapper 中的 bean 实例。*/protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // 让任何 InstantiationAwareBeanPostProcessors 有机会在设置属性之前修改 bean 的状态。 // 例如，这可以用于支持字段注入的样式。 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { return; } } } // 取出BeanDefinition里的属性值 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // 如果设置的是自动装配模式，则由自动装配来进行赋值 if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过bean名自动装配 if (resolvedAutowireMode == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // 通过bean类型自动装配 if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } checkDependencies(beanName, mbd, filteredPds, pvs); } // 这里的PropertyValues已经包含了bean字段属性的设置值了 if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); }}/* 应用给定的属性值，解析对此 bean 工厂中其他 bean 的任何运行时引用。必须使用深拷贝，所以我们不会永久修改这个属性。*/protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) { if (pvs.isEmpty()) { return; } if (System.getSecurityManager() != null &amp;&amp; bw instanceof BeanWrapperImpl) { ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext()); } MutablePropertyValues mpvs = null; // 源属性值 List&lt;PropertyValue&gt; original; if (pvs instanceof MutablePropertyValues) { mpvs = (MutablePropertyValues) pvs; if (mpvs.isConverted()) { // Shortcut: use the pre-converted values as-is. try { bw.setPropertyValues(mpvs); return; } catch (BeansException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex); } } original = mpvs.getPropertyValueList(); } else { original = Arrays.asList(pvs.getPropertyValues()); } TypeConverter converter = getCustomTypeConverter(); if (converter == null) { converter = bw; } BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); // 拷贝值；创建一个深拷贝副本，应用于任何bean引用此bean的情况。 List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size()); boolean resolveNecessary = false; for (PropertyValue pv : original) { if (pv.isConverted()) { deepCopy.add(pv); } else { String propertyName = pv.getName(); Object originalValue = pv.getValue(); if (originalValue == AutowiredPropertyMarker.INSTANCE) { Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod(); if (writeMethod == null) { throw new IllegalArgumentException(&quot;Autowire marker for property without write method: &quot; + pv); } originalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true); } Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); Object convertedValue = resolvedValue; boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName); if (convertible) { convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter); } // 可能在合并的bean定义中存储转换后的值，以避免为每个创建的bean实例重新转换。 if (resolvedValue == originalValue) { if (convertible) { pv.setConvertedValue(convertedValue); } deepCopy.add(pv); } else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp; !((TypedStringValue) originalValue).isDynamic() &amp;&amp; !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) { pv.setConvertedValue(convertedValue); deepCopy.add(pv); } else { resolveNecessary = true; deepCopy.add(new PropertyValue(pv, convertedValue)); } } } if (mpvs != null &amp;&amp; !resolveNecessary) { mpvs.setConverted(); } // 将深拷贝属性数组填充到beanWrapper中。这里就真正的将属性值填充到了bean上，实现了 try { bw.setPropertyValues(new MutablePropertyValues(deepCopy)); } catch (BeansException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex); }} 3.13 finishRefresh finishRefresh（AbstractApplicationContext.class） 123456789101112131415161718192021/* 完成此上下文的刷新，调用 LifecycleProcessor 的 onRefresh() 方法并发布 ContextRefreshedEvent。*/protected void finishRefresh() { // 清除上下文级别的资源缓存（例如扫描中的 ASM 元数据）。 clearResourceCaches(); //为此上下文初始化生命周期处理器。 initLifecycleProcessor(); // 首先将刷新传播到生命周期处理器。 getLifecycleProcessor().onRefresh(); // 发布最终事件。 publishEvent(new ContextRefreshedEvent(this)); // 参与 LiveBeansView MBean（如果处于活动状态）。 if (!NativeDetector.inNativeImage()) { LiveBeansView.registerApplicationContext(this); }} ​ 经过上面的分析，就知道真正的对bean赋值填充是在AbstractAutowireCapableBeanFactory.class类里的applyPropertyValues方法里的，并且是通过对原属性值进行了一次深拷贝，然后将深拷贝后的属性值填充到bean里的。 4. 总结​ 本次源码分析，主要还是对容器的创建与初始化进行分析，也就是obtainFreshBeanFactory 和finishBeanFactoryInitialization这两个函数，其他函数是对其的加工或者预处理，留到后面再详细展开。 参考(99条消息) Spring和Spring Framework的理解_海TAO的博客-CSDN博客_springframework和spring JavaSourceCodeLearning/深入Spring源码系列（二）——深入Spring容器，通过源码阅读和时序图来彻底弄懂Spring容器（上）","link":"/2022/02/08/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"CMU15445","slug":"CMU15445","link":"/tags/CMU15445/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"BUG","slug":"BUG","link":"/tags/BUG/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"网络模型","slug":"网络模型","link":"/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"},{"name":"周赛","slug":"周赛","link":"/tags/%E5%91%A8%E8%B5%9B/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"LC双周赛","slug":"LC双周赛","link":"/tags/LC%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"name":"双周赛","slug":"双周赛","link":"/tags/%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"笔试","slug":"笔试","link":"/tags/%E7%AC%94%E8%AF%95/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"RPC","slug":"RPC","link":"/tags/RPC/"},{"name":"动态代理","slug":"动态代理","link":"/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"场景算法","slug":"场景算法","link":"/tags/%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"状态DP","slug":"状态DP","link":"/tags/%E7%8A%B6%E6%80%81DP/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"背包DP","slug":"背包DP","link":"/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"序列DP","slug":"序列DP","link":"/tags/%E5%BA%8F%E5%88%97DP/"},{"name":"线性DP","slug":"线性DP","link":"/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"公开课","slug":"公开课","link":"/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"JVM","slug":"Java/JVM","link":"/categories/Java/JVM/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂烩","slug":"杂烩","link":"/categories/%E6%9D%82%E7%83%A9/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"},{"name":"RPC","slug":"框架/RPC","link":"/categories/%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Spring","slug":"框架/Spring","link":"/categories/%E6%A1%86%E6%9E%B6/Spring/"}]}