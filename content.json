{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/29/hello-world/"},{"title":"zk入门","text":"Zookeeper入门1. ZK简介​ 一个分布式的，开放源码的分布式应用程序协调服务。 2. ZK数据模型2.1 模型结构​ 2.2 模型的特点 每个子目录如/node1都被称作一个znode（节点）。这个znode是它所在的路径唯一标识 znode可以有子节点目录，并且每个znode可以存储数据 znode是有有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据 znode是可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端 3. 节点的分类3.1 持久节点（PERSISTENT）​ 指在节点创建后，就一直存在，知道有删除操作来主动删除这个节点–会因为创建该节点的客户端会话失效而消失 3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）​ 这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 3.3 临时节点（EPHEMERAL）​ 和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）​ 具有临时节点特点额外的特性是，每个父节点会为他的第一级子节点维护一份时序。这点和刚才提到的持久顺序节点类似 4. 安装4.1 linux系统安装 安装JDK 12tar -zxvf jdk-8u171-linux-x64.tar.gz mv ./jdk1.8.0_171/ /usr/java/ 12vim /etc/profilesource /etc/profile 安装ZK 1tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz 1cd conf/ 由于zk默认加载的是zoo.cfg，所以需要改名 1mv zoo_sample.cfg zoo.cfg 由于zookeeper加载要将节点加载到磁盘，所以需要预先新建一个磁盘目录 1mkdir /tmp/zookeeper 启动ZK 1234567[root@localhost bin]# ./zkServer.sh start /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg ZooKeeper JMX enabled by defaultUsing config: /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfgStarting zookeeper ... STARTED# 查看是否启动jps ​ QuorumPeerMain就是zk 连接ZK 1./zkCli.sh -server 192.168.9.3:2181 如果是本机，-server后可不加 5. 配置文件说明 tickTime：集群节点心跳时间， initLimit：初始化集群时集群节点同步超时时间20s syncLimit：集群在运行过程中，同步数据超时时间为10s（这里5是指5次心跳） dataDir：默认数据存储位置 clientPort：zk服务监听端口号 maxClientCnxns：线程池线程数量 6. 客户端基本指令 查看节点 1ls / # 根节点 创建节点 12345create path data # 创建一个节点，并给节点绑定数据（默认是持久性节点）- create path data # 持久节点- create -s path data # 持久性顺序节点- create -e path data # 临时性节点- create -e -s path data # 临时顺序节点 quit：会直接导致会话断开，会话失效，其他ctrl+c会导致触发倒计时 注：临时节点上不能创建任何节点 查看节点状态 1stat /node1 cZxid：创建事务ID ctime：创建时间 mZxid：修改ID mtime：修改时间 pZxid：父结点版本号 cversion：创建版本号 dataVersion：数据版本号 aclVersion： ephemerslOwner：是否是临时节点 dataLength：存储数据长度 numChildren：子节点数量 获得节点上绑定的数据信息 1get /node1 删除节点 1delete /node1 只能删除没有子节点的节点，如果有子节点，则无法删除 若想删除有子节点的，则需要deleteall 7. watch节点监听机制监听分为节点目录监听和节点数据监听 目录监听是监听节点目录的变化 数据监听是监听当前节点数据的变化 两种监听都是一次性的，也就是发现一个修改，下次修改则不会触发监听机制 目录监听 1ls -w /node 再次创建，无触发 数据监听 1get -w /node 8. Java操作ZK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.w1nd.test;import org.I0Itec.zkclient.IZkChildListener;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import org.I0Itec.zkclient.serialize.SerializableSerializer;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.data.Stat;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.List;public class TestZKClient { private ZkClient zkClient; // 1. 在zk创建节点 @Test public void testCreateNode() { // 1. 持久节点 zkClient.create(&quot;/node1&quot;, &quot;xiaochen&quot;, CreateMode.PERSISTENT); // 2. 持久顺序节点 zkClient.create(&quot;/node1/names&quot;, &quot;zhangsan&quot;, CreateMode.PERSISTENT_SEQUENTIAL); // 3. 临时节点 zkClient.create(&quot;/node1/lists&quot;, &quot;xiaoxiao&quot;, CreateMode.EPHEMERAL); // 4. 临时顺序节点 zkClient.create(&quot;/node1/lists1&quot;, &quot;xiaoming&quot;, CreateMode.EPHEMERAL_SEQUENTIAL); } // 2. 删除节点 @Test public void testDeleteNode() { // 删除没有子节点的节点，返回值：是否成功 boolean delete = zkClient.delete(&quot;/node1&quot;); // 递归删除节点信息，返回值：是否删除成功 boolean b = zkClient.deleteRecursive(&quot;/node1&quot;); } // 3. 查询当前节点下所有子节点 @Test public void testFindNodes() { // 获取指定路径的节点信息 List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;); for (String child : children) { System.out.println(child); } } // 4. 查看某个节点数据，注意：通过java客户端操作需要保证节点存储的数据和节点时序列化方式一致 // shell中的数据序列化方式和java中的不一致 @Test public void testFindNodeData() { Object readData = zkClient.readData(&quot;/node3&quot;); System.out.println(readData); } // 5. 查看节点状态信息 @Test public void testFindNodeDataAndStat() { Stat stat = new Stat(); Object readData = zkClient.readData(&quot;/node1&quot;, stat); System.out.println(readData); System.out.println(stat); } // 6. 修改节点数据 @Test public void testWriteData() { // User user = new User(); // user.setId(1); // zkClient.writeData(&quot;/node1&quot;, user); } // 监听节点数据的变化 @Test public void testOnNodeDataChange() throws IOException { zkClient.subscribeDataChanges(&quot;/node1&quot;, new IZkDataListener() { // 当节点数据变化时触发对应这个方法 @Override public void handleDataChange(String s, Object o) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); System.out.println(&quot;当前节点变化后数据：&quot; + o); } // 当前节点删除时触发这个方法 @Override public void handleDataDeleted(String s) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); } }); System.in.read(); // 阻塞当前监听 } // 监听节点目录的变化 @Test public void testOnNodesChange() throws IOException { zkClient.subscribeChildChanges(&quot;/node1&quot;, new IZkChildListener() { // 当节点的发生变化时，会自动调用这个方法 // 参数1：父节点名称 // 参数2：父节点中的所有子节点名称 @Override public void handleChildChange(String s, List&lt;String&gt; list) throws Exception { System.out.println(&quot;父节点名称：&quot; + s); System.out.println(&quot;发生变更后孩子节点名称：&quot;); for (String name: list) { System.out.println(name); } } }); System.in.read(); // 阻塞当前监听 } @Before public void before() { // 参数1：Server服务器ip地址 // 参数2：会话超时时间 // 参数3：连接超时时间 // 参数4：序列化方式 zkClient = new ZkClient(&quot;192.168.9.3:2181&quot;, 60000 * 30, 60000, new SerializableSerializer()); } @After // 释放资源 public void after() { zkClient.close(); } // 获取连接 public static void main(String[] args) { }} 9. ZK集群9.1 集群（cluster）​ 集群是指同一种软件服务的多个节点同时提供服务 ​ 集群解决了什么问题？ 单节点的并发访问的压力问题 单节点故障问题 9.2 集群架构 9.3 集群搭建 在~目录下新建三个文件夹 1mkdir zkdata1 zkdata2 zkdata3 建立myid文件 1touch zkdata1/myid zkdata2/myid zkdata3/myid 为每个zk指定id 123echo &quot;1&quot; &gt;&gt; zkdata1/myid echo &quot;2&quot; &gt;&gt; zkdata2/myid echo &quot;3&quot; &gt;&gt; zkdata3/myid 添加配置文件 12345678910111213vim zkdata1/zoo.cfgvim zkdata2/zoo.cfgvim zkdata3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/root/zkdata1clientPort=3001server.1=196.168.9.3:3002:3003server.2=192.158.9.3:4002:4003server.3=192.168.9.3:5002:5003 相关操作 12345678# 启动./bin/zkServer.sh start /root/zkdata1/zoo.cfg./bin/zkServer.sh start /root/zkdata2/zoo.cfg./bin/zkServer.sh start /root/zkdata3/zoo.cfg# 查看状态./bin/zkServer.sh status /root/zkdata1/zoo.cfg# 停止./bin/zkServer.sh stop /root/zkdata1/zoo.cfg","link":"/2022/01/30/zk%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"zk","slug":"zk","link":"/tags/zk/"}],"categories":[]}