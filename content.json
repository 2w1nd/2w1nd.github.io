{"pages":[{"title":"","text":"About Me​ 一个菜狗","link":"/about/index.html"}],"posts":[{"title":"dubbo从入门到实战","text":"1 互联网系统架构演变​ 随着互联网的发展，网站应用规模不断壮大，由此系统架构也在不断演变，下图是一张经典的演变过程图： 单一应用架构 ​ 优点：当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本 ​ 缺点：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护 ​ 此时：用于简化增删改查工作量的数据访问框架（ORM）是关键 垂直应用架构 ​ 优点：解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率 ​ 缺点：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。 ​ 此时：用于加速前端页面开发的Web框架（MVC）是关键 分布式应用架构（RPC） ​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心 ​ 此时：用于提高业务复用及整合的分布式服务框架（RPC）是关键 流动计算架构（SOA） ​ 随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架 ​ 此时，用于提高机器利用率**资源调度和治理中心(SOA)**是关键。 2 什么是Dubbo​ Dubbo是一个微服务开发框架，提供了RPC通信与微服务治理两大关键能力。它提供了远程过程调用的能力，使得远程调用像本地调用一样方便 ​ Dubbo提供的基础能力包括： 服务发现 流式通信 负载均衡 流量治理 集群容错 服务降级 … 3 Dubbo总体架构​ 以下是官网的一张图 节点 说明 Consumer 需要调用远程服务的服务消费方 Registry 注册中心 Provider 服务提供方 Container 服务运行的容器 Monitor 监控中心 ​ 通过上图，可以知道服务发现整体流程如下： 服务提供者Provider启动然后向注册中心注册自己所能提供的服务。 消费者Consumer启动向注册中心订阅所需的服务。 然后注册中心返回服务提供者地址列表给消费者Consumer，如果有变更，注册中心将基于长连接推送变更数据给消费者Consumer。 消费者Consumer就可以负载均衡选择一个Provier直接调用。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 4 快速入门​ 新建两个Maven项目，JDK版本1.8，Dubbo版本2.7，一个消费者，一个提供者 引入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;groupId&gt;com.tiza.leo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo_001_p&lt;/artifactId&gt; &lt;!--引入依赖--&gt; &lt;dependencies&gt; &lt;!-- core context beans spring三件套--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo 2.5.3--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper zkclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 提供端代码 UserService 12345678package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} UserServiceImpl 12345678910111213package com.w1nd.dubbo.service;public class UserServiceImpl implements UserService { public String findName(String name) { System.out.println(&quot;姓名:&quot; +name); return &quot;hello: &quot;+name; } public void addUser(String username) { System.out.println(&quot;添加用户,用户名为: &quot;+username); }} spring-dubbo.xml（重要） 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过duboo发布服务 --&gt; &lt;dubbo:application name=&quot;dubbo_001_p&quot;&gt;&lt;/dubbo:application&gt; &lt;!--将服务注册到指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--指定服务的协议 和 使用端口号 注意此处服务端使用客户端无需使用 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt; &lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--注册服务到注册中心--&gt; &lt;dubbo:service interface=&quot;com.w1nd.dubbo.service.UserService&quot; ref=&quot;userService&quot; timeout=&quot;4000&quot;&gt; &lt;!--定义超时时间方二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:service&gt; &lt;!--服务提供者--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.w1nd.dubbo.service.UserServiceImpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 测试代码 1234567891011121314151617package com.w1nd.dubbo.publish;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;import static org.junit.Assert.*;public class PublishServiceTest { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); System.out.println(&quot;服务提供者,开始提供服务.....&quot;); System.in.read(); }} 消费端代码 UserService 1234567package com.w1nd.dubbo.service;public interface UserService { public String findName(String name); public void addUser(String username);} spring-dubbo.xml（重要） 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress SpringFacetInspection --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--通过dubbo消费服务--&gt; &lt;dubbo:application name=&quot;dubbo_001_c&quot;/&gt; &lt;!--指定的注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;&gt;&lt;/dubbo:registry&gt; &lt;!--关闭所有服务的启动时检查 (没有提供者时报错)：--&gt; &lt;dubbo:consumer timeout=&quot;5000&quot; &gt;&lt;/dubbo:consumer&gt; &lt;!--定义超时时间方式一--&gt; &lt;!--调用服务--&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.w1nd.dubbo.service.UserService&quot; timeout=&quot;4000&quot; &gt; &lt;!--定义超时时间方式二--&gt; &lt;dubbo:method name=&quot;findName&quot; timeout=&quot;3000&quot;&gt;&lt;/dubbo:method&gt; &lt;!--定义超时时间方式三--&gt; &lt;/dubbo:reference&gt; &lt;/beans&gt; 测试代码 12345678910111213141516package com.w1nd.dubbo.invoke;import com.w1nd.dubbo.service.UserService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class InvokeServiceTest { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dubbo.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.addUser(&quot;w1nd&quot;); /* String serverReturn = userService.findName(&quot;GouSheng&quot;); System.out.println(&quot;get message from server message is &quot; + serverReturn);*/ }} 5 集群​ 不同消费者的使用端口号设置不一样，即可。 dubbo_cluster_001_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_002_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; dubbo_cluster_003_p 1&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20883&quot;&gt;&lt;/dubbo:protocol&gt; 参考(96条消息) 朋友国企干了5年java，居然不知道Dubbo是做什么呢？我真信了！_敖丙-CSDN博客 Dubbo3 简介 | Apache Dubbo","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/dubbo%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"},{"title":"zookeeper基本使用与集群搭建","text":"1. ZK简介​ 一个分布式的，开放源码的分布式应用程序协调服务。 2. ZK数据模型2.1 模型结构​ 2.2 模型的特点 每个子目录如/node1都被称作一个znode（节点）。这个znode是它所在的路径唯一标识 znode可以有子节点目录，并且每个znode可以存储数据 znode是有有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据 znode是可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端 3. 节点的分类3.1 持久节点（PERSISTENT）​ 指在节点创建后，就一直存在，知道有删除操作来主动删除这个节点–会因为创建该节点的客户端会话失效而消失 3.2 持久顺序节点（PERSISTENT_SEQUENTIAL）​ 这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 3.3 临时节点（EPHEMERAL）​ 和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 3.4 临时顺序节点（EPHEMERAL_SEQUENTIAL）​ 具有临时节点特点额外的特性是，每个父节点会为他的第一级子节点维护一份时序。这点和刚才提到的持久顺序节点类似 4. 安装4.1 linux系统安装 安装JDK 12tar -zxvf jdk-8u171-linux-x64.tar.gz mv ./jdk1.8.0_171/ /usr/java/ 12vim /etc/profilesource /etc/profile 安装ZK 1tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz 1cd conf/ 由于zk默认加载的是zoo.cfg，所以需要改名 1mv zoo_sample.cfg zoo.cfg 由于zookeeper加载要将节点加载到磁盘，所以需要预先新建一个磁盘目录 1mkdir /tmp/zookeeper 启动ZK 1234567[root@localhost bin]# ./zkServer.sh start /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfg ZooKeeper JMX enabled by defaultUsing config: /root/apache-zookeeper-3.6.3-bin/conf/zoo.cfgStarting zookeeper ... STARTED# 查看是否启动jps ​ QuorumPeerMain就是zk 连接ZK 1./zkCli.sh -server 192.168.9.3:2181 如果是本机，-server后可不加 5. 配置文件说明 tickTime：集群节点心跳时间， initLimit：初始化集群时集群节点同步超时时间20s syncLimit：集群在运行过程中，同步数据超时时间为10s（这里5是指5次心跳） dataDir：默认数据存储位置 clientPort：zk服务监听端口号 maxClientCnxns：线程池线程数量 6. 客户端基本指令 查看节点 1ls / # 根节点 创建节点 12345create path data # 创建一个节点，并给节点绑定数据（默认是持久性节点）- create path data # 持久节点- create -s path data # 持久性顺序节点- create -e path data # 临时性节点- create -e -s path data # 临时顺序节点 quit：会直接导致会话断开，会话失效，其他ctrl+c会导致触发倒计时 注：临时节点上不能创建任何节点 查看节点状态 1stat /node1 cZxid：创建事务ID ctime：创建时间 mZxid：修改ID mtime：修改时间 pZxid：父结点版本号 cversion：创建版本号 dataVersion：数据版本号 aclVersion： ephemerslOwner：是否是临时节点 dataLength：存储数据长度 numChildren：子节点数量 获得节点上绑定的数据信息 1get /node1 删除节点 1delete /node1 只能删除没有子节点的节点，如果有子节点，则无法删除 若想删除有子节点的，则需要deleteall 7. watch节点监听机制监听分为节点目录监听和节点数据监听 目录监听是监听节点目录的变化 数据监听是监听当前节点数据的变化 两种监听都是一次性的，也就是发现一个修改，下次修改则不会触发监听机制 目录监听 1ls -w /node 再次创建，无触发 数据监听 1get -w /node 8. Java操作ZK123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.w1nd.test;import org.I0Itec.zkclient.IZkChildListener;import org.I0Itec.zkclient.IZkDataListener;import org.I0Itec.zkclient.ZkClient;import org.I0Itec.zkclient.serialize.SerializableSerializer;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.data.Stat;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.List;public class TestZKClient { private ZkClient zkClient; // 1. 在zk创建节点 @Test public void testCreateNode() { // 1. 持久节点 zkClient.create(&quot;/node1&quot;, &quot;xiaochen&quot;, CreateMode.PERSISTENT); // 2. 持久顺序节点 zkClient.create(&quot;/node1/names&quot;, &quot;zhangsan&quot;, CreateMode.PERSISTENT_SEQUENTIAL); // 3. 临时节点 zkClient.create(&quot;/node1/lists&quot;, &quot;xiaoxiao&quot;, CreateMode.EPHEMERAL); // 4. 临时顺序节点 zkClient.create(&quot;/node1/lists1&quot;, &quot;xiaoming&quot;, CreateMode.EPHEMERAL_SEQUENTIAL); } // 2. 删除节点 @Test public void testDeleteNode() { // 删除没有子节点的节点，返回值：是否成功 boolean delete = zkClient.delete(&quot;/node1&quot;); // 递归删除节点信息，返回值：是否删除成功 boolean b = zkClient.deleteRecursive(&quot;/node1&quot;); } // 3. 查询当前节点下所有子节点 @Test public void testFindNodes() { // 获取指定路径的节点信息 List&lt;String&gt; children = zkClient.getChildren(&quot;/&quot;); for (String child : children) { System.out.println(child); } } // 4. 查看某个节点数据，注意：通过java客户端操作需要保证节点存储的数据和节点时序列化方式一致 // shell中的数据序列化方式和java中的不一致 @Test public void testFindNodeData() { Object readData = zkClient.readData(&quot;/node3&quot;); System.out.println(readData); } // 5. 查看节点状态信息 @Test public void testFindNodeDataAndStat() { Stat stat = new Stat(); Object readData = zkClient.readData(&quot;/node1&quot;, stat); System.out.println(readData); System.out.println(stat); } // 6. 修改节点数据 @Test public void testWriteData() { // User user = new User(); // user.setId(1); // zkClient.writeData(&quot;/node1&quot;, user); } // 监听节点数据的变化 @Test public void testOnNodeDataChange() throws IOException { zkClient.subscribeDataChanges(&quot;/node1&quot;, new IZkDataListener() { // 当节点数据变化时触发对应这个方法 @Override public void handleDataChange(String s, Object o) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); System.out.println(&quot;当前节点变化后数据：&quot; + o); } // 当前节点删除时触发这个方法 @Override public void handleDataDeleted(String s) throws Exception { System.out.println(&quot;当前节点路径：&quot; + s); } }); System.in.read(); // 阻塞当前监听 } // 监听节点目录的变化 @Test public void testOnNodesChange() throws IOException { zkClient.subscribeChildChanges(&quot;/node1&quot;, new IZkChildListener() { // 当节点的发生变化时，会自动调用这个方法 // 参数1：父节点名称 // 参数2：父节点中的所有子节点名称 @Override public void handleChildChange(String s, List&lt;String&gt; list) throws Exception { System.out.println(&quot;父节点名称：&quot; + s); System.out.println(&quot;发生变更后孩子节点名称：&quot;); for (String name: list) { System.out.println(name); } } }); System.in.read(); // 阻塞当前监听 } @Before public void before() { // 参数1：Server服务器ip地址 // 参数2：会话超时时间 // 参数3：连接超时时间 // 参数4：序列化方式 zkClient = new ZkClient(&quot;192.168.9.3:2181&quot;, 60000 * 30, 60000, new SerializableSerializer()); } @After // 释放资源 public void after() { zkClient.close(); } // 获取连接 public static void main(String[] args) { }} 9. ZK集群9.1 集群（cluster）​ 集群是指同一种软件服务的多个节点同时提供服务 ​ 集群解决了什么问题？ 单节点的并发访问的压力问题 单节点故障问题 9.2 集群架构 9.3 集群搭建 在~目录下新建三个文件夹 1mkdir zkdata1 zkdata2 zkdata3 建立myid文件 1touch zkdata1/myid zkdata2/myid zkdata3/myid 为每个zk指定id 123echo &quot;1&quot; &gt;&gt; zkdata1/myid echo &quot;2&quot; &gt;&gt; zkdata2/myid echo &quot;3&quot; &gt;&gt; zkdata3/myid 添加配置文件 12345678910111213vim zkdata1/zoo.cfgvim zkdata2/zoo.cfgvim zkdata3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/root/zkdata1clientPort=3001server.1=196.168.9.3:3002:3003server.2=192.158.9.3:4002:4003server.3=192.168.9.3:5002:5003 相关操作 12345678# 启动./bin/zkServer.sh start /root/zkdata1/zoo.cfg./bin/zkServer.sh start /root/zkdata2/zoo.cfg./bin/zkServer.sh start /root/zkdata3/zoo.cfg# 查看状态./bin/zkServer.sh status /root/zkdata1/zoo.cfg# 停止./bin/zkServer.sh stop /root/zkdata1/zoo.cfg","link":"/2022/02/04/%E6%A1%86%E6%9E%B6/zookeeper%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"前缀和","text":"525. 连续数组 1234567891011121314151617181920class Solution {public: int findMaxLength(vector&lt;int&gt;&amp; nums) { /* 由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 cur 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 curcur 值即可 */ unordered_map&lt;int, int&gt; hash{{0, -1}}; int cur = 0, ans = 0; for (int i = 0; i &lt; nums.size(); i ++) { cur += nums[i] == 0 ? -1 : 1; if (hash.count(cur)) { ans = max(ans, i - hash[cur]); } else { hash[cur] = i; } } return ans; }}; 剑指 Offer II 010. 和为 k 的子数组 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"位运算","text":"剑指 Offer II 004. 只出现一次的数字刷穿剑指offer-Day02-整数II 004.只出现一次的数字 位运算讲解 - 只出现一次的数字 12345678910111213141516class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int ret = 0; for (int i = 0; i &lt; 32; i ++) { int cnt = 0; for (auto num: nums) { cnt += num &gt;&gt; i &amp; 1; } if (cnt % 3 != 0) { ret |= 1 &lt;&lt; i; } } return ret; }}; 剑指 Offer II 005. 单词长度的最大乘积123456789101112131415161718192021222324class Solution {public: int maxProduct(vector&lt;string&gt;&amp; words) { int n = words.size(); vector&lt;int&gt; dict(n, 0); for (int i = 0; i &lt; words.size(); i ++) { int t = 0; for (auto c: words[i]) { int bit = c - 'a'; t |= (1 &lt;&lt; bit); } dict[i] = t; } int ans = 0; for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; i; j ++) if ((dict[i] &amp; dict[j]) == 0) { int temp = words[i].size() * words[j].size(); ans = max(ans, temp); } return ans; } };","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"区间DP","text":"87. 扰乱字符串1234567891011121314151617181920212223242526272829class Solution {public: bool isScramble(string s1, string s2) { int n = s1.size(); if (s1 == s2) return true; if (s1.size() != s2.size()) return false; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, false))); // 处理长度为1的情况 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; n; j ++) if (s1[i] == s2[j]) f[i][j][1] = true; // f[i][j][len] 代表 s1s1 从 ii 开始，s2s2 从 jj 开始，后面长度为 lenlen 的字符是否能形成「扰乱字符串」（互为翻转）。 for (int len = 2; len &lt;= n; len ++) for (int i = 0; i &lt;= n - len; i ++) for (int j = 0; j &lt;= n - len; j ++) for (int k = 1; k &lt; len; k ++) { // 分割点 // a : 0 - i, b : 0 - j ; a: i - n, j - n bool a = f[i][j][k] &amp;&amp; f[i + k][j + k][len - k]; // a : 0 - i, b : n - i, n ; a: i - n, 0 - j bool b = f[i][j + len - k][k] &amp;&amp; f[i + k][j][len - k]; if (a || b) { f[i][j][len] = true; } } return f[0][0][n]; }}; 375. 猜数字大小 II1234567891011121314151617181920class Solution {public: int getMoneyAmount(int n) { //定义 f[l][r]f[l][r] 为考虑在 [l, r][l,r] 范围内进行猜数的最小成本。 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); // 需要找到能猜中数字的最小成本，也就是最坏情况最好的结果 // 对于任一区间取min是因为我们在该区间可以先选择小的数去试，由此降低成本 for (int len = 2; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; f[l][r] = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cur = max(f[l][x - 1], f[x + 1][r]) + x; f[l][r] = min(f[l][r], cur); } } return f[1][n]; }}; 516. 最长回文子序列123456789101112131415161718192021222324252627282930313233class Solution {public: /* bb aa bb bb a bb dp[i][j] 表示 第 i 个字符到 第 j 个字符之间最长的回文子序列长度 1、当 s[i] == s[j] 时，考虑 i 和 j 中间序列的奇偶个数， dp[i][j] = dp[i+1][j-1] + 2 对上述 dp[i][j] = dp[i+1][j-1] + 2 的解释： 当序列为 b aa b 时， i = 0, j = 3，则 dp[0][3] = dp[1][2] + 2 = 4 当序列为 b a b 时，i = 0, j = 2，则 dp[0][2] = dp[1][1] + 2 = 3 当序列为 b b 时， i = 0, j = 1，则 dp[0][1] = dp[1][0] = 0 + 2 = 2 (dp[1][0] 默认值为 0) 该式子同时考虑到了奇偶 2、当 s[i] != s[j] ，那么 dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]) 对上述 dp[i][j] 式子的解释： 假如序列为 d c b c c（index：0-4），s[0] != s[4] ，则 dp[0][4] = Math.max(dp[0][3],dp[1,4]) = Math.max(2,3) = 3 */ int longestPalindromeSubseq(string s) { int n = s.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i + 1][j - 1] + 2; } else { f[i][j] = max(f[i + 1][j], f[i][j - 1]); } } } return f[0][n - 1]; }}; 664. 奇怪的打印机123456789101112131415161718192021class Solution {public: int strangePrinter(string s) { int n = s.size(); // f[i][j] 表示 区间[i,j]的最小打印次数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for (int i = n - 1; i &gt;= 0; i --) { f[i][i] = 1; for (int j = i + 1; j &lt; n; j ++) { if (s[i] == s[j]) { f[i][j] = f[i][j - 1]; } else { for (int k = i; k &lt; j; k ++) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } } return f[0][n - 1]; }}; 877. 石子游戏1234567891011121314151617class Solution {public: bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); // 定义 f[l][r]f[l][r] 为考虑区间 [l,r][l,r]，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少 vector&lt;vector&lt;int&gt;&gt; f(n + 2, vector&lt;int&gt;(n + 2, 0)); for (int len = 1; len &lt;= n; len ++) for (int l = 1; l + len - 1 &lt;= n; l ++) { int r = l + len - 1; int a = piles[l - 1] + f[l + 1][r]; int b = piles[r - 1] + f[l][r - 1]; f[l][r] = max(a, b); } return f[1][n] &gt; 0; }};","link":"/2022/02/02/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4DP/"},{"title":"双指针","text":"剑指 Offer II 008. 和大于等于 target 的最短子数组123456789101112class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(), sum = 0, res = INT_MAX; for (int i = 0, j = 0; i &lt; n; i ++) { sum += nums[i]; while (sum - nums[j] &gt;= target) sum -= nums[j ++]; if (sum &gt;= target) res = min(res, i - j + 1); } return res == INT_MAX ? 0 : res; }}; 剑指 Offer II 009. 乘积小于 K 的子数组 1234567891011121314class Solution {public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) { //已知ABC &lt; target, 新增一位X变成ABCX, 若ABCX &lt; target 则新增的subarray中必须满足 1.连续 2.包含X //所以从X向左数: X, CX, BCX, ABCX int n = nums.size(), product = 1, res = 0; for (int i = 0, j = 0; i &lt; n; i ++ ) { product *= nums[i]; while (i &gt;= j &amp;&amp; product &gt;= k) product /= nums[j ++]; res += i - j + 1; } return res; }}; 剑指 Offer II 010. 和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com) 123456789101112131415161718class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; s(n + 1, 0); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + nums[i - 1]; hash[0] = 1; int res = 0; // 类似双指针，哈希表存储的每个前缀和对应的个数，由于hash[0] = 1， // 它一定会转移到前嘴和-k为0的的位置，后面在确定其他前嘴和-当前前嘴和是否能被首前嘴和转移 for (int i = 1; i &lt;= n; i ++) { res += hash[s[i] - k]; hash[s[i]] ++; } return res; }}; 剑指 Offer II 014. 字符串中的变位词 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617class Solution {public: bool checkInclusion(string s1, string s2) { map&lt;char, int&gt; hash; // 存储子串各个字符数量 for (auto c: s1) hash[c] ++; int tot = hash.size(), statify = 0; // tot是字符总数，statify是s2中满足要求的数量 for (int i = 0, j = 0; i &lt; s2.size(); i ++) { if (--hash[s2[i]] == 0) statify ++; while (i - j + 1 &gt; s1.size()) { // 窗口大小小于s1.size if (hash[s2[j]] == 0) statify --; hash[s2[j ++]] ++; } if (statify == tot) return true; } return false; }}; 剑指 Offer II 017. 含有所有字符的最短字符串 - 力扣（LeetCode） (leetcode-cn.com) 1234567891011121314151617181920class Solution {public: string minWindow(string s, string t) { map&lt;char, int&gt; hash; for (auto c: t) hash[c] ++; int tot = hash.size(), statify = 0; string res; for (int i = 0, j = 0; i &lt; s.size(); i ++) { if (hash[s[i]] == 1) statify ++; hash[s[i]] --; while (hash[s[j]] &lt; 0) hash[s[j ++]] ++; // 注意这里是&lt;，所以不会出现后续的不符合要求的字符顶去前面的，例如BANC，N的出现不会将B删去 if (statify == tot) { if (res.empty() || res.size() &gt; i - j + 1) { res = s.substr(j, i - j + 1); } } } return res; }};","link":"/2022/02/04/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"状压DP","text":"526. 优美的排列123456789101112131415161718class Solution {public: int countArrangement(int n) { int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(mask, 0)); f[0][0] = 1; // 考虑前i个数，状态为0的方案数（优美排列数量） for (int i = 1; i &lt;= n; i ++) // 枚举当前位置 for (int state = 1; state &lt;= mask; state ++) // 枚举当前状态，0为选该数，1为不选 for (int k = 1; k &lt;= n; k ++) { // 枚举当前位置填了什么数 if (!((state &gt;&gt; (k - 1)) &amp; 1)) continue; // 如果当前数在状态中为0，则跳过 if (k % i &amp;&amp; i % k) continue; // 不满足任何整除关系 // state &amp; (~(1 &lt;&lt; (k - 1))) 代表将 state 中数值 k 的位置置零 f[i][state] += f[i - 1][state &amp; ~(1 &lt;&lt; (k - 1))]; } return f[n][mask - 1]; }}; 847. 访问所有节点的最短路径1234567891011121314151617181920212223242526class Solution {public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); int mask = 1 &lt;&lt; n; vector&lt;vector&lt;int&gt;&gt; dist(mask, vector&lt;int&gt;(n + 1, INT_MAX)); // state和u(该状态下的最后一步)对应的步数 deque&lt;vector&lt;int&gt;&gt; d; // 存储state 和 u for (int i = 0; i &lt; n; i ++) { dist[1 &lt;&lt; i][i] = 0; d.push_back({1 &lt;&lt; i, i}); } while (!d.empty()) { auto poll = d.front(); d.pop_front(); int state = poll[0], u = poll[1], step = dist[state][u]; if (state == mask - 1) return step; for (int i: graph[u]) { if (dist[state | (1 &lt;&lt; i)][i] == INT_MAX) { dist[state | (1 &lt;&lt; i)][i] = step + 1; d.push_back({state | (1 &lt;&lt; i), i}); } } } return -1; }};","link":"/2022/02/03/%E7%AE%97%E6%B3%95/%E7%8A%B6%E5%8E%8BDP/"},{"title":"背包DP","text":"279. 完全平方数 12345678910111213class Solution {public: int numSquares(int n) { // dp[i] 表示 能凑出i的完全平方数的最小数量 vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i ++) { dp[i] = i; for (int j = 1; i - j * j &gt;= 0; j ++) dp[i] = min(dp[i], dp[i - j * j] + 1); } return dp[n]; }}; 322. 零钱兑换 12345678910111213class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 1e9); dp[0] = 0; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) dp[j] = min(dp[j], dp[j - coins[i]] + 1); if (dp[amount] == 1e9) return -1; return dp[amount]; }}; 416. 分割等和子集 12345678910111213141516class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = 0; for (auto &amp;x: nums) sum += x; int target = sum / 2; if (target * 2 != sum) return false; vector&lt;int&gt; dp(target + 1, 0); // dp[i] 表示 凑出 i 所需的价值数 for (auto &amp;x: nums) for (int j = target; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } return dp[target] == target; }}; 474. 一和零 12345678910111213141516171819202122232425class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int len = strs.size(); vector&lt;vector&lt;int&gt;&gt; cnt(len, vector&lt;int&gt;(2, 0)); for (int i = 0; i &lt; len; i ++) { int zero = 0, one = 0; for (auto &amp;c: strs[i]) { if (c == '1') one ++; else zero ++; } cnt[i][0] = zero, cnt[i][1] = one; } vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int k = 0; k &lt; len; k ++) { int zero = cnt[k][0], one = cnt[k][1]; for (int i = m; i &gt;= zero; i --) for (int j = n; j &gt;= one; j --) { f[i][j] = max(f[i][j], f[i - zero][j - one] + 1); } } return f[m][n]; }}; 494. 目标和 1234567891011121314151617181920class Solution {public: const int Offset = 1000; int findTargetSumWays(vector&lt;int&gt;&amp; a, int t) { int n = a.size(); int s = 0; for (int i: a) s += abs(i); if (abs(t) &gt; s) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2 * s + 1, 0)); dp[0][s] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = -s; j &lt;= s; j ++) { if (j - a[i - 1] &gt;= -s) dp[i][j + s] += dp[i - 1][j - a[i - 1] + s]; if (j + a[i - 1] &lt;= s) dp[i][j + s] += dp[i - 1][j + a[i - 1] + s]; } return dp[n][t + s]; }}; 518. 零钱兑换 II 1234567891011121314class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { // dp[i][j] 表示 考虑前i个物品，凑出 j 的方案数 int n = coins.size(); vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; n; i ++) for (int j = coins[i]; j &lt;= amount; j ++) { dp[j] += dp[j - coins[i]]; } return dp[amount]; }}; 879. 盈利计划 12345678910111213141516171819class Solution {public: const int MOD = 1e9 + 7; // dp[i][j][k] 表示 前i个个物品，人数不超过j，利润至少为k的方案数 int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) { int m = group.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(minProfit + 1, 0)); for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= m; i ++) { int a = group[i - 1], b = profit[i - 1]; for (int j = n; j &gt;= a; j --) for (int k = minProfit; k &gt;= 0; k --) { dp[j][k] += dp[j - a][max(k - b, 0)]; dp[j][k] %= MOD; } } return dp[n][minProfit]; }}; 1049. 最后一块石头的重量 II 未优化空间 问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值进一步分析：要让差值小,两堆石头的重量都要接近sum/2;我们假设两堆分别为A,B,A&lt;sum/2,B&gt;sum/2,若A更接近sum/2,B也相应更接近sum/2进一步转化：将一堆stone放进最大容量为sum/2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;、 123456789101112131415161718// d[i][j]代表考虑前 i 个物品（数值），凑成总和不超过 j 的最大价值。class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(t + 1, 0)); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = 0; j &lt;= t; j ++) { dp[i][j] = dp[i - 1][j]; if (j &gt;= x) dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + x); } } return sum - 2 * dp[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { int sum = 0, n = stones.size(); for (auto x: stones) sum += x; int t = sum / 2; vector&lt;int&gt; dp(t + 1, 0); for (int i = 1; i &lt;= n; i ++) { int x = stones[i - 1]; for (int j = t; j &gt;= x; j --) { dp[j] = max(dp[j], dp[j - x] + x); } } return sum - 2 * dp[t]; }}; 1155. 掷骰子的N种方法 未优化空间 1234567891011121314class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(t + 1, 0)); f[0][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 0; j &lt;= t; j ++) for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[i][j] = (f[i][j] + f[i - 1][j - k]) % MOD; } return f[n][t]; }}; 优化空间 12345678910111213141516class Solution {public: const int MOD = 1e9 + 7; int numRollsToTarget(int n, int m, int t) { vector&lt;int&gt; f(t + 1, 0); f[0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = t; j &gt;= 0; j --) { f[j] = 0; //由于我们直接是在 f[i][j]f[i][j] 格子的基础上进行方案数累加，因此在计算 f[i][j]f[i][j] 记得手动置零。 for (int k = 1; k &lt;= m; k ++) { if(j &gt;= k) f[j] = (f[j] + f[j - k]) % MOD; } } return f[t]; }}; 1449. 数位成本和为目标值的最大数字 1234567891011121314151617181920212223242526class Solution {public: // dp[i][j] 表示 考虑前i个物品，总成本为j的最大整数长度 string largestNumber(vector&lt;int&gt;&amp; cost, int t) { int n = cost.size(); vector&lt;int&gt; dp(t + 1, INT_MIN); dp[0] = 0; for (int i = 1; i &lt;= n; i ++) { int x = cost[i - 1]; for (int j = x; j &lt;= t; j ++) { dp[j] = max(dp[j], dp[j - x] + 1); } } if (dp[t] &lt; 0) return &quot;0&quot;; string res = &quot;&quot;; for (int i = 9, j = t; i &gt;= 1; i --) { int x = cost[i - 1]; while (j &gt;= x &amp;&amp; dp[j] == dp[j - x] + 1) { res += to_string(i); j -= x; } } return res; }}; 1995. 统计特殊四元组 123456789101112131415161718192021class Solution {public: int countQuadruplets(vector&lt;int&gt;&amp; nums) { // dp[i][j][k] 考虑前i个数，恰好凑出j，使用个数为k的方案数 int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(110, vector&lt;int&gt;(4, 0))); f[0][0][0] = 1; for (int i = 1; i &lt;= n; i ++) { int x = nums[i - 1]; for (int j = 0; j &lt; 110; j ++) for (int k = 0; k &lt; 4; k ++) { f[i][j][k] += f[i - 1][j][k]; if (j &gt;= x &amp;&amp; k &gt;= 1) f[i][j][k] += f[i - 1][j - x][k - 1]; } } int res = 0; for (int i = 3; i &lt; n; i ++) res += f[i][nums[i]][3]; return res; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85DP/"},{"title":"记忆化搜索","text":"87. 扰乱字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int Y = 1, N = -1; string s1, s2; bool isScramble(string _s1, string _s2) { s1 = _s1, s2 = _s2; if (s1 == s2) return true; if (s1.size() != s2.size()) return false; int n = s1.size(); // cache表示s1从i开始，s2从j开始 len 位，是否形成扰动字符串 cache.resize(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0))); return dfs(0, 0, n); } bool dfs(int i, int j, int len) { if (cache[i][j][len] != 0) return cache[i][j][len] == Y; string a = s1.substr(i, len), b = s2.substr(j, len); if (a == b){ cache[i][j][len] = Y; return true; } if (!check(a, b)) { cache[i][j][len] = N; return false; } for (int k = 1; k &lt; len; k ++) { if (dfs(i, j, k) &amp;&amp; dfs(i + k, j + k, len - k)) { cache[i][j][len] = Y; return true; } if (dfs(i, len - k + j, k) &amp;&amp; dfs(i + k, j, len - k)) { cache[i][j][len] = Y; return true; } } cache[i][j][len] = N; return false; } bool check(string a, string b) { if (a.size() != b.size()) return false; vector&lt;int&gt; cnt1(26, 0), cnt2(26, 0); for (auto c: s1) { cnt1[c - 'a'] ++; } for (auto c: s2) { cnt2[c - 'a'] ++; } return cnt1 == cnt2; }}; 375. 猜数字大小 II12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; int getMoneyAmount(int n) { cache.resize(n + 1, vector&lt;int&gt;(n + 1, 0)); return dfs(1, n); } int dfs(int l, int r) { if (l &gt;= r) return 0; if (cache[l][r] != 0) return cache[l][r]; int ans = 0x3f3f3f3f; for (int x = l; x &lt;= r; x ++) { int cnt = max(dfs(l, x - 1), dfs(x + 1, r)) + x; ans = min(ans, cnt); } cache[l][r] = ans; return ans; }}; 403. 青蛙过河1234567891011121314151617181920212223242526272829303132class Solution {public: unordered_map&lt;string, bool&gt; cache; // 存储u下标跳k步有没有方案 unordered_map&lt;int, int&gt; map; // 存储每个石块对应的下标 bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); for (int i = 0; i &lt; n; i ++) { map.insert({stones[i], i}); } if (!map.count(1)) return false; return dfs(stones, n, 1, 1); } bool dfs(vector&lt;int&gt; &amp;stones, int n, int u, int k) { if (u == n - 1) return true; string key = to_string(u) + '_' + to_string(k); if (cache.count(key)) return cache[key]; for (int i = -1; i &lt;= 1; i ++) { if (k + i == 0) continue; int next = stones[u] + i + k; // 下一个跳跃点 if (map.count(next)) { bool cur = dfs(stones, n, map[next], k + i); cache.insert({key, cur}); if (cur) return true; } } cache.insert({key, false}); return false; }}; 494. 目标和12345678910111213141516171819202122class Solution {public: unordered_map&lt;string, int&gt; cache; // 表示从u下标,当前计算结果为string，的方案数int int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { return dfs(nums, target, 0, 0); } int dfs(vector&lt;int&gt; &amp;nums, int target, int u, int cur) { string key = to_string(u) + '_' + to_string(cur); if (cache.count(key)) return cache[key]; if (u == nums.size()) { cache.insert({key, cur == target ? 1: 0}); return cache[key]; } int left = dfs(nums, target, u + 1, cur - nums[u]); int right = dfs(nums, target, u + 1, cur + nums[u]); cache.insert({key, left + right}); return cache[key]; }}; 552. 学生出勤记录 II1234567891011121314151617181920212223class Solution {public: // cache 是指 下标为u，连续a个数为acnt，l个数为lcnt的方案数 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int mod = (int)1e9 + 7; int checkRecord(int n) { cache.resize(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3, -1))); return dfs(n, 0, 0); } int dfs(int u, int acnt, int lcnt) { if (acnt &gt;= 2) return 0; if (lcnt &gt;= 3) return 0; if (u == 0) return 1; if (cache[u][acnt][lcnt] != -1) return cache[u][acnt][lcnt]; int ans = 0; ans = dfs(u - 1, acnt + 1, 0) % mod; // A ans = (ans + dfs(u - 1, acnt, lcnt + 1)) % mod; // L ans = (ans + dfs(u - 1, acnt, 0)) % mod; // P cache[u][acnt][lcnt] = ans; return ans; }}; 576. 出界的路径数12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache; int MOD = (int) 1e9 + 7; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { cache.resize(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, -1))); return dfs(m, n, maxMove, startRow, startColumn); } int dfs(int m, int n, int u, int x, int y) { if (x &gt;= m || x &lt; 0) return 1; if (y &gt;= n || y &lt; 0) return 1; if (u == 0) return 0; if (cache[u][x][y] != -1) return cache[u][x][y]; int ans = 0; ans = dfs(m, n, u - 1, x + 1, y) % MOD; ans = (ans + dfs(m, n, u - 1, x, y + 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x, y - 1)) % MOD; ans = (ans + dfs(m, n, u - 1, x - 1, y)) % MOD; cache[u][x][y] = ans; return ans; }}; 1137. 第 N 个泰波那契数12345678910111213class Solution {public: int cache[40]; int tribonacci(int n) { if (n == 0) return 0; if (n == 1 || n == 2) return 1; if (cache[n] != 0) return cache[n]; cache[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3); return cache[n]; }}; 剑指 Offer 10- I. 斐波那契数列1234567891011121314class Solution {public: int mod = (int) 1e9 + 7; int cache[110]; int fib(int n) { if (n &lt;= 1) return n; if (cache[n] != 0) return cache[n]; cache[n] = fib(n - 1) + fib(n - 2); cache[n] %= mod; return cache[n]; }}; 638. 大礼包 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;int&gt; price; vector&lt;vector&lt;int&gt;&gt; special; vector&lt;int&gt; needs; map&lt;vector&lt;int&gt;, int&gt; cache; int shoppingOffers(vector&lt;int&gt;&amp; _price, vector&lt;vector&lt;int&gt;&gt;&amp; _special, vector&lt;int&gt;&amp; _needs) { price = _price; special = _special; needs = _needs; return dfs(needs); } int dfs(vector&lt;int&gt; needs) { if (cache.count(needs)) { return cache[needs]; } int n = needs.size(); int minN = 0; for (int i = 0; i &lt; n; i ++) { minN += price[i] * needs[i]; } for (int i = 0; i &lt; special.size(); i ++) { bool flag = true; vector&lt;int&gt; nextNeeds = needs; for (int j = 0; j &lt; n; j ++) { if (special[i][j] &gt; nextNeeds[j]) flag = false; nextNeeds[j] -= special[i][j]; } if (!flag) continue; minN = min(minN, dfs(nextNeeds) + special[i][n]); } return cache[needs] = minN; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"title":"序列DP","text":"334. 递增的三元子序列 12345678910111213141516class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int small = INT_MAX, big = INT_MAX; for (int x: nums) { if (x &lt;= small) { small = x; } else if (x &lt;= big) { big = x; } else { return true; } } return false; }}; 1234567891011121314151617181920class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1, INT_MAX); // f[len] = x 表示 以 长度为 len 的序列的最小尾元素为x int ans = 1; for (int i = 0; i &lt; n; i ++) { int l = 1, r = i + 1; int x = nums[i]; while (l &lt; r) { // 二分查找小于nums[i]的最小元素 int mid = l + r &gt;&gt; 1; if (f[mid] &gt;= x) r = mid; else l = mid + 1; } f[r] = x; ans = max(ans, r); } return ans &gt;= 3; }}; 354. 俄罗斯套娃信封问题 123456789101112131415161718class Solution {public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) { int n = envelopes.size(); vector&lt;int&gt; f(n, 0); // 以 i 结尾的最大信封 sort(envelopes.begin(), envelopes.end()); int res = 0; for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) { if (envelopes[i][0] &gt; envelopes[j][0] &amp;&amp; envelopes[i][1] &gt; envelopes[j][1]) f[i] = max(f[i], f[j] + 1); } res = max(res, f[i]); } return res; }}; 368. 最大整除子集 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n, 0); // f[i] 表示 前i个数中以a[i]结尾的整除子集的最长序列的元素个数 sort(nums.begin(), nums.end()); int k = 0; // 整除序列最后一个元素下标 for (int i = 0; i &lt; n; i ++) { f[i] = 1; for (int j = 0; j &lt; i; j ++) if (nums[i] % nums[j] == 0) f[i] = max(f[i], f[j] + 1); if (f[k] &lt; f[i]) k = i; } vector&lt;int&gt; res; // 逆推得出答案 while (true) { res.push_back(nums[k]); if (f[k] == 1) break; // 只剩一个元素 for (int i = 0; i &lt; k; i ++) { if ((nums[k] % nums[i] == 0) &amp;&amp; f[k] == f[i] + 1) { k = i; break; } } } return res; }}; 390. 消除游戏 1234567class Solution {public: int lastRemaining(int n) { if (n == 1) return 1; return 2 * (n / 2 + 1 - lastRemaining(n / 2)); }}; 446. 等差数列划分 II - 子序列 LeetCode 446. 等差数列划分 II - 子序列 - AcWing 12345678910111213141516171819202122class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; a) { typedef long long LL; int n = a.size(); // 由于每个数可能都会在不同等差数列中，需要用哈希表来存 vector&lt;unordered_map&lt;LL, int&gt;&gt; f(n); // f[i][j] 表示 考虑以第 i 个数结尾 公差为j的等差数列的个数 int res = 0; for (int i = 0; i &lt; n; i ++) for (int k = 0; k &lt; i; k ++) { LL j = (LL)a[i] - a[k]; auto it = f[k].find(j); // 查找a[k]结尾公差为j的等差数列的个数 int t = 0; if (it != f[k].end()) { t = it-&gt;second; res += t; } f[i][j] += t + 1; } return res; }}; 472. 连接词 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: typedef unsigned long long ULL; unordered_set&lt;ULL&gt; hash; const int P = 131; vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) { // 初始化字符串哈希表 for (auto &amp;s: words) { ULL t = 0; for (auto &amp;c: s) { t = t * P + c; } hash.insert(t); } vector&lt;string&gt; res; for (auto &amp;s: words) if (check(s)) res.push_back(s); return res; } bool check(string str) { int n = str.size(); vector&lt;int&gt; f(n + 1, -1); // f[i] 表示 在i前面的连接词的个数 f[0] = 0; for (int i = 0; i &lt;= n; i ++) { if (f[i]== -1) continue; ULL cur = 0; for (int j = i + 1; j &lt;= n; j ++) { cur = cur * P + str[j - 1]; if (hash.count(cur)) { f[j] = max(f[j], f[i] + 1); } } if (f[n] &gt;= 2) return true; } return false; }}; 583. 两个字符串的删除操作 123456789101112131415161718class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 0; i &lt;= n; i ++) f[i][0] = 1; for (int j = 0; j &lt;= m; j ++) f[0][j] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i][j - 1], f[i - 1][j]); if (word1[i - 1] == word2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } int maxn = f[n][m] - 1; return n + m - 2 * maxn; }}; 629. K个逆序对数组 LeetCode 629. K个逆序对数组 - AcWing 123456789101112131415161718class Solution {public: const int MOD = 1e9 + 7; int kInversePairs(int n, int k) { // f[i][j] 表示 所有由数字 1 ~ i 组成的含有 j 个 逆序对的数组个数 vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1, 0)); f[1][0] = 1; for (int i = 2; i &lt;= n; i ++) { long long s = 0; for (int j = 0; j &lt;= k; j ++) { s += f[i - 1][j]; if (j &gt;= i) s -= f[i - 1][j - i]; f[i][j] = s % MOD; } } return (f[n][k] + MOD) % MOD; } }; 673. 最长递增子序列的个数 123456789101112131415161718192021class Solution {public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n), g(n); // f 表示 以i结尾的最长上升子序列长度，g 表示 以 i 结尾的最长上升子序列的个数 int maxl = 0, cnt = 0; // maxl是最长子序列长度，cnt是子序列个数 for (int i = 0; i &lt; n; i ++) { f[i] = g[i] = 1; for (int j = 0; j &lt; i; j ++) { if (nums[j] &lt; nums[i]) { if (f[i] &lt; f[j] + 1) f[i] = f[j] + 1, g[i] = g[j]; else if (f[i] == f[j] + 1) g[i] += g[j]; } } if (maxl &lt; f[i]) maxl = f[i], cnt = g[i]; else if (maxl == f[i]) cnt += g[i]; } return cnt; }}; 689. 三个无重叠子数组的最大和 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;int&gt; s(n, 0); int sum = 0; for (int i = 0; i &lt; n; i ++) { sum += nums[i]; if (i &gt;= k) sum -= nums[i - k]; if (i &gt;= k - 1) s[i - k + 1] = sum; } vector&lt;int&gt; left(n, 0), right(n, 0); int maxIndex = 0; for (int i = 0; i &lt; n; i ++) { if (s[maxIndex] &lt; s[i]) maxIndex = i; left[i] = maxIndex; } maxIndex = n - 1; for (int i = n - 1; i &gt;= 0; i --) { if (s[maxIndex] &lt;= s[i]) maxIndex = i; right[i] = maxIndex; } vector&lt;int&gt; res(3, -1); for (int i = k; i &lt; n - k; i ++) { if (res[0] == -1 || s[res[0]] + s[res[1]] + s[res[2]] &lt; s[i] + s[left[i - k]] + s[right[i + k]]) { res[0] = left[i - k]; res[1] = i; res[2] = right[i + k]; } } return res; }}; 740. 删除并获得点数 1234567891011121314151617181920class Solution {public: const int N = 1e4 + 10; int deleteAndEarn(vector&lt;int&gt;&amp; nums) { // f[i][j] 表示是否删除 j 数 的 最大点数 int n = nums.size(); int maxn = 0; vector&lt;int&gt; cnt(N); for(auto x: nums) { cnt[x] ++; maxn = max(maxn, x); } vector&lt;vector&lt;int&gt;&gt; f(maxn + 1, vector&lt;int&gt;(2, 0)); for (int i = 1; i &lt;= maxn; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = max(f[i][1], f[i - 1][0] + cnt[i] * i); } return max(f[maxn][0], f[maxn][1]); }}; 978. 最长湍流子数组 12345678910111213141516171819// 优化了空间class Solution {public: int maxTurbulenceSize(vector&lt;int&gt;&amp; arr) { int n = arr.size(); // f[i][0/1]表示 以i结尾的数组 元素状态为j的最大湍流子数组长度 vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(2, 0)); int ans = 1; f[0][0] = f[0][1] = 1; for (int i = 1; i &lt; n; i ++) { for (int j = 0; j &lt; 2; j ++) f[i % 2][j] = 1; if (arr[i - 1] &lt; arr[i]) f[i % 2][0] = f[(i - 1) % 2][1] + 1; if (arr[i - 1] &gt; arr[i]) f[i % 2][1] = f[(i - 1) % 2][0] + 1; for (int j = 0; j &lt; 2; j ++) ans = max(ans, f[i % 2][j]); } return ans; }}; 1035. 不相交的线 123456789101112131415161718class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int n = nums1.size(), m = nums2.size(); // f[i][j] 表示 考虑 前 i 个 数字，前 j 个数字组成最大公共子序列长度 // 最长公共子序列 是考虑的情况是不一定包含第i个字符的 // 例如，我们通常考虑f[i - 1][j]为前i - 1，j个数字的最长子序列，但这里不一定包含第j个，只是可能，所以 f[i - 1][j] 包含 f[i - 1][j - 1]; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (nums1[i - 1] == nums2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1143. 最长公共子序列 12345678910111213141516class Solution {public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (text1[i - 1] == text2[j - 1]) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } return f[n][m]; }}; 1218. 最长定差子序列 1234567891011121314151617181920212223class Solution {public: // 注意覆盖问题：hash.insert遇到一样的键不会覆盖 // 由于 arr长度 为 1e5，不能用两层循环，使用哈希表进行优化 int longestSubsequence(vector&lt;int&gt;&amp; arr, int diff) { int n = arr.size(); // f[i][j] 表示 前i个数，第i个数选或不选的最长定差子序列长度 vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(2, 0)); f[0][1] = 1; unordered_map&lt;int, int&gt; hash; hash[arr[0]] = 0; for (int i = 1; i &lt; n; i ++) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = 1; int prev = arr[i] - diff; if (hash.count(prev)) { f[i][1] = max(f[i][1], f[hash[prev]][1] + 1); } hash[arr[i]] = i; } return max(f[n - 1][0], f[n - 1][1]); }}; 1473. 粉刷房子 III 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: const int INF = 0x3f3f3f3f; int minCost(vector&lt;int&gt;&amp; houses, vector&lt;vector&lt;int&gt;&gt;&amp; cost, int n, int m, int t) { // f[i][j][k] 表示 考慮前i个房子，第i个房子粉刷为j，分区数量为k的所有方案中的最小总花费 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(t + 1, 0))); for (int i = 0; i &lt;= n; i ++) for (int j = 0; j &lt;= m; j ++) f[i][j][0] = INF; for (int i = 1; i &lt;= n; i ++) { int color = houses[i - 1]; // 当前房子的颜色 for (int j = 1; j &lt;= m; j ++) { for (int k = 1; k &lt;= t; k ++) { if (k &gt; i) { // 如果分区数量大于房子数，不合法 f[i][j][k] = INF; continue; } if (color != 0) { // 当前房子已经染色 if (color == j) { // 只有与当前颜色相同才能被转移 int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp); // 与前面颜色相同的情况 } else { f[i][j][k] = INF; } } else { // 当前房子未被染色 int u = cost[i - 1][j - 1]; int tmp = INF; for (int p = 1; p &lt;= m; p ++) { // 与前面颜色不同（可组成分区的情况） if (p != j) { tmp = min(tmp, f[i - 1][p][k - 1]); } } f[i][j][k] = min(f[i - 1][j][k], tmp) + u; // 与前面颜色相同的情况 } } } } int ans = INF; for (int i = 1; i &lt;= m; i ++) ans = min(ans, f[n][i][t]); return ans == INF ? -1: ans; }}; 1713. 得到子序列的最少操作次数 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: /* target 6 4 8 1 3 2 arr 4 7 6 2 3 8 6 1 list 1 0 5 4 2 0 3 */ int minOperations(vector&lt;int&gt;&amp; t, vector&lt;int&gt;&amp; a) { int n = t.size(), m = a.size(); unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; n; i ++) hash.insert({t[i], i}); // 建立 target 和 arr 的映射关系 vector&lt;int&gt; list; for (auto x: a) { // 由于target各元素不相同，list中保存了arr与target相同元素的下标，并且递增，故可转化为LIS问题 if (hash.count(x)) list.push_back(hash[x]); } int cnt = list.size(); // q[i] 表示 长度为i的上升子序列 中末尾元素最小的数 vector&lt;int&gt; q(cnt + 1, 0); // 使用LIS的贪心+二分的方法求解，复杂度为nlog(n) // 个人感觉这种优化方式主要是维护一个单调队列，每次加入新的元素，要和之前加入的对比， // 找到比自己小的最后一个数，那么它就可以代替这之前的那个数，因为它更小，更好维护递增序列， // 例如 1 3 5 ，加入1个4（规定长度3），那肯定4替换掉5更好 int len = 0; for (int i = 0; i &lt; cnt; i ++) { int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; list[i]) l = mid; else r = mid - 1; } q[r + 1] = list[i]; if (r + 1 &gt; len) len ++; } return n - len; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E5%BA%8F%E5%88%97DP/"},{"title":"线性DP","text":"10. 正则表达式匹配12345678910111213141516171819202122232425class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(), m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; // dp状态表示：dp[i][j] s以i结尾的子串与p以j结尾的子串是否匹配 vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; // 下一个是*，当前 字符不能单独使用，跳过 if (i - 1 &gt;= 0 &amp;&amp; p[j] != '*') { dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); // 对应了p[j]为普通字符和'.'两种情况 } else if (p[j] == '*') { // 字符为'*' dp[i][j] = (j - 2 &gt;= 0 &amp;&amp; dp[i][j - 2]) || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')); } } return dp[n][m]; }}; 44. 通配符匹配1234567891011121314151617181920class Solution {public: bool isMatch(string ss, string pp) { int n = ss.size(); int m = pp.size(); string s = &quot; &quot; + ss; string p = &quot; &quot; + pp; vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; for (int i = 0; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { if (p[j] != '*') { dp[i][j] = i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (p[j] == s[i] || p[j] == '?'); } else { dp[i][j] = dp[i][j - 1] || (i - 1 &gt;= 0 &amp;&amp; dp[i - 1][j]); } } return dp[n][m]; }}; 45. 跳跃游戏 II123456789101112class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n); for (int i = 1, j = 0; i &lt; n; i ++) { while (j + nums[j] &lt; i) j ++; dp[i] = dp[j] + 1; } return dp[n - 1]; }}; 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string ss) { int n = ss.size(); string s = &quot; &quot; + ss; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; i ++) { int a = s[i] - '0', b = (s[i - 1] - '0') * 10 + (s[i] - '0'); if (a &gt;= 1 &amp;&amp; a &lt;= 9) dp[i] = dp[i - 1]; if (b &gt;= 10 &amp;&amp; b &lt;= 26) dp[i] += dp[i - 2]; } return dp[n]; }}; 115. 不同的子序列1234567891011121314151617181920class Solution {public: int numDistinct(string ss, string tt) { int n = ss.size(), m = tt.size(); string s = &quot; &quot; + ss; string t = &quot; &quot; + tt; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); // f[i][j] 表示 0~i，0~j的字符串匹配个数 for (int i = 0; i &lt;= n; i ++) dp[i][0] = 1; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { // 不匹配s[i] dp[i][j] = dp[i - 1][j]; if (s[i] == t[j]) { // 匹配s[i] dp[i][j] = (0LL + dp[i][j] + dp[i - 1][j - 1]) % INT_MAX; } } return dp[n][m]; }}; 119. 杨辉三角 II123456789101112131415class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; dp(rowIndex + 1); dp[0] = 1; for (int i = 1; i &lt;= rowIndex; i ++) for (int j = i; j &gt;= 0; j --) { if (j - 1 &gt;= 0) dp[j] += dp[j - 1]; if (dp[j] == 0) dp[j] = 1; } vector&lt;int&gt; res; for (int i = 0; i &lt; rowIndex + 1; i ++) res.push_back(dp[i]); return res; }}; 213. 打家劫舍 II1234567891011121314151617181920212223class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 1) return nums[0]; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0)); // 不选第1间, 0不选，1选 for (int i = 1; i &lt; n; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res1 = max(dp[n - 1][0], dp[n - 1][1]); dp[0][1] = nums[0], dp[0][0] = 0; for (int i = 1; i &lt; n - 1; i ++) { dp[i][1] = dp[i - 1][0] + nums[i]; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); } int res2 = max(dp[n - 2][0], dp[n - 2][1]); return max(res1, res2); }}; 403. 青蛙过河1234567891011121314151617181920class Solution {public: bool canCross(vector&lt;int&gt;&amp; stones) { int n = stones.size(); if (stones[1] != 1) return false; // dp[i][j]表示跳到位置i步长为j是否可以 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); dp[1][1] = true; for (int i = 2; i &lt; n; i ++) for (int j = 1; j &lt; i; j ++) { int k = stones[i] - stones[j]; // 步长 if(k &lt;= j + 1) { dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; } } for (int i = 1; i &lt; n; i ++) if (dp[n - 1][i]) return true; return false; }}; 576. 出界的路径数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: const int MOD = (int) 1e9 + 7; int n, m, maxn; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int findPaths(int _m, int _n, int _maxMove, int r, int c) { n = _m, m = _n, maxn = _maxMove; vector&lt;vector&lt;int&gt;&gt; dp(n * m, vector&lt;int&gt;(maxn + 1, 0)); // 初始化边缘 for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j ++) { if (i == 0) add(i, j, dp); if (j == 0) add(i, j, dp); if (i == n - 1) add(i, j, dp); if (j == m - 1) add(i, j, dp); } // f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1] for (int k = 1; k &lt;= maxn; k ++) { for (int idx = 0; idx &lt; m * n; idx ++) { vector&lt;int&gt; info(2, 0); info = parseIdx(idx); int x = info[0], y = info[1]; for (int i = 0; i &lt; 4; i ++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; int nidx = getIdx(nx, ny); dp[idx][k] += dp[nidx][k - 1]; dp[idx][k] %= MOD; } } } return dp[getIdx(r, c)][maxn]; } void add(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;dp) { for (int k = 1; k &lt;= maxn; k ++) { dp[getIdx(x, y)][k] ++; } } int getIdx(int x, int y) { return x * m + y; } vector&lt;int&gt; parseIdx(int idx) { return vector&lt;int&gt;{idx / m, idx % m}; }}; 639. 解码方法 II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution {public: const int MOD = (int) 1e9 + 7; // i 表示当前遍历字符下标，j表示前一个字符下标 // f[i] 表示 以 s[i] 结尾的字符串，共有多少种解码方法 /* s[i] == '*'： s[i]可以单独组成一个，f[i] += f[i - 1] * 9 可以和前面的字符组成： 若s[j] == 1，那么 f[i] += f[i - 2] * 9 (11 - 19) 若s[j] == 2，那么 f[i] += f[i - 2] * 6 (21 - 26) 若s[j] == *，那么 f[i] += f[i - 2] * 15 s[i] != '*'，s[i]为数字时： s[j] 为 '*'： s[i] == 0，f[i] += f[i - 2] * 2; （10，20） s[i] != 0： f[i] = f[i - 1] (1 - 9) 1 &lt;= s[i] &lt;= 6 f[i] += f[i - 2] * 2 （11 - 16，21 - 26） 7 &lt;= s[i] &lt;= 9 f[i] += f[i - 2] * 1 （17 - 19） s[j] != '*'： s[i] == 0，f[i] = f[i - 2] (10, 20) s[i] != 0： f[i] = f[i - 1] (1 - 9) s[j] == 1，f[i] = f[i - 2]; (11 - 19) s[j] == 2 且 1 &lt;= s[i] &lt;= 6 ，f[i] = f[i - 2]; (21 - 26) */ int numDecodings(string s) { int n = s.size(); vector&lt;long&gt; f(n, 0); // 注意这里要long f[0] = s[0] == '*' ? 9 : (s[0] != '0' ? 1 : 0); for (int i = 1; i &lt; n; i ++) { char c = s[i], prev = s[i - 1]; if (c == '*') { f[i] += f[i - 1] * 9; if (prev == '*') f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 15; else { int u = prev - '0'; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 9; else if (u == 2) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 6; } } else { int t = c - '0'; if (prev == '*') { if (t == 0) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; else { f[i] += f[i - 1]; if (t &gt;= 1 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1) * 2; if (t &gt;= 7 &amp;&amp; t &lt;= 9) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { int u = prev - '0'; if (t == 0) { if (u == 1 || u == 2) { f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } else { f[i] = f[i - 1]; if (u == 1) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); if (u == 2 &amp;&amp; t &lt;= 6) f[i] += (i - 2 &gt;= 0 ? f[i - 2] : 1); } } } f[i] %= MOD; } return (int) f[n - 1]; }}; 650. 只有两个键的键盘1234567891011121314151617181920// f[i][j]表示经过最后一次操作，记事本上有i个字符，粘贴板上有j个字符的最小操作次数class Solution {public: const int MAX_INT = 0x3f3f3f3f; int minSteps(int n) { vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, MAX_INT)); dp[1][0] = 0, dp[1][1] = 1; for (int i = 2; i &lt;= n; i ++) { int minN = MAX_INT; for (int j = 0; j &lt;= i / 2; j ++) { dp[i][j] = dp[i - j][j] + 1; // paste minN = min(minN, dp[i][j]); } dp[i][i] = minN + 1; // copy all } int res = MAX_INT; for (int i = 0; i &lt;= n; i ++) res = min(res, dp[n][i]); return res; }}; 678. 有效的括号字符串1234567891011121314151617181920212223class Solution {public: bool checkValidString(string s) { int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(n + 1, 0)); dp[0][0] = true; for (int i = 1; i &lt;= n; i ++) { char c = s[i - 1]; for (int j = 0; j &lt;= i; j ++) { if (c == '(') { if (j - 1 &gt;= 0) dp[i][j] = dp[i - 1][j - 1]; } else if (c == ')') { if (j + 1 &lt;= i) dp[i][j] = dp[i - 1][j + 1]; } else { dp[i][j] = dp[i - 1][j]; if (j - 1 &gt;= 0) dp[i][j] = dp[i][j] | dp[i - 1][j - 1]; if (j + 1 &lt;= i) dp[i][j] = dp[i][j] | dp[i - 1][j + 1]; } } } return dp[n][0]; }}; 1220. 统计元音字母序列的数目12345678910111213141516171819202122232425262728293031class Solution {public: const int MOD = 1e9 + 7; // dp[i][j] 表示 长度为i的字符串，结尾为j的字符串 的 个数 int countVowelPermutation(int n) { vector&lt;vector&lt;long&gt;&gt; dp(n, vector&lt;long&gt;(5, 0)); for (int i = 0; i &lt; 5; i ++) dp[0][i] = 1; for (int i = 1; i &lt; n; i ++) { // 每个元音 'a' 后面都只能跟着 'e' dp[i][1] += dp[i - 1][0]; // 每个元音 'e' 后面只能跟着 'a' 或者是 'i' dp[i][0] += dp[i - 1][1]; dp[i][2] += dp[i - 1][1]; // 每个元音 'i' 后面 不能 再跟着另一个 'i' dp[i][0] += dp[i - 1][2]; dp[i][1] += dp[i - 1][2]; dp[i][3] += dp[i - 1][2]; dp[i][4] += dp[i - 1][2]; // 每个元音 'o' 后面只能跟着 'i' 或者是 'u' dp[i][2] += dp[i - 1][3]; dp[i][4] += dp[i - 1][3]; // 每个元音 'u' 后面只能跟着 'a' dp[i][0] += dp[i - 1][4]; for (int j = 0; j &lt; 5; j ++) dp[i][j] %= MOD; } long res = 0; for (int i = 0; i &lt; 5; i ++) res += dp[n - 1][i]; return (int) (res % MOD); }}; 1751. 最多可以参加的会议数目 II1234567891011121314151617181920212223242526272829303132333435class Solution {public: static bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) { // 升序排序 return a[1] &lt;= b[1]; } int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; events, int k) { int n = events.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k + 1, 0)); sort(events.begin(), events.end(), cmp); for (int i = 0; i &lt; n; i ++) printf(&quot;[%d %d %d]&quot;, events[i][0], events[i][1], events[i][2]); for (int i = 1; i &lt;= n; i ++) { auto p = events[i - 1]; int s = p[0], e = p[1], v = p[2]; int last = 0; for (int t = i - 1; t &gt;= 1; t --) { auto l = events[t - 1]; if (s &gt; l[1]) { last = t; // 更新为不冲突的事件下标 break; } } for (int j = 1; j &lt;= k; j ++) { dp[i][j] = max(dp[i - 1][j], dp[last][j - 1] + v); // 选与不选 } } return dp[n][k]; }}; 1787. 使所有区间的异或结果为零12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: /* 易知，将nums排列为一个二维数组（每行为k个），问题将转化为： 使得每列相等，且最终首行异或值为0的更改元素数 定义 f[i][xor]为考虑前i列，且首行前i列异或值的xor的更改元素数 由于需要知道i - 1列的最小更改元素数，使之转态转移，所以需要一个状态数组prev 另外，使用 map记录每一列数字对应的个数 cnt记录每一列数字总数 所以，分析状态转移方程 当在第0列时： f[0][xor] = f[0][xor] + cnt - map[xor] 当在其他列时，需要考虑从前一列转移的状态： 另外，还有 考虑整列修改： f[i][xor] = f[i - 1][xor] + cnt; 考虑部分修改： f[i][xor] = f[i - 1][xor ^ cur] + cnt - map[cur]; */ const int maxVal = INT_MAX / 2; const int maxHalf = 1 &lt;&lt; 10; int minChanges(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(maxHalf, maxVal)); vector&lt;int&gt; prev(k, maxVal); for (int i = 0; i &lt; k; i ++) { // 遍历每一列 int cnt = 0; unordered_map&lt;int, int&gt; map; for (int j = i; j &lt; n; j += k) { map[nums[j]] ++; cnt ++; } if (i == 0) { // 第0列 for (int x = 0; x &lt; maxHalf; x ++) { dp[0][x] = min(dp[0][x], cnt - map[x]); prev[0] = min(prev[0], dp[0][x]); } } else { // 其他列 for (int x = 0; x &lt; maxHalf; x ++) { dp[i][x] = prev[i - 1] + cnt; for (auto &amp;it: map) { dp[i][x] = min(dp[i][x], dp[i - 1][x ^ it.first] + cnt - it.second); } prev[i] = min(prev[i], dp[i][x]); } } } return dp[k - 1][0]; }}; 剑指 Offer 42. 连续子数组的最大和1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; int ans = dp[0]; for (int i = 1; i &lt; n; i ++) { dp[i] = max(nums[i], dp[i - 1] + nums[i]); ans = max(ans, dp[i]); } return ans; }}; LCP 07. 传递信息12345678910111213class Solution {public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) { vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(15, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= k; i ++) for(auto &amp;r: relation) { int a = r[0], b = r[1]; dp[i][b] += dp[i - 1][a]; } return dp[k][n - 1]; }};","link":"/2022/01/30/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7DP/"},{"title":"第71周双周赛","text":"5984. 拆分数位后四位数字的最小和123456789101112131415161718192021222324class Solution {public: int minimumSum(int num) { vector&lt;int&gt; vec; int t = num; while (t) { vec.push_back(t % 10); t /= 10; } sort(vec.begin(), vec.end()); int zero = count(vec.begin(), vec.end(), 0); if (zero == 3) { return vec[3]; } else if (zero == 2) { return vec[2] + vec[3]; } else if (zero == 1) { if (vec[2] &gt; vec[3]) return vec[1] * 10 + vec[3] + vec[2]; return vec[1] * 10 + vec[2] + vec[3]; } else { return vec[0] * 10 + vec[2] + vec[1] * 10 + vec[3]; } return 0; }}; 5985. 根据给定数字划分数组1234567891011121314151617class Solution {public: vector&lt;int&gt; pivotArray(vector&lt;int&gt;&amp; nums, int pivot) { vector&lt;int&gt; vec1; for (auto num: nums) if (num &lt; pivot) vec1.push_back(num); vector&lt;int&gt; vec2; for (auto num: nums) if (num &gt; pivot) vec2.push_back(num); int tot = count(nums.begin(), nums.end(), pivot); vector&lt;int&gt; res; for (auto i: vec1) res.push_back(i); for (int i = 0; i &lt; tot; i ++) res.push_back(pivot); for (auto i: vec2) res.push_back(i); return res; }}; 5986. 设置时间的最少代价123456789101112131415161718192021222324252627282930313233class Solution {public: /* 分类讨论 因为秒数的范围[0,99], 分两种场景讨论: a. mins = target / 60, secs = target % 60; b. mins = target / 60 - 1, secs = target % 60 + 60; 将mins*100+secs转为字符串进行处理, 求出花费的时间即可; */ int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) { int mins = targetSeconds / 60, secs = targetSeconds % 60; int ans1 = calTime(startAt, moveCost, pushCost, mins, secs); int ans2 = calTime(startAt, moveCost, pushCost, mins - 1, secs + 60); return min(ans1, ans2); } int calTime(int startAt, int moveCost, int pushCost, int mins, int secs) { if (mins &lt; 0 || mins &gt; 99 || secs &gt; 99) { return INT_MAX; } string s = to_string(mins * 100 + secs); int ans = 0; for (int i = 0; i &lt; s.size(); i ++) { if (s[i] - '0' == startAt) { ans += pushCost; } else { ans += pushCost + moveCost; } startAt = s[i] - '0'; } return ans; }}; 5987. 删除元素后和的最小差值1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: /* 枚举i为分界点，维护0-i内长度为n / 3 的最小值，i + 1 - n - 1内长度为n / 3的最大值 */ long long minimumDifference(vector&lt;int&gt;&amp; nums) { int n = nums.size(), k = n / 3; vector&lt;long long&gt; s1(n, 0); priority_queue&lt;int&gt; small; // 大根堆，维护0 - i内的最小值 for (int i = 0; i &lt; 2 * k; i ++) { s1[i] = (i &gt; 0) ? s1[i - 1] : 0; small.push(nums[i]); s1[i] += nums[i]; if (small.size() &gt; k) { s1[i] -= small.top(); small.pop(); } } vector&lt;long long&gt; s2(n, 0); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; big; // 小根堆，维护 i + 1 - n - 1内的最大值 for (int i = n - 2; i &gt;= k - 1; i --) { // 注意这里是n - 2的原因是，下面计算答案是从 k - 1 ~ 2 *k - 1，如果为n-1，会多算一个数进来 // 例如 1 2 3 4 5 6 ，n-2会使得下标为1的位置s[1] 表示 后4个数中最大值，n-1则表示5个数了 s2[i] = s2[i + 1]; big.push(nums[i + 1]); s2[i] += nums[i + 1]; if (big.size() &gt; k) { s2[i] -= big.top(); big.pop(); } } long long res = 1e15; for (int i = k - 1; i &lt; 2 * k; i ++) { res = min(res, s1[i] - s2[i]); } return res; }};","link":"/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC71%E5%91%A8%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第279场周赛","text":"6000. 对奇偶下标分别排序123456789101112131415161718class Solution {public: vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; vec1, vec2; for (int i = 0; i &lt; nums.size(); i ++) { if (i % 2 == 0) vec1.push_back(nums[i]); // 偶数 else vec2.push_back(nums[i]); // 奇数 } sort(vec1.begin(), vec1.end()); sort(vec2.begin(), vec2.end(), greater&lt;int&gt;()); vector&lt;int&gt; res; for (int i = 0, j = 0, k = 0; i &lt; nums.size(); i ++) { if (i % 2 == 0) res.push_back(vec1[j ++]); else res.push_back(vec2[k ++]); } return res; }}; 6001. 重排数字的最小值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: vector&lt;int&gt; getNum(long long num) { vector&lt;int&gt; a; while(num) { a.push_back(num % 10); num /= 10; } return a; } long long smallestNumber(long long num) { long long res = 0; if (num &gt; 0) { auto a = getNum(num); sort(a.begin(), a.end()); int i = 0, n =a.size(), k = 0; bool flag = true; vector&lt;int&gt; vec; for (int i = 0; i &lt; n; i ++) { if (a[i] != 0 &amp;&amp; flag){ k = i, flag = !flag; continue; } vec.push_back(a[i]); } res += a[k] * pow(10, n - 1); int cnt = vec.size() - 1; for (int i = 0; i &lt; vec.size(); i ++) { res += vec[i] * pow(10, cnt); cnt --; } } else { long long n1 = -num; auto a = getNum(n1); sort(a.begin(), a.end(), greater&lt;int&gt;()); int cnt = a.size() - 1; for (int i = 0; i &lt; a.size(); i ++) { res += a[i] * pow(10, cnt); cnt --; } res = -res; } return res; }}; 6002. 设计位集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Bitset {public: string bst, fbst; int cnt; bool flipped; // 判断是否翻转 Bitset(int size) { bst = string(size, '0'); fbst = string(size, '1'); cnt = 0; flipped = false; } void fix(int idx) { if (!flipped) { if (bst[idx] == '0') cnt ++; bst[idx] = '1'; fbst[idx] = '0'; } else { if (bst[idx] == '1') cnt ++; // 如果翻转了，则是fbit，那么翻转前是1，翻转后是0，fix设置fbit，则加1 bst[idx] = '0'; fbst[idx] = '1'; } } void unfix(int idx) { if (!flipped) { if (bst[idx] == '1') cnt --; bst[idx] = '0'; fbst[idx] = '1'; } else { if (bst[idx] == '0') cnt --; bst[idx] = '1'; fbst[idx] = '0'; } } void flip() { flipped = !flipped; cnt = bst.size() - cnt; } bool all() { return cnt == bst.size(); } bool one() { return cnt &gt; 0; } int count() { return cnt; } string toString() { if (!flipped) return bst; else return fbst; }};/** * Your Bitset object will be instantiated and called as such: * Bitset* obj = new Bitset(size); * obj-&gt;fix(idx); * obj-&gt;unfix(idx); * obj-&gt;flip(); * bool param_4 = obj-&gt;all(); * bool param_5 = obj-&gt;one(); * int param_6 = obj-&gt;count(); * string param_7 = obj-&gt;toString(); */ 6003. 移除所有载有违禁货物车厢所需的最少时间前后缀分解 + DP - 移除所有载有违禁货物车厢所需的最少时间 1234567891011121314151617181920212223242526class Solution {public: /* 考虑左半部分的最少时间。 当s[i] == '0' pre[i] = pre[i - 1] 当s[i] == '1' pre[i] = min(pre[i - 1] + 2, i + 1) 考虑右半部分的最少时间 s[i] == '0' , suf[i] = suf[i + 1] s[i] == '1' , suf[i] = min(suf[i + 1] + 2, n - i) */ int minimumTime(string s) { int n = s.length(); vector&lt;int&gt; suf(n + 1, 0); // 移除后i个载有违禁货物车所需的最少单位时间数 for (int i = n - 1; i &gt;= 0; i --) { suf[i] = s[i] == '0' ? suf[i + 1] : min(suf[i + 1] + 2, n - i); } // 枚举分割点 int pre = 0, ans = suf[0]; // pre使用滚动数组优化 for (int i = 0; i &lt; n; i ++) { if (s[i] == '1') pre = min(pre + 2, i + 1); ans = min(ans, pre + suf[i]); } return ans; }};","link":"/2022/02/06/LC%E5%91%A8%E8%B5%9B/%E7%AC%AC279%E5%9C%BA%E5%91%A8%E8%B5%9B/"},{"title":"Java类的加载机制","text":"1 概述​ 首先，先看如下的Java代码执行流程图 ​ 类的加载是指图中：字节码进入Java虚拟机后的一系列过程。具体是：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 ​ 简单来说，类的加载过程（从加载到虚拟机内存到卸出）：包括了加载，验证，准备，解析，初始化，使用，卸载。 ​ 其他的过程顺序都是确定的，除了解析，它在某些情况下可以在初始化阶段后开始。注意：这里的顺序指的是按顺序开始，但之后执行与完成可能不是顺序的，这些阶段通常是交叉执行的。 2 类的加载过程2.1 加载​ 在这一阶段，虚拟机通常需要完成三件事情： 1）通过类的全限定名（包名+类名），获取到该类的.class文件的二进制字节流 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3）在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口 简单来说，就如下图 ​ 下面对再稍微细说下这三阶段 加载二进制数据到内存 ​ 这一阶段并没有说明从哪里获取以及怎么获取，这是交给开发人员自定义的，一般的读取方式有以下 从ZIP包中获取，或者JAR包（很常见现在），WAR包等 从网络获取，例如Applet 运行时计算生成，使用动态代理技术 …… 映射jvm能够识别的结构 ​ 将映射后可以被虚拟机识别的格式存储在方法区中，这种数据存储格式是由虚拟机自行定义 在内存中生成class文件 ​ 在Java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口 2.2 验证​ 该阶段是连接阶段的第一步，这是要确保前面加载进来的字节流包含的数据符合要求，不会危害到虚拟机的安全 ​ 一般有以下四个阶段的检验过程 文件格式检验 ​ 字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。例如魔数开头是否正确，版本号是否在范围内，常量池是否有不支持的常量等 元数据验证 ​ 对描述信息进行语义分析，确保描述的信息符合Java语言规范的要求。例如该类是否有父类，是否继承了不允许被继承的类，如果不是抽象类，是否实现了该父类或接口要求实现的所有方法。 字节码验证 ​ 进行数据流和控制流分析（对类的方法体进行校验分析）。例如保证操作数栈的数据类型和指令代码序列能够配合工作，跳转指令不会跳转到方法体以外的字节码指令上，保证方法体类型转化有效。 符号引用验证 ​ 这会发生在虚拟机符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段发生。 ​ 这里符号引用是指任何形式的字面量，这与内存布局无关，引用的目标不一定加载到内存中，例如，引用了org.simple.people，那么则使用org.simple.people来表示该类的地址。而直接引用是则可以是指向目标的指针，相对偏移量，句柄等，该引用的目标必定存在于虚拟机内存中 ​ 通常这里要检查以下内容 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段 …. 2.3 准备​ 这一阶段将会为类变量分配内存并设置类变量初始值，这些内存都会在方法区中分配（JDK1.6）。注意，这里的类变量是指被static修饰的变量，实例变量将会在对象实例化随着对象分配到Java堆中。并且，初始值是指数据类型的零值 1public static int value = 123; ​ 这里，准备阶段后，初始值为0，不是123，将value赋值为123的操作在初始化阶段才会执行 ​ 但会存在特殊情况，如果某个变量是不可变的，例如上述变量定义为： 1public static final int value = 123; ​ 这样，准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123 2.4 解析​ 这一阶段将会将常量池内的符号引用替换为直接引用。符号引用的解析可以出现多次，虚拟机实现可能会对第一次解析的结果进行缓存，以便后续使用。 ​ 解析动作主要针对以下四类进行 类或接口的解析 字段解析 类方法解析 接口方法解析 ​ 由于这些篇幅过长，就不细说，具体查看《深入理解Java虚拟机》 2.5 初始化​ 这一阶段是通过程序制定的主观计划去初始化类变量和其他资源，从另一方面说，是执行类构造器&lt;clinit&gt;()方法的过程。这一方法运行的行为和细节如下： &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值操作和static{}块合并产生。 &lt;clinit&gt;()方法与类的构造函数不同，不需要显式调用父类构造器，父类的&lt;clinit&gt;()方法已经执行完毕 通过以上两点可知，父类定义的静态语句块要优于子类的变量赋值操作 &lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步 3 类加载器​ 通过对前面类加载过程的阐述，可以发现除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。类加载器提高了JVM的可扩展性，是Java语言流行一大原因。 3.1 双亲委派模型​ 绝大部分Java程序都会使用到以下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader） ​ 应用程序都是由这三类类加载器互相配合进行加载的，如果有必要，可以加入自定义的类加载器 ​ 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 ​ 双亲委派模型的工作流程： 一个类加载器收到类加载的请求，不会首先自己尝试加载该类 将该请求委派给父类加载器去完成，对于每个层次的类加载器都是如此 所有的加载请求最终都应该传送到顶层的启动类加载器中 只有当父加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载 ​ 使用该模型的好处有如下： Java类和它的类加载器一起具备一种带有优先级的层次关系 ​ 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。如果您有 上面的好处也从一定程度上防止了危险代码的植入 参考《深入理解Java虚拟机-第3版》 jvm类加载器，类加载机制详解，看这一篇就够了 - SegmentFault 思否 Java类加载机制（全套） - 掘金 (juejin.cn) Java虚拟机 - 符号引用和直接引用理解 - qlky - 博客园 (cnblogs.com) (99条消息) 符号引用和直接引用有什么区别_绅士jiejie的博客-CSDN博客_符号引用和直接引用的区别","link":"/2022/02/07/Java/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"Spring源码阅读（一）","text":"1 前言​ 阅读源码可以帮助提高debug能力以及更加熟悉该框架的原理与构建方式，学习大师的思维。本系列文章将会通过阅读Spring源码，尽力分析各个函数，类，接口等的实现方式与原理，来让自己更加深刻理解这一框架。 ​ 首先，我们要知道，Spring是一个生态体系，其中包含了Spring Framework, Spring Boot, Spring Cloud等，一般说的Spring源码是指Spring Framework中的。 ​ 而在Spring Framework中，又会有许多模块所组成 一共有以下20多个不同的模块 12345spring-aop spring-context-indexer spring-instrument spring-orm spring-webspring-aspects spring-context-support spring-jcl spring-oxm spring-webfluxspring-beans spring-core spring-jdbc spring-r2dbc spring-webmvcspring-context spring-expression spring-jms spring-test spring-websocketspring-messaging spring-tx ​ 而我们知道，Spring最核心的功能就是IOC和AOP，也是本次源码分析的重点 ​ 在图中，也就是Core Container中的模块和AOP、Aspects。接下来，说说大致作用： Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。 Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。 Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。 AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。 大致了解了以后，将进入源码分析了 2 环境搭建新建一个maven项目以后，导入以下pom文件 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring_core&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; applicationContext.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;com.w1nd.spring.dao.Person&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;Bruis&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Person.java 123456789package com.w1nd.spring.dao;import lombok.Data;@Datapublic class Person { private Integer age; private String name;} 3 IoC过程​ IoC（控制反转）简单来说就是将创建Bean和注入Bean的权利赋予给了Spring容器，不用程序员自己去管理，在bean生成或初始化的时候，Spring容器就会将数据注入到bean中，又或者通过将对象的引用注入到对象数据域中的方式来注入对方法调用的依赖。 ​ 在Spring容器的设计中，有两个主要的容器机制： 实现BeanFactory接口的简单容器系列 ​ 实现了容器最基本的功能 ApplicationContext应用上下文 ​ 除了拥有BeanFactory的所有功能外，还支持特殊类型bean如上一节中的BeanFactoryPostProcessor和BeanPostProcessor的自动识别、资源加载、容器事件和监听器、国际化支持、单例bean自动初始化等。 对于这两个容器，DefaultListableBeanFactory是是Spring注册及加载bean的默认实现，我们可以直接使用该类来加载 123456789101112131415161718package com.w1nd.spring;import com.w1nd.spring.dao.Person;import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain { public static void main(String[] args) { DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); reader.loadBeanDefinitions(&quot;applicationContext.xml&quot;); Person person1 = (Person) beanFactory.getBean(&quot;person&quot;); System.out.println(person1); }} 但在下面演示中，为了更好的了解spring一系列衍生方案，使用ClassPathXmlApplicationContext来加载xml文件，演示程序如下 1234567891011121314package com.w1nd.spring;import com.w1nd.spring.dao.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringMain { public static void main(String[] args) { //使用spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person person = (Person)context.getBean(&quot;person&quot;); System.out.println(person); }} ​ 另外，我们来看DefaultListableBeanFactory和ClassPathXmlApplicationContext两个类的继承链图，这对于接下来的debug会更有帮助 ​ 建议将该图画下来，debug时对着用箭头标明，这样不会混乱 ​ 下面对上述演示程序debug 3.1 初始 加载ContextClosedEvent，以免后续出现问题 ClassPathXmlApplicationContext构造函数（ClassPathXmlApplicationContext.class） 12345678910111213141516171819202122public ClassPathXmlApplicationContext(String configLocation) throws BeansException { this(new String[] {configLocation}, true, null);}/* 使用给定的父类容器创建新的ClassPathXmlApplicationContext，然后从给定的XML文件加载定义， 加载所有bean定义并且创建所有的单例，在进一步配置上下文后调用refresh。换句话说xml文件的读取， bean的创建和实例化都是在refresh()方法中进行的，refresh()函数中包含了几乎所有的 ApplicationContext中提供的全部功能。*/public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); //设置配置路径 setConfigLocations(configLocations); if (refresh) { //refresh Spring容器 很重要，这个方法 refresh(); }} 设置配置路径（AbstractRefreshableConfigApplicationContext.class） 12345678910111213//给configLocations字符串数组设置值，支持多个配置文件已数组方式同时传入。public void setConfigLocations(@Nullable String... locations) { if (locations != null) { Assert.noNullElements(locations, &quot;Config locations must not be null&quot;); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) { this.configLocations[i] = resolvePath(locations[i]).trim(); } } else { this.configLocations = null; }} 3.2 refresh refresh函数（AbstractApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 简单来说，Spring容器的初始化是在refresh()方法来启动的，这个方法标志着IOC容器的正式启动。 具体来说，这里的启动包括了BeanDefinition和Resource的定位、载入和注册三个基本过程。*/@Overridepublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;); // 准备刷新容器（上下文环境） prepareRefresh(); // 通知子类刷新内部bean工厂，初始化BeanFactory并进行XML的解析读取 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 准备 bean 工厂以在此上下文中使用。 prepareBeanFactory(beanFactory); try { // 允许在上下文子类中对 bean 工厂进行后处理。 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;); // 调用在上下文中注册为 bean 的工厂处理器。 invokeBeanFactoryPostProcessors(beanFactory); // 注册拦截 bean 创建的 bean 处理器。 registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // 为此上下文初始化消息源。 initMessageSource(); // 为此上下文初始化事件多播器。 initApplicationEventMulticaster(); // 初始化特定上下文子类中的其他特殊 bean。 onRefresh(); // 检查侦听器 bean 并注册它们。 registerListeners(); // 实例化所有剩余的（非惰性初始化）单例。 finishBeanFactoryInitialization(beanFactory); // 最后一步：发布相应的事件。 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } }} ​ 鉴于该方法的重要性，下面对其函数名分目录分别讲解，每个函数会逐渐深入其子函数去分序号，部分不会讲的可能不太重要或仅知道该函数作用即可。往后，每个函数名后面会写明所在类，部分辅助函数和其他函数放在同个代码块说明，代码块的函数通常在同个类，如果不在，会在注释标明 3.3 prepareRefresh prepareRefresh（）（AbstractApplicationContext.class） 1234567891011121314151617181920212223242526272829303132333435363738/* 准备此上下文以进行刷新、设置其启动日期和活动标志以及执行任何属性源的初始化。*/protected void prepareRefresh() { // 切换到活动状态 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) { if (logger.isTraceEnabled()) { logger.trace(&quot;Refreshing &quot; + this); } else { logger.debug(&quot;Refreshing &quot; + getDisplayName()); } } // 初始化上下文环境中的任何占位符属性源。这里对于子类啥都不会干 initPropertySources(); // 验证所有标记为必需的属性都是可解析的： // 请参阅 ConfigurablePropertyResolvesetRequiredProperties getEnvironment().validateRequiredProperties(); // 存储预刷新 ApplicationListeners... if (this.earlyApplicationListeners == null) { this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); } else { // 将本地应用程序侦听器重置为预刷新状态。 this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); } // 允许收集早期应用程序事件，一旦多播器可用就发布... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();} 3.4 obtainFreshBeanFactory该方法的时序图 obtainFreshBeanFactory （AbstractApplicationContext.class） 1234567/* 告诉子类刷新内部 bean 工厂。会返回新的BeanFactory实例*/protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { refreshBeanFactory(); return getBeanFactory();} refreshBeanFactory（AbstractRefreshableApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 此实现执行此上下文的底层 bean 工厂的实际刷新，关闭先前的 bean 工厂（如果有）并为上下文生命周期的下一阶段初始化一个新的 bean 工厂。*/@Overrideprotected final void refreshBeanFactory() throws BeansException { // 如果有 Bean工厂，则关闭该工厂 if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // 创建一个新bean工厂，这里的DefaultListableBeanFactory就是前面的Spring核心类，这个类真的很重要！ DefaultListableBeanFactory beanFactory = createBeanFactory(); // 序列化指定ID，如果需要的话，让这个BeanFactory从ID反序列化掉BeanFactory对象 beanFactory.setSerializationId(getId()); // 自定义此上下文使用的内部 bean 工厂。为每次 refresh() 尝试调用。默认实现应用此上下文 // 的“allowBeanDefinitionOverriding”和“allowCircularReferences”设置（如果指定）。 // 可以在子类中重写以自定义任何DefaultListableBeanFactory 的设置。 customizeBeanFactory(beanFactory); // 加载bean定义信息，这一步实际上就从XML配置文件里的bean信息给读取到了Factory里了。 loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; } catch (IOException ex) { throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); }}/* 确定此上下文当前是否包含 bean 工厂，即至少已刷新一次且尚未关闭。*/ protected final boolean hasBeanFactory() { return (this.beanFactory != null);}/* 关闭BeanFactory实例*/@Overrideprotected final void closeBeanFactory() { DefaultListableBeanFactory beanFactory = this.beanFactory; if (beanFactory != null) { beanFactory.setSerializationId(null); this.beanFactory = null; }} ​ 上面图片，是loadBeanDefinitions（）方法运行完之后，eanFactory变量里面存放着一个ConcurrentHashMap变量，用于存放着person这个KV键值对，Key为person，Value为一个ArrayList的变量，里面存放着person的两个属性：age、name。下面接着深入该方法分析 loadBeanDefinitions（AbstractXmlApplicationContext.class） ​ BeanDefinition，顾名思义，用于定义bean信息的类，包含bean的class类型、构造参数、属性值等信息，每个bean对应一个BeanDefinition的实例。简化BeanDefinition仅包含bean的class类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 通过 XmlBeanDefinitionReader 加载 bean 定义。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 为给定的 BeanFactory 创建一个新的 XmlBeanDefinitionReader。 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 使用此上下文的资源加载环境配置 bean 定义阅读器。 beanDefinitionReader.setEnvironment(this.getEnvironment()); // 设置 ResourceLoader 以用于资源定位。 beanDefinitionReader.setResourceLoader(this); // 设置要用于解析的 SAX 实体解析器。默认情况下，将使用 ResourceEntityResolver。 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 允许子类提供阅读器的自定义初始化 initBeanDefinitionReader(beanDefinitionReader); // 实际加载 bean 定义。 loadBeanDefinitions(beanDefinitionReader);}/* AbstractApplicationContext.class 以可配置的形式返回此应用程序上下文的环境，允许进一步定制。 如果未指定，则将通过 createEnvironment() 初始化默认环境。*/@Overridepublic ConfigurableEnvironment getEnvironment() { if (this.environment == null) { this.environment = createEnvironment(); } return this.environment;}/* XmlBeanDefinitionReader.class*/public void setEntityResolver(@Nullable EntityResolver entityResolver) { this.entityResolver = entityResolver;}/* 初始化用于加载此上下文的 bean 定义的 bean 定义阅读器。默认实现为空。 可以在子类中被覆盖，例如用于关闭 XML 验证或使用不同的 XmlBeanDefinitionParser 实现。*/protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) { reader.setValidating(this.validating);} loadBeanDefinitions（AbstractXmlApplicationContext.class） ​ 注意这个和上个不一样，是重载 1234567891011121314/* 使用给定的 XmlBeanDefinitionReader 加载 bean 定义。 bean 工厂的生命周期由 refreshBeanFactory 方法处理；因此这个方法只是应该加载和或注册 bean 定义。*/protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { reader.loadBeanDefinitions(configLocations); // &lt;-------是string路径会执行这个 }} loadBeanDefinitions（AbstractBeanDefinationReader.class） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException { Assert.notNull(locations, &quot;Location array must not be null&quot;); int count = 0; for (String location : locations) { count += loadBeanDefinitions(location); } return count;}/* 从指定的资源位置加载 bean 定义。位置也可以是位置模式， 前提是此 bean 定义读取器的 ResourceLoader 是 ResourcePatternResolver。*/public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException { ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) { throw new BeanDefinitionStoreException( &quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;); } if (resourceLoader instanceof ResourcePatternResolver) { // 资源模式匹配可用。 try { Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); // 从指定的 XML 文件加载 bean 定义。这里debug会进去XmlBeanDefinitionReader， int count = loadBeanDefinitions(resources); if (actualResources != null) { Collections.addAll(actualResources, resources); } if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;); } return count; } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); } } else { // 只能通过绝对 URL 加载单个资源。 Resource resource = resourceLoader.getResource(location); int count = loadBeanDefinitions(resource); if (actualResources != null) { actualResources.add(resource); } if (logger.isTraceEnabled()) { logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;); } return count; }} getResources（PathMatchingResourcePatternResolver.class） 12345678910111213141516171819202122232425262728@Overridepublic Resource[] getResources(String locationPattern) throws IOException { Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) { // 类路径资源（可能有多个同名资源） if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) { // 类路径资源模式 return findPathMatchingResources(locationPattern); } else { // 具有给定名称的所有类路径资源 return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); } } else { // 通常只在前缀后面查找一个模式，并且在Tomcat之后只有“* /”分隔符之后的“war：”协议。 int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(':') + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) { // 文件模式 return findPathMatchingResources(locationPattern); } else { // 具有给定名称的单个资源 return new Resource[] {getResourceLoader().getResource(locationPattern)}; } }} loadBeanDefinitions（XmlBeanDefinitionReader.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 从XML配置文件中获取bean定义信息*/public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); ... Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } ... try { InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } //获取到读取xml配置文件的InputStream流后，进行BeanDefinitions的加载 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { ... } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }}/* 真正从xml配置文件中加载Bean定义信息*/protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { //获取xml的配置信息并封装为Document对象 Document doc = doLoadDocument(inputSource, resource); return this.registerBeanDefinitions(doc, resource); } catch (BeanDefinitionStoreException ex) { ... }} 以上的流程是在读取BeanDefinition信息，下面看如何将其注册 registerBeanDefinitions（XmlBeanDefinitionReader.class） 123456789101112/* 注册包含在给定 DOM 文档中的 bean 定义*/public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { // 创建 BeanDefinitionDocumentReader 以用于从 XML 文档中实际读取 bean 定义 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 注册表中定义的 bean 数量 int countBefore = getRegistry().getBeanDefinitionCount(); // 打开一个 DOM 文档；然后初始化在 &lt;beans&gt; 级别指定的默认设置；然后解析包含的 bean 定义。 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // &lt;----------- return getRegistry().getBeanDefinitionCount() - countBefore;} registerBeanDefinitions（DefaultBeanDefinitionDocumentReader.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* 注册并解析包含的 bean 定义。*/public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; doRegisterBeanDefinitions(doc.getDocumentElement());}/* 在给定的根 &lt;beans&gt; 元素中注册每个 bean 定义。*/protected void doRegisterBeanDefinitions(Element root) { BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 解析beanDefinitions信息，经过这个方法，beanFactory中就会保存从xml配置文件中解析而来的信息 parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;}/* 解析文档中根级别的元素：“import”、“alias”、“bean”*/protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析默认元素 parseDefaultElement(ele, delegate); } else { delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); }}/* 解析默认元素*/private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { // 读取到xml配置文件的&lt;bean&gt;节点 processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 递归 doRegisterBeanDefinitions(ele); }}/* 处理给定的 bean 元素，解析 bean 定义并将其注册到注册表。*/protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 解析提供的 &lt;bean&gt; 元素 if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); // 如果适用，通过命名空间处理程序装饰给定的 bean 定义。 try { // 注册最终的装饰实例。 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // 发送注册事件。 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} parseBeanDefinitionElement（BeanDefinitionParserDelegate.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);}/* 解析提供的 &lt;bean&gt; 元素。*/@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isTraceEnabled()) { logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } //终于，这里要解析beanDefinition了 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { if (containingBean != null) { beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null;}/* 解析 bean 定义本身，而不考虑名称或别名。如果在解析 bean 定义期间出现问题，则可能返回 null。*/@Nullablepublic AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { // 创建BeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); parseMetaElements(ele, bd); parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 通过构造器解析参数值 parseConstructorArgElements(ele, bd); // 通过property的value解析值吗，本文的程序xml就是通过property属性设置bean的值的，最终被这一方法所解析出来。 parsePropertyElements(ele, bd); parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null;}// 解析给定 bean 元素的属性子元素。public void parsePropertyElements(Element beanEle, BeanDefinition bd) { NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) { // 解析出参数值来，这里就真正的讲age的23，和name的bruis值解析出来并防止在一个组装的类里面存放着。 // 因为这里有两个bean，所以要循环调用两次parsePropertyElement()方法 parsePropertyElement((Element) node, bd); } }}// 解析属性元素public void parsePropertyElement(Element ele, BeanDefinition bd) { String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) { error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele); return; } this.parseState.push(new PropertyEntry(propertyName)); try { if (bd.getPropertyValues().contains(propertyName)) { error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele); return; } Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); // 就是这一步，将K为age、name，值分别为23、bruis的KV对存放在了Spring容器里。 bd.getPropertyValues().addPropertyValue(pv); } finally { this.parseState.pop(); }} 总结：该方法实际上实现了容器的初始化以及BeanDefinition的注册与加载，方便后续Bean的创建和加载 容器的初始化过程如下： 第一个过程是Resource定位过程。这个Resource定位过程指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用都提供了统一接口。这个定位过程类似于容器寻找数据的过程，就像使用水桶装水先要把水找到一样。 第二个过程是BeanDefinition的载入。这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。下面介绍这个数据结构的详细定义。具体来说，这个BeanDefinition实际上就是POJO对象在IOC容器的抽象，通过这个BeanDefinition定义的数据结构，使IOC能够方便地对POJO对象进行管理。 第三个过程是向IOC容器注册这些BeanDefinition的过程，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的。这个注册过程把载入过程中解析到的BeanDefinition向IOC容器进行注册。通过上面的分析，我们知道IOC内部将BeanDefinition注册到了ConcurrentHashMap中。 3.5 prepareBeanFactory prepareBeanFactory（AbstractApplicationContext.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 配置工厂的标准上下文特征，例如上下文的 ClassLoader 和后处理器*/protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 告诉内部 bean 工厂使用上下文的类加载器等。 beanFactory.setBeanClassLoader(getClassLoader()); if (!shouldIgnoreSpel) { beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); } beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 使用上下文回调配置 bean 工厂。 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class); // BeanFactory 接口未在普通工厂中注册为可解析类型。 // MessageSource 作为 bean 注册（并为自动装配找到）。 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 将用于检测内部 bean 的早期后处理器注册为 ApplicationListener。 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 检测 LoadTimeWeaver 并准备编织（如果找到）。 if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // 为类型匹配设置一个临时 ClassLoader。 beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册默认环境 bean。 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) { beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup()); }} 3.6 postProcessBeanFactory postProcessBeanFactory（AbstractApplicationContext.class） 1234567/* 在标准初始化之后修改应用程序上下文的内部 bean 工厂。所有 bean 定义都将被加载， 但还没有 bean 被实例化。这允许在某些 ApplicationContext 实现中注册特殊的 BeanPostProcessors 等。 简单来说，就是允许我们在bean实例化之前修改bean的定义信息即BeanDefinition的信息*/protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {} 3.7 invokeBeanFactoryPostProcessors invokeBeanFactoryPostProcessors （AbstractApplicationContext.class） 1234567891011// 实例化并调用所有已注册的 BeanFactoryPostProcessor bean，如果给定，则尊重显式顺序。必须在单例实例化之前调用。protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); }} 3.8 registerBeanPostProcessors registerBeanPostProcessors （AbstractApplicationContext.class） 123456/* 实例化并注册所有 BeanPostProcessor bean，如果给定，则尊重显式顺序。必须在应用程序 bean 的任何实例化之前调用。*/protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);} 3.9 initMessageSource initMessageSource（AbstractApplicationContext.class） 123456789101112131415161718192021222324252627282930/* 初始化消息源。如果没有在此上下文中定义，则使用父级。*/protected void initMessageSource() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) { this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); // 使 MessageSource 感知父 MessageSource。 if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) { HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource; if (hms.getParentMessageSource() == null) { // 如果尚未注册父消息源，则仅将父上下文设置为父消息源。 hms.setParentMessageSource(getInternalParentMessageSource()); } } if (logger.isTraceEnabled()) { logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;); } } else { // 使用空 MessageSource 能够接受 getMessage 调用。 DelegatingMessageSource dms = new DelegatingMessageSource(); dms.setParentMessageSource(getInternalParentMessageSource()); this.messageSource = dms; beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource); if (logger.isTraceEnabled()) { logger.trace(&quot;No '&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;' bean, using [&quot; + this.messageSource + &quot;]&quot;); } }} 3.10 initApplicationEventMulticaster initApplicationEventMulticaster（AbstractApplicationContext.class） 123456789101112131415161718192021/* 初始化 ApplicationEventMulticaster。如果上下文中没有定义，则使用 SimpleApplicationEventMulticaster。*/protected void initApplicationEventMulticaster() { ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) { this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (logger.isTraceEnabled()) { logger.trace(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;); } } else { this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); if (logger.isTraceEnabled()) { logger.trace(&quot;No '&quot; + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + &quot;' bean, using &quot; + &quot;[&quot; + this.applicationEventMulticaster.getClass().getSimpleName() + &quot;]&quot;); } }} 3.11 onRefresh onRefresh（AbstractApplicationContext.class） 123456/* 可以重写以添加特定于上下文的刷新工作的模板方法。在单例实例化之前调用特殊 bean 的初始化。这个实现是空的。*/protected void onRefresh() throws BeansException { // 对于子类：默认情况下什么都不做。} 3.12 registerListeners registerListeners（AbstractApplicationContext.class） 123456789101112131415161718192021protected void registerListeners() { // 首先注册静态指定的监听器。 for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // 不要在这里初始化 FactoryBeans：我们需要让所有常规 bean 保持未初始化状态，以让后处理器应用于它们！ String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // 发布早期应用程序事件，因为我们终于有了一个多播器...... Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (!CollectionUtils.isEmpty(earlyEventsToProcess)) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } }} 3.12 finishBeanFactoryInitialization finishBeanFactoryInitialization（AbstractApplicationContext.class） 1234567891011121314151617181920212223242526272829303132/* 完成此上下文的 bean 工厂的初始化，初始化所有剩余的单例 bean。*/protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // 为此上下文初始化转换服务。 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // 如果之前没有注册过任何 BeanFactoryPostProcessor（例如 PropertySourcesPlaceholderConfigurer bean）， // 则注册一个默认的嵌入值解析器：此时，主要用于解析注释属性值。 if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal)); } // 尽早初始化 LoadTimeWeaverAware bean，以便尽早注册它们的转换器。 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // 停止使用临时 ClassLoader 进行类型匹配。 beanFactory.setTempClassLoader(null); // 允许缓存所有 bean 定义元数据，而不是期望进一步的更改。 beanFactory.freezeConfiguration(); // 实例化所有剩余的（非惰性初始化）单例。 beanFactory.preInstantiateSingletons();} ​ 这里的懒加载的意思，指的是bean单例不是在Spring容器初始化的时候就创建的，而是在要使用该bean的时候，才会创建该bean。 preInstantiateSingletons（DefaultListableBeanFactory.class） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic void preInstantiateSingletons() throws BeansException { if (logger.isTraceEnabled()) { logger.trace(&quot;Pre-instantiating singletons in &quot; + this); } // 迭代一个副本以允许 init 方法依次注册新的 bean 定义。 // 虽然这可能不是常规工厂引导程序的一部分，但它确实可以正常工作。 // 获取所有的bean定义的名字，并保存在集合List里面。 List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // 触发所有非延迟单例bean的初始化... for (String beanName : beanNames) { // 触发所有适用bean的后初始化回调 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { if (isFactoryBean(beanName)) { Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) { FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged( (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } } else { getBean(beanName); } } } // 为所有适用的 bean 触发初始化后回调... for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { StartupStep smartInitialize = this.getApplicationStartup().start(&quot;spring.beans.smart-initialize&quot;) .tag(&quot;beanName&quot;, beanName); SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { smartSingleton.afterSingletonsInstantiated(); return null; }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } smartInitialize.end(); } }} getBean（AbstractBeanFactory.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159@Overridepublic Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false);}/* 返回指定 bean 的一个实例，该实例可以是共享的，也可以是独立的。*/protected &lt;T&gt; T doGetBean( String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException { // 去除name上存在的工厂bean的前缀 String beanName = transformedBeanName(name); Object beanInstance; // 快速判断单例缓存中是否存在该bean，如果存在则返回单例bean；否则返回null Object sharedInstance = getSingleton(beanName); // &lt;-------------- if (sharedInstance != null &amp;&amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName + &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } // 从单例缓存中获取单例bean beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { // 如果我们已经在创建这个 bean 实例，则失败：我们可能在循环引用中。 if (isPrototypeCurrentlyInCreation(beanName)) { throw new BeanCurrentlyInCreationException(beanName); } // 检查此工厂中是否存在 bean 定义。 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // 未找到 -&gt; 检查父级。 String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) { return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); } else if (args != null) { // 使用显式参数委托给父级。 return (T) parentBeanFactory.getBean(nameToLookup, args); } else if (requiredType != null) { // 没有 args -&gt; 委托给标准 getBean 方法。 return parentBeanFactory.getBean(nameToLookup, requiredType); } else { return (T) parentBeanFactory.getBean(nameToLookup); } } if (!typeCheckOnly) { markBeanAsCreated(beanName); // 将指定的 bean 标记为已创建（或即将创建）。这允许 bean 工厂优化其缓存以重复创建指定的 bean } StartupStep beanCreation = this.applicationStartup.start(&quot;spring.beans.instantiate&quot;) .tag(&quot;beanName&quot;, name); try { if (requiredType != null) { beanCreation.tag(&quot;beanType&quot;, requiredType::toString); } RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 保证当前 bean 所依赖的 bean 的初始化。 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } registerDependentBean(dep, beanName); try { getBean(dep); } catch (NoSuchBeanDefinitionException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex); } } } // 创建 bean 实例。 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&gt; { try { return createBean(beanName, mbd, args); // &lt; ----------------- } catch (BeansException ex) { // 从单例缓存中显式删除实例：它可能已被创建过程急切地放在那里，以允许循环引用解析。 // 还要删除任何接收到对 bean 的临时引用的 bean。 destroySingleton(beanName); throw ex; } }); beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } else if (mbd.isPrototype()) { // 这是一个原型 -&gt; 创建一个新实例。 Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } else { String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) { throw new IllegalStateException(&quot;No scope name defined for bean '&quot; + beanName + &quot;'&quot;); } Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;); } try { Object scopedInstance = scope.get(beanName, () -&gt; { beforePrototypeCreation(beanName); try { return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } }); beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new ScopeNotActiveException(beanName, scopeName, ex); } } } catch (BeansException ex) { beanCreation.tag(&quot;exception&quot;, ex.getClass().toString()); beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage())); cleanupAfterBeanCreationFailure(beanName); throw ex; } finally { beanCreation.end(); } } return adaptBeanInstance(name, beanInstance, requiredType);} getSingleton（DefaultSingletonBeanRegistry.class） 123456789101112131415161718192021222324252627282930313233343536@Override@Nullablepublic Object getSingleton(String beanName) { return getSingleton(beanName, true);}/* 返回在给定名称下注册的（原始）单例对象。 检查已经实例化的单例，还允许对当前创建的单例进行早期引用（解决循环引用）。*/@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) { // 快速检查没有完整单例锁的现有实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) { synchronized (this.singletonObjects) { // 在完整的单例锁中一致地创建早期引用 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) { ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } } } return singletonObject;} createBean（AbstractAutowireCapableBeanFactory.class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342/* 此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等。*/@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { if (logger.isTraceEnabled()) { logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;); } RootBeanDefinition mbdToUse = mbd; // 确保此时实际解析了 bean 类，并克隆 bean 定义以防动态解析的 Class 无法存储在共享的合并 bean 定义中。 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // 准备方法覆盖 try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); } try { // 调用实例化前的后置处理器，在这个后置处理器中可以对bean进行处理，可以返回由后置处理器处理的bean而不是被实例化的bean。 // 换句话说就是这里可以拦截住bean的实例化 // Spring的后置处理器后面有机会再专门写一篇博文来总结学习一下 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); } try { Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) { logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;); } return beanInstance; } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) { // 先前检测到的异常已经具有正确的 bean 创建上下文，或者要与 DefaultSingletonBeanRegistry 通信的非法单例状态。 throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex); }}/* 正在的创建一个bean，并且按照配置文件的配置来实例化该bean。如果没有初始化前的后置处理器的调用，则调用该方法。*/protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { // 创建一个包装类，用于包装真正要创建的bean。 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 使用适当的实例化策略例如：工厂方法、构造函数自动装配或者简单实例化 来为指定bean创建新的实例。 // 这里仅仅是简单的实例化，为bean设置默认初始值 // 也就是name为null，age为0。此时instanceWrapper任然还只是一个包装bean，并不是一个真正意义上的person类bean。 // 1. 实例化 instanceWrapper = createBeanInstance(beanName, mbd, args); } // 终于，我们千辛万苦打断点调试来到了这一步，就是这一步， 获得了我们想要的person类bean。 // 只需要在BeanWrapper里取出WrapperInstance即可。 // 接下来就是要拿这个创建好的bean和BeanDefinition进行实例化了。 Object bean = instanceWrapper.getWrappedInstance(); // 获取bean的类型 Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // 调用后置处理器去修改bean的定义信息。 synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, ex); } mbd.postProcessed = true; } } // 即使被 BeanFactoryAware 等生命周期接口触发，也急切地缓存单例以解析循环引用。 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(&quot;Eagerly caching bean '&quot; + beanName + &quot;' to allow for resolving potential circular references&quot;); } addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); } // 实例化一个真正使用的bean。 Object exposedObject = bean; try { // 2. 属性赋值 populateBean(beanName, mbd, instanceWrapper); // &lt;-------------------- // 3. 初始化 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); } } if (earlySingletonExposure) { Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;); } } } } // 销毁注册回调接口 try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); } return exposedObject;}/* 使用 bean 定义中的属性值填充给定 BeanWrapper 中的 bean 实例。*/protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // 让任何 InstantiationAwareBeanPostProcessors 有机会在设置属性之前修改 bean 的状态。 // 例如，这可以用于支持字段注入的样式。 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { return; } } } // 取出BeanDefinition里的属性值 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); int resolvedAutowireMode = mbd.getResolvedAutowireMode(); // 如果设置的是自动装配模式，则由自动装配来进行赋值 if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过bean名自动装配 if (resolvedAutowireMode == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // 通过bean类型自动装配 if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) { if (pvs == null) { pvs = mbd.getPropertyValues(); } for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) { return; } } pvs = pvsToUse; } } if (needsDepCheck) { if (filteredPds == null) { filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); } checkDependencies(beanName, mbd, filteredPds, pvs); } // 这里的PropertyValues已经包含了bean字段属性的设置值了 if (pvs != null) { applyPropertyValues(beanName, mbd, bw, pvs); }}/* 应用给定的属性值，解析对此 bean 工厂中其他 bean 的任何运行时引用。必须使用深拷贝，所以我们不会永久修改这个属性。*/protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) { if (pvs.isEmpty()) { return; } if (System.getSecurityManager() != null &amp;&amp; bw instanceof BeanWrapperImpl) { ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext()); } MutablePropertyValues mpvs = null; // 源属性值 List&lt;PropertyValue&gt; original; if (pvs instanceof MutablePropertyValues) { mpvs = (MutablePropertyValues) pvs; if (mpvs.isConverted()) { // Shortcut: use the pre-converted values as-is. try { bw.setPropertyValues(mpvs); return; } catch (BeansException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex); } } original = mpvs.getPropertyValueList(); } else { original = Arrays.asList(pvs.getPropertyValues()); } TypeConverter converter = getCustomTypeConverter(); if (converter == null) { converter = bw; } BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); // 拷贝值；创建一个深拷贝副本，应用于任何bean引用此bean的情况。 List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size()); boolean resolveNecessary = false; for (PropertyValue pv : original) { if (pv.isConverted()) { deepCopy.add(pv); } else { String propertyName = pv.getName(); Object originalValue = pv.getValue(); if (originalValue == AutowiredPropertyMarker.INSTANCE) { Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod(); if (writeMethod == null) { throw new IllegalArgumentException(&quot;Autowire marker for property without write method: &quot; + pv); } originalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true); } Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); Object convertedValue = resolvedValue; boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName); if (convertible) { convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter); } // 可能在合并的bean定义中存储转换后的值，以避免为每个创建的bean实例重新转换。 if (resolvedValue == originalValue) { if (convertible) { pv.setConvertedValue(convertedValue); } deepCopy.add(pv); } else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp; !((TypedStringValue) originalValue).isDynamic() &amp;&amp; !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) { pv.setConvertedValue(convertedValue); deepCopy.add(pv); } else { resolveNecessary = true; deepCopy.add(new PropertyValue(pv, convertedValue)); } } } if (mpvs != null &amp;&amp; !resolveNecessary) { mpvs.setConverted(); } // 将深拷贝属性数组填充到beanWrapper中。这里就真正的将属性值填充到了bean上，实现了 try { bw.setPropertyValues(new MutablePropertyValues(deepCopy)); } catch (BeansException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex); }} 3.13 finishRefresh finishRefresh（AbstractApplicationContext.class） 123456789101112131415161718192021/* 完成此上下文的刷新，调用 LifecycleProcessor 的 onRefresh() 方法并发布 ContextRefreshedEvent。*/protected void finishRefresh() { // 清除上下文级别的资源缓存（例如扫描中的 ASM 元数据）。 clearResourceCaches(); //为此上下文初始化生命周期处理器。 initLifecycleProcessor(); // 首先将刷新传播到生命周期处理器。 getLifecycleProcessor().onRefresh(); // 发布最终事件。 publishEvent(new ContextRefreshedEvent(this)); // 参与 LiveBeansView MBean（如果处于活动状态）。 if (!NativeDetector.inNativeImage()) { LiveBeansView.registerApplicationContext(this); }} ​ 经过上面的分析，就知道真正的对bean赋值填充是在AbstractAutowireCapableBeanFactory.class类里的applyPropertyValues方法里的，并且是通过对原属性值进行了一次深拷贝，然后将深拷贝后的属性值填充到bean里的。 4. 总结​ 本次源码分析，主要还是对容器的创建与初始化进行分析，也就是obtainFreshBeanFactory 和finishBeanFactoryInitialization这两个函数，其他函数是对其的加工或者预处理，留到后面再详细展开。 参考(99条消息) Spring和Spring Framework的理解_海TAO的博客-CSDN博客_springframework和spring JavaSourceCodeLearning/深入Spring源码系列（二）——深入Spring容器，通过源码阅读和时序图来彻底弄懂Spring容器（上）","link":"/2022/02/08/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Spring Bean生命周期","text":"1 前言​ Bean是由Spring IoC容器实例化，组装和管理的对象，并且Spring Bean的生命周期完全由容器控制。这里所说的生命周期主要是指singleton bean，对于prototype的bean，Spring在创建好交给使用者后将不会管理后续的生命周期。 ​ 对于Spring Bean的生命周期，本文将会从以下两部分将： 生命周期的概要流程 扩展点的作用 2 Bean生命周期概述​ 我们知道对于普通的Java对象来说，它们的生命周期是： 创建阶段(Created) 应用阶段(In Use) 不可见阶段(Invisible) 不可达阶段(Unreachable) 收集阶段(Collected) 终结阶段(Finalized) 对象空间重分配阶段(De-allocated) ​ 而对于Spring Bean来说，可以概述为4个阶段： 实例化（Instantiation） 属性赋值（Populate） 初始化（Initialization） 销毁（Destruction） 从图中分析 实例化：第1步，实例化一个bean对象 属性赋值：第2步，为bean对象设置相关属性和依赖 初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用； 销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。 ​ 下面结合代码来直观的看下， 12345678910111213141516171819202122232425// AbstractAutowireCapableBeanFactory.javaprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // 1. 实例化 BeanWrapper instanceWrapper = null; if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } Object exposedObject = bean; try { // 2. 属性赋值 populateBean(beanName, mbd, instanceWrapper); // 3. 初始化 exposedObject = initializeBean(beanName, exposedObject, mbd); } // 4. 销毁-注册回调接口 try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } return exposedObject;} ​ 由于初始化较复杂，包含了第3~7步，所以我们进到 initializeBean() 方法里具体看下其过程（注释的序号对应图中序号）： 123456789101112131415161718192021222324252627282930313233343536// AbstractAutowireCapableBeanFactory.javaprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { // 3. 检查 Aware 相关接口并设置相关依赖 if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } // 4. BeanPostProcessor 前置处理 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } // 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法 // 6. 若配置自定义的 init-method方法，则执行 try { invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } // 7. BeanPostProceesor 后置处理 if (mbd == null || !mbd.isSynthetic()) { wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} ​ 在 invokInitMethods() 方法中会检查 InitializingBean 接口和 init-method 方法 ​ 销毁的过程也与其类似： 12345678910111213141516171819202122232425262728// DisposableBeanAdapter.javapublic void destroy() { // 9. 若实现 DisposableBean 接口，则执行 destory()方法 if (this.invokeDisposableBean) { try { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; { ((DisposableBean) this.bean).destroy(); return null; }, this.acc); } else { ((DisposableBean) this.bean).destroy(); } } } // 10. 若配置自定义的 detory-method 方法，则执行 if (this.destroyMethod != null) { invokeCustomDestroyMethod(this.destroyMethod); } else if (this.destroyMethodName != null) { Method methodToInvoke = determineDestroyMethod(this.destroyMethodName); if (methodToInvoke != null) { invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke)); } }} ​ 这里额外说一下为什么JVM类加载是初始化再实例化，而Spring Bean是先实例化再初始化，有什么不同？（刚开始困扰了一会儿QAQ） ​ 首先，要明确。类加载是JVM的基本过程，而Spring是在其上层的实现，这两个不在同个层次 ​ 在JVM中，初始化是在类级别的，主要功能是为静态成员赋值，执行静态代码块，执行&lt;clinit&gt;方法。实例化是指在堆区分配空间，执行实例对象初始化，设置引用变量指向刚分配的内存地址（注意实例化也有一个初始化，这次初始化就会调用构造函数了，这是实例对象级别的） ​ 在Spring中，实例化就是创造出一个bean对象了，包含了JVM的初始化和实例化；初始化就是给对象中的属性赋值，相当于人为操作。 3 扩展点的作用3.1 Aware接口​ 若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源。 Spring 中提供的 Aware 接口有： BeanNameAware：注入当前 bean 对应 beanName； BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader； BeanFactoryAware：注入 当前BeanFactory容器 的引用。 其代码实现如下： 123456789101112131415// AbstractAutowireCapableBeanFactory.javaprivate void invokeAwareMethods(final String beanName, final Object bean) { if (bean instanceof Aware) { if (bean instanceof BeanNameAware) { ((BeanNameAware) bean).setBeanName(beanName); } if (bean instanceof BeanClassLoaderAware) { ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); } if (bean instanceof BeanFactoryAware) { ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); } }} ​ 以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。 EnvironmentAware：注入 Enviroment，一般用于获取配置属性； EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析； ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。 123456789101112131415161718192021222324252627// ApplicationContextAwareProcessor.javaprivate void invokeAwareInterfaces(Object bean) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware)bean).setMessageSource(this.applicationContext); } if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext); }} 3.2 容器级的方法（BeanPostProcessor 一系列接口） 3.2.1 InstantiationAwareBeanPostProcessor 源码分析​ 从源码中发现InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor 12345678910111213141516171819202122232425262728293031323334package org.springframework.beans.factory.config;import java.beans.PropertyDescriptor;import org.springframework.beans.BeansException;import org.springframework.beans.PropertyValues;import org.springframework.lang.Nullable;public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor { @Nullable default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException { return null; } default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { return true; } @Nullable default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { return null; } @Deprecated @Nullable default PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException { return pvs; }} 1234567891011121314151617package org.springframework.beans.factory.config;import org.springframework.beans.BeansException;import org.springframework.lang.Nullable;public interface BeanPostProcessor { @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; }} InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 调用点 Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：InstantiationAwareBeanPostProcessor接口中的postProcessBeforeInstantiation，在实例化之前调用。BeanPostProcessor接口中的postProcessAfterInitialization，在实例化之后调用。 12345678910111213141516171819202122232425262728293031/* org.spring framework.beans . factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation 作用：在实例化之前解析是否有快捷创建的Bean，既是通过postProcessBeforeInstantiation返回的Bean 内部调用两个重要的方法: 1. applyBeanPostProcessorsBeforeInstantiation: 内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用J 2. applyBeanPostProcessorsAfterInitialization: 如果postProcessBeforeInstantiation方法返回了快捷的Bean，内部遍历调用postProcessBeforeInstantiation方法【在初始化之后调用】*/@Nullableprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { Class&lt;?&gt; targetType = determineTargetType(beanName, mbd); if (targetType != null) { // 调用方法，内部遍历调用postProcessBeforeInstantiation方法【在实例化之前调用】 bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); // 如果返回了快捷的Bean if (bean != null) { //如果postProcessBeforeInstantiation方法返回了快捷的Bean， // 内部遍历调用 postProcessBeforeInstantiation方法【在初始化之后调用】 bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean;} applyBeanPostProcessorsBeforeInstantiation 12345678910111213141516/* 将 InstantiationAwareBeanPostProcessors 应用于指定的 bean 定义（按类和名称）， 调用它们的 postProcessBeforeInstantiation 方法。任何返回的对象都将用作 bean， 而不是实际实例化目标 bean。来自后处理器的空返回值将导致目标 bean 被实例化。*/@Nullableprotected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) { // getBeanPostProcessorCache返回预过滤后处理器的内部缓存，如有必要，重新（重新）构建它。 for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { Object result = bp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } return null;} applyBeanPostProcessorsAfterInitialization 1234567891011121314151617/* 作用:遍历调用postProcessAfterInitialization*/@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) { Object current = processor.postProcessAfterInitialization(result, beanName); if (current == null) { return result; } result = current; } return result;} InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation 调用点 boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException正常情况下在实例化之后在执行populateBean之前调用返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的postProcessPropertyValues将不会执行,但是初始化和BeanPostProcessor的仍然会执行。 1234567891011121314151617181920212223242526protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) { if (bw == null) { if (mbd.hasPropertyValues()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { // 执行postProcessAfterInstantiation方法 if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { // 返回结果为false，那么赋值continuewithPropertyPopulation=false，表示不继续执行属性填充 return; } } } ....} 3.2.2 BeanPostProcessor 源码分析​ initializeBean是该接口源码的入口 ​ 进入初始化接口： 1234567891011121314151617181920212223242526272829303132protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // 初始化前执行的方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } if (mbd == null || !mbd.isSynthetic()) { // 初始化后执行的方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization 12345678910111213141516@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; // 1. 获取到所有的后置处理器 getBeanPostProcessors() for (BeanPostProcessor processor : getBeanPostProcessors()) { // 2. 调用后置处理器的方法 Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) { return result; } result = current; } return result;} ​ 进入postProcessBeforeInitialization方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization@Override@Nullablepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware || bean instanceof ApplicationStartupAware)) { return bean; } AccessControlContext acc = null; if (System.getSecurityManager() != null) { acc = this.applicationContext.getBeanFactory().getAccessControlContext(); } if (acc != null) { AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; { invokeAwareInterfaces(bean); return null; }, acc); } else { invokeAwareInterfaces(bean); } return bean;}private void invokeAwareInterfaces(Object bean) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware) bean).setMessageSource(this.applicationContext); } if (bean instanceof ApplicationStartupAware) { ((ApplicationStartupAware) bean).setApplicationStartup(this.applicationContext.getApplicationStartup()); } if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); }} ​ ApplicationContextAwareProcessor#postProcessBeforeInitialization 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 invokeAwareInterfaces(bean)，向容器中添加相关接口的上下文环境。 3.3 InitializingBean 和 init-methodInitializingBean 和 init-method 是 Spring 为 bean 初始化提供的扩展点。 InitializingBean接口 的定义如下： 123public interface InitializingBean { void afterPropertiesSet() throws Exception;} 在 afterPropertiesSet() 方法写初始化逻辑。 指定 init-method 方法，指定初始化方法： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;demo&quot; class=&quot;com.w1nd.Demo&quot; init-method=&quot;init()&quot;/&gt; &lt;/beans&gt; DisposableBean 和 destory-method 与上述类似，就不描述了。 4. 总结​ 最后总结下如何记忆 Spring Bean 的生命周期： 首先是实例化、属性赋值、初始化、销毁这 4 个大阶段； 再是初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作； 销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。 参考如何记忆 Spring Bean 的生命周期 - 掘金 (juejin.cn) 一文读懂 Spring Bean 的生命周期 - SegmentFault 思否 (104条消息) JVM类 和 spring Bean 的实例化 和 初始化区别以及顺序_秋楓的博客-CSDN博客_spring实例化和初始化的区别 java类的初始化和实例化区别 - pu20065226 - 博客园 (cnblogs.com) 聊聊spring的那些扩展机制 - 掘金 (juejin.cn)","link":"/2022/02/10/%E6%A1%86%E6%9E%B6/Spring/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"红黑树","text":"1 概念1. 1 定义（1）结点是红色或黑色 （2）根节点是黑色 （3）所有叶子都是黑色（叶子是NULL结点） （4）每个红色节点的两个子节点一定都是黑色。不能有两个红色节点相连。 （5）任意一节点到每个叶子节点的路径都包含数量相同的黑结点。俗称：黑高！ 红黑树实例图 ​ 红黑树并不是一个完美平衡二叉查找树，从图上可以看到，根结点P的左子树显然比右子树高， ​ 但左子树和右子树的黑结点的层数是相等的，也就是说，任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。 ​ 所以我们叫红黑树这种平衡为黑色完美平衡。 ​ 红黑树的性质讲完了，只要这棵树满足以上性质，这棵树就是趋近与平衡状态的。 1.2 性质​ 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长 1.3 关于红黑树操作​ 在了解这些操作前，先明确三个小操作 变色：结点的颜色由红变黑或由黑变红。 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变 左旋图示 右旋图示 另外，约定一些节点的称呼 1.3.1 插入插入操作包括两部分工作： 查找插入的位置 插入后自平衡 ​ 注意：插入节点，必须为红色，理由很简单，红色在父节点（如果存在）为黑色节点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。 ​ 但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。 红黑树插入节点情景分析情景1：红黑树为空树​ 最简单的一种情景，直接把插入结点作为根结点就行 ​ 注意：根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。 情景2：插入结点的Key已存在​ 处理：更新当前节点的值，为插入节点的值 情景3：插入结点的父结点为黑结点​ 由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。 ​ 情景4：插入节点的父节点为红色​ 再次回想下红黑树的性质2：根结点是黑色。如果插入节点的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。 ​ 这一点很关键，因为后续的旋转操作肯定需要祖父结点的参与。 ​ 插入情景4.1：叔叔结点存在并且为红结点 依据红黑树性质4可知，红色节点不能相连 ==&gt; 祖父结点肯定为黑结点； 因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红 处理： 将P和U节点改为黑色 将PP改为红色 将PP设置为当前节点，进行后续处理 ​ 可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理； 但如果PP的父结点是红色，则违反红黑树性质了。所以需要将PP设置为当前节点，继续做插入操作自平衡处理，直到平衡为止。 插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点 注意：单纯从插入前来看，叔叔节点非红即空（NIL节点），否则的话破坏了红黑树性质5，此路径会比其它路径多一个黑色节点。 ​ 插入情景4.2.1：新插入节点，为其父节点的左子节点（LL红色情况） ​ 处理： 变颜色：将P设置为黑色，将PP设置为红色 对PP节点进行右旋 插入情景4.2.2：新插入节点，为其父节点的右子节点（LR红色情况） 处理： 对P进行左旋 将P设置为当前节点，得到LL红色情况 按照LL红色情况处理（1.变颜色 2.右旋PP） 插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点 该情景对应情景4.2，只是方向反转，直接看图。 插入情景4.3.1：新插入节点，为其父节点的右子节点（RR红色情况） 处理： 变颜色：将P设置为黑色，将PP设置为红色 对PP节点进行左旋 插入情景4.3.2：新插入节点，为其父节点的左子节点（RL红色情况） 处理： 对P进行右旋 将P设置为当前节点，得到RR红色情况 按照RR红色情况处理（1.变颜色 2.左旋PP） 2 代码实现2.1 RBTree.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372package DataStructure.rbtree;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * &lt;p&gt; * ②创建RBNode * &lt;p&gt; * ③辅助方法定义：parentOf(node)，isRed(node)，setRed(node)，setBlack(node)，inOrderPrint() * &lt;p&gt; * ④左旋方法定义：leftRotate(node) * &lt;p&gt; * ⑤右旋方法定义：rightRotate(node) * &lt;p&gt; * ⑥公开插入接口方法定义：insert(K key, V value); * &lt;p&gt; * ⑦内部插入接口方法定义：insert(RBNode node); * &lt;p&gt; * ⑧修正插入导致红黑树失衡的方法定义：insertFIxUp(RBNode node); * &lt;p&gt; * ⑨测试红黑树正确性 */public class RBTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private static final boolean RED = true; // 红 private static final boolean BLACK = false; // 黑 @Data @AllArgsConstructor @NoArgsConstructor static class RBNode&lt;K extends Comparable&lt;K&gt;, V&gt; { private RBNode parent; //父结点 private RBNode left; // 左子树 private RBNode right; // 右子树 private boolean color; // 颜色 private K key; //键 private V value; // 值 } /** * 树根的引用 */ private RBNode root; public RBNode getRoot() { return this.root; } private RBNode parentOf(RBNode node) { if (node != null) { return node.parent; } return null; } /** * 当前结点是否为红色 * @param node * @return */ private boolean isRed(RBNode node) { return node != null &amp;&amp; node.color == RED; } /** * 当前结点是否为黑色 * @param node * @return */ private boolean isBlack(RBNode node) { return node != null &amp;&amp; node.color == BLACK; } /** * 设置节点为红色 * * @param node */ private void setRed(RBNode node) { if (node != null) { node.color = RED; } } /** * 设置节点为黑色 * * @param node */ private void setBlack(RBNode node) { if (node != null) { node.color = BLACK; } } /** * 中序打印二叉树 */ public void inOrderPrint() { inOrderPrint(root); } private void inOrderPrint(RBNode node) { if (node != null) { inOrderPrint(node.left); System.out.println(&quot;key:&quot; + node.key + &quot;.value:&quot; + node.value); inOrderPrint(node.right); } } /** * 左旋方法 * 左旋示意图：左旋x节点 * p p * | | * x y * / \\ ----&gt; / \\ * lx y x ry * / \\ / \\ * ly ry lx ly * * 左旋做了几件事？ * 1.将x的右子节点指向y的左子节点(ly)，并且把y的左子节点更新为x * 2.当x的父节点(不为空时)，更新y的父节点为x的父节点，并将x的父节点 指定 子树(当前x的子树位置) 指定为y * 3.将x的父节点更新为y，将y的左子节点更新为x */ private void leftRotate(RBNode x) { RBNode y = x.right; x.right = y.left; // 1.将x的右子节点指向y的左子节点(ly)，并且把y的左子节点更新为x if (y.left != null) { y.left.parent = x; } // 2.当x的父节点(不为空时)，更新y的父节点为x的父节点，并将x的父节点 指定 子树(当前x的子树位置) 指定为y if (x.parent != null) { y.parent = x.parent; if (x == x.parent.left) { // 如果x是其父节点的左子节点，则将y放在x父节点的左边 x.parent.left = y; } else { x.parent.right = y; // 如果x是其父节点的右子节点，则将y放在x父节点的右边 } } else { // 说明x为根节点，此时需要更新y为根节点 的引用 this.root = y; this.root.parent = null; // 根节点无父节点 } // 3.将x的父节点更新为y，将y的左子节点更新为x x.parent = y; y.left = x; } /** * 右旋方法 * 右旋示意图：右旋y节点 * * p p * | | * y x * / \\ ----&gt; / \\ * x ry lx y * / \\ / \\ * lx ly ly ry * * 右旋都做了几件事？ * 1.将y的左子节点指向x的右子节点，并且更新x的右子节点的父节点为y * 2.当y的父节点不为空时，更新x的父节点为y的父节点，更新y的父节点的指定子节点（y当前位置） 为x * 3.更新y 的父节点为x ,更新x 的右子节点为y */ public void rightRotate(RBNode y) { RBNode x = y.left; y.left = x.right; // 1.将x的右子节点 赋值 给了 y 的左子节点，并且更新x的右子节点的父节点为 y if (x.right != null) { x.right.parent = y; } // 2.将y的父节点p（非空时）赋值给x的父节点，同时更新p的子节点为x（左或右） if (y.parent != null) { x.parent = y.parent; if (y == y.parent.left) { // 如果y是其父节点的左子节点，则将x放在y父节点的左边 y.parent.left = x; } else { // 如果y是其父节点的右子节点，则将x放在y父节点的右边 y.parent.right = x; } } else { // 说明y为根节点，此时需要更新x为根节点 的引用 this.root = x; x.parent = null; } // 3.将x的右子节点赋值为y，将y的父节点设置为x x.right = y; y.parent = x; } /** * public插入方法 * * @param key * @param value */ public void insert(K key, V value) { RBNode node = new RBNode&lt;&gt;(); node.setKey(key); node.setValue(value); // 新结点一定是红色 node.setColor(RED); insert(node); } /** * 插入节点 * @param node */ private void insert(RBNode node) { // 第一步：查找当前要插入节点node的父节点 RBNode parent = null; // 声明要插入节点node的父节点 RBNode x = this.root; while (x != null) { parent = x; /** * cmp &gt; 0 说明node.key 大于 x.key 需要到x 的右子树查找 * cmp == 0 说明node.key 等于 x.key 需要进行替换操作 * cmp &lt; 0 说明node.key 小于 x.key 需要到x 的左子树查找 */ int cmp = node.key.compareTo(x.key); if (cmp &gt; 0) { x = x.right; } else if (cmp == 0) { x.setValue(node.getValue()); return ; // 修改完后 就不再继续往下面的代码执行了 } else { x = x.left; } } /** * 退出上面的while循环后，到这里，说明树中没有相同key 的元素 * * 需要添加新元素node到 x(parent) 目前位置的左子树/右子树 */ node.parent = parent; if (parent != null) { // 判断node与parent的key谁大 int cmp = node.key.compareTo(parent.key); if (cmp &gt; 0) { // 当前node的key比parent 的key大，需要把node放入parent 的右子节点 parent.right = node; } else { // 当前node的key比parent 的key大，需要把node放入parent 的右子节点 parent.left = node; } } else { // parent == null; 说明为空树 this.root = node; // 直接给树根赋值为node } // 新元素node 加入树中之后，要调用修复红黑树平衡的方法 insertFixUp(node); } /** * 插入后修复红黑树平衡的方法 * |---情景1：如果红黑树为空树,需要将根节点染为黑色 * |---情景2：如果插入节点的key已经存在,(这种情况不需要处理,因为修改树中的值不会触发红黑树修复平衡方法) * |---情景3：如果插入节点的父节点为黑色,这种情况不需要处理,(参考红黑树的性质4和性指5去理解) * (因为所插入的路径中,黑色节点数没发生变化,所以红黑树依然平衡) * &lt;p&gt; * 情景4 需要去处理的情景 * |---情景4：插入节点的父节点为红色,(违反红黑树性质4,不能有两个红色节点相连) * |---情景4.1：叔叔节点存在，并且为红色（父-叔 双红） * 处理：将爸爸和叔叔染成黑色，将爷爷染成红色，并且再以爷爷节点为当前节点，进行下一轮处理 * |---情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树 * 处理： * |---情景4.2.1：插入节点为其父节点的左子节点（LL情况） * 处理：将父节点染为黑色，将爷爷染为红色，然后以爷爷节点右旋即可 * |---情景4.2.2：插入节点为其父节点的右子节点（LR情况） * 处理：将父节点进行一次左旋，得到LL双红情景(4.2.1),然后指定父节点为当前节点进行下一轮处理 * |---情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树 * |---情景4.3.1：插入节点为其父节点的右子节点（RR情况） * 处理：将父节点染为黑色，将爷爷节点染为红色，然后以爷爷节点左旋即可 * |---情景4.3.2：插入节点为其父节点的左子节点（RL情况） * 处理：以父节点进行一次右旋，得到RR双红情景(4.3.1),然后指定父节点为当前节点进行下一轮处理 */ private void insertFixUp(RBNode node) { RBNode parent = parentOf(node); // 当前节点的父节点 RBNode gparent = parentOf(parent); // 当前节点的爷爷节点 // 存在父节点且父节点为红色 if (parent != null &amp;&amp; isRed(parent)) { // 父节点是红色的，那么一定存在爷爷节点(性质2：根节点只能是黑色) // 父节点为爷爷节点的左子树 if (parent == gparent.left) { RBNode uncle = gparent.right; // 情景4.1：叔叔节点存在，并且为红色（父-叔 双红） // 将父和叔染色为黑色，再将爷爷染红，并将爷爷设置为当前节点，进入下一次循环判断 if (uncle != null &amp;&amp; isRed(uncle)) { setBlack(parent); setBlack(uncle); setRed(gparent); insertFixUp(gparent); return ; } // 情景4.2：叔叔节点不存在，或者为黑色，父节点为爷爷节点的左子树 if (uncle == null || isBlack(uncle)) { /** * 情景4.2.1：插入节点为其父节点的左子节点（LL情况） * 处理：将父节点染为黑色，将爷爷染为红色，然后以爷爷节点右旋即可 */ // 插入节点为其父节点的左子节点（LL情况）=&gt; // 变色（父节点变黑，爷爷节点变红），右旋爷爷节点 if (node == parent.left) { setBlack(parent); setRed(gparent); rightRotate(gparent); // 以gparent右旋 } /** * 情景4.2.2：插入节点为其父节点的右子节点（LR情况） * 处理：将父节点进行一次左旋，得到LL双红情景(4.2.1),然后指定父节点为当前节点进行下一轮处理 */ // 插入节点为其父节点的右子节点（LR情况）=&gt; // 左旋（父节点），当前节点设置为父节点，进入下一次循环 if (node == parent.right) { leftRotate(parent); // parent左旋 insertFixUp(parent); // 进行下一轮处理 return ; } } } else { // 父节点为爷爷节点的右子树 RBNode uncle = gparent.left; // 情景4.1：叔叔节点存在，并且为红色（父-叔 双红） // 将父和叔染色为黑色，再将爷爷染红，并将爷爷设置为当前节点，进入下一次循环判断 if (uncle != null &amp;&amp; isRed(uncle)) { setBlack(parent); setBlack(uncle); setRed(gparent); insertFixUp(gparent); return ; } // 情景4.3：叔叔节点不存在，或者为黑色，父节点为爷爷节点的右子树 if (uncle == null || isBlack(uncle)) { /** * 情景4.3.1：插入节点为其父节点的右子节点（RR情况） * 处理：将父节点染为黑色，将爷爷节点染为红色，然后以爷爷节点左旋即可 */ // 插入节点为其父节点的右子节点（RR情况）=&gt; // 变色（父节点变黑，爷爷节点变红），右旋爷爷节点 if (node == parent.right) { setBlack(parent); setRed(gparent); leftRotate(gparent); } /** * 情景4.3.2：插入节点为其父节点的左子节点（RL情况） * 处理：以父节点进行一次右旋，得到RR双红情景(4.3.1),然后指定父节点为当前节点进行下一轮处理 */ // 插入节点为其父节点的左子节点（RL情况） // 右旋（父节点）得到RR情况，当前节点设置为父节点，进入下一次循环 if (node == parent.left) { rightRotate(parent); insertFixUp(parent); return ; } } } } setBlack(this.root); }} 2.2 TreeOperation.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package DataStructure.rbtree;public class TreeOperation { /** 树的结构示例： 1 / \\ 2 3 / \\ / \\ 4 5 6 7 */ /** * 用于获得树的层数 * @param root * @return */ public static int getTreeDepth(RBTree.RBNode root) { return root == null ? 0 : (1 + Math.max(getTreeDepth(root.getLeft()), getTreeDepth(root.getRight()))); } /** * 将树的值写入数组 * @param currNode * @param rowIndex * @param columnIndex * @param res * @param treeDepth */ private static void writeArray(RBTree.RBNode currNode, int rowIndex, int columnIndex, String[][] res, int treeDepth) { // 保证输入的树不为空 if (currNode == null) return ; // 先将当前节点保存到二维数组中 res[rowIndex][columnIndex] = String.valueOf(currNode.getKey() + &quot;-&quot; + (currNode.isColor() ? &quot;R&quot; : &quot;B&quot;) + &quot;&quot;); // 计算当前位于树的第几层 int currLevel = ((rowIndex + 1) / 2); // 若到了最后一层，则返回 if (currLevel == treeDepth) return ; // 计算当前行到下一行，每个元素之间的间隔（下一行的列索引与当前元素的列缩影之间的间隔） int gap = treeDepth - currLevel - 1; // 对左儿子进行判断，若有左儿子，则记录相应的&quot;/&quot;与左儿子的值 if (currNode.getLeft() != null) { res[rowIndex + 1][columnIndex - gap] = &quot;/&quot;; writeArray(currNode.getLeft(), rowIndex + 2, columnIndex - gap * 2, res, treeDepth); } // 对右儿子进行判断，若有右儿子，则记录相应的&quot;\\&quot;与右儿子的值 if (currNode.getRight() != null) { res[rowIndex + 1][columnIndex + gap] = &quot;\\\\&quot;; writeArray(currNode.getRight(), rowIndex + 2, columnIndex + gap * 2, res, treeDepth); } } /** * 展示 * @param root */ public static void show(RBTree.RBNode root) { if (root == null) System.out.println(&quot;EMPTY!&quot;); // 得到树的深度 int treeDepth = getTreeDepth(root); // 最后一行的宽度为2的（n - 1）次方乘3，再加1 // 作为整个二维数组的宽度 int arrayHeight = treeDepth * 2 - 1; int arrayWidth = (2 &lt;&lt; (treeDepth - 2)) * 3 + 1; // 用一个字符串数组来存储每个位置应显示的元素 String[][] res = new String[arrayHeight][arrayWidth]; // 对数组进行初始化，默认为一个空格 for (int i = 0; i &lt; arrayHeight; i++) { for (int j = 0; j &lt; arrayWidth; j++) { res[i][j] = &quot; &quot;; } } // 从根节点开始，递归处理整个树 // res[0][(arrayWidth + 1)/ 2] = (char)(root.val + '0'); writeArray(root, 0, arrayWidth / 2, res, treeDepth); // 此时，已经将所有需要显示的元素储存到了二维数组中，将其拼接并打印即可 for (String[] line : res) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; line.length; i++) { sb.append(line[i]); if (line[i].length() &gt; 1 &amp;&amp; i &lt;= line.length - 1) { i += line[i].length() &gt; 4 ? 2 : line[i].length() - 1; } } System.out.println(sb.toString()); } }} 2.3 RBTreeTest.java123456789101112131415161718package DataStructure.rbtree;import java.util.Scanner;public class RBTreeTest { public static void main(String[] args) { RBTree&lt;String, Object&gt; rbtree = new RBTree(); //测试输入：ijkgefhdabc while(true) { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入key:&quot;); String key = sc.next(); rbtree.insert(key, null); TreeOperation.show(rbtree.getRoot()); } }}","link":"/2022/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"状态DP","slug":"状态DP","link":"/tags/%E7%8A%B6%E6%80%81DP/"},{"name":"背包DP","slug":"背包DP","link":"/tags/%E8%83%8C%E5%8C%85DP/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"序列DP","slug":"序列DP","link":"/tags/%E5%BA%8F%E5%88%97DP/"},{"name":"线性DP","slug":"线性DP","link":"/tags/%E7%BA%BF%E6%80%A7DP/"},{"name":"双周赛","slug":"双周赛","link":"/tags/%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"name":"周赛","slug":"周赛","link":"/tags/%E5%91%A8%E8%B5%9B/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"红黑树","slug":"红黑树","link":"/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}],"categories":[{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring","slug":"框架/Spring","link":"/categories/%E6%A1%86%E6%9E%B6/Spring/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}